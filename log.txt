
C:\Users\klano\Documents\version24>java -jar umlrsds.jar -cgtl cg/python2UML.cstl output/ast.txt 
Found plugin: uml2Ca
Found plugin: uml2Cb
Found plugin: uml2py
Found plugin: uml2py3
output/python2UML_out.txt
>> Text rule _1 |-->_1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1;\n\n_1`functionDefinitions\n}\n LHS variables = [_1]
>> Text rule _1 |-->_1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1;\n\n_1`functionDefinitions\n}\n LHS tokens = [_1]
>> Text rule _1 |-->_1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1;\n\n_1`functionDefinitions\n}\n RHS = _1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1;\n\n_1`functionDefinitions\n}\n
>>> found metafeature _1`classDefinitions for _1`
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>>> found metafeature _1`functionDefinitions for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classDefinitions, _1`nestedAttributeDefinitions, _1`functionDefinitions]
>> Text rule _1 _* |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n RHS = _1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n
>>> found metafeature _*`classDefinitions for _*`
>>> found metafeature _*`nestedAttributeDefinitions for _*`
>>> found metafeature _*`followingStatement for _*`
>>> found metafeature _*`functionDefinitions for _*`
>>> found metafeature _1`classDefinitions for _1`
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>>> found metafeature _1`functionDefinitions for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`classDefinitions, _*`nestedAttributeDefinitions, _*`followingStatement, _*`functionDefinitions, _1`classDefinitions, _1`nestedAttributeDefinitions, _1`functionDefinitions]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->_1 LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1 LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1 RHS = _1
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_1 LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1 LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1 RHS = _1
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1<when> _1 star_expr LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 star_expr LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 star_expr RHS = _1<when> _1 star_expr
+++ Condition lexicals:: [_1, star_expr]
>***> Rule with condition: [_1 star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->Sequence{ _1 } LHS variables = [_1]
>> Text rule _1 |-->Sequence{ _1 } LHS tokens = [_1]
>> Text rule _1 |-->Sequence{ _1 } RHS = Sequence{ _1 }
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , |-->Sequence{ _1 } LHS variables = [_1]
>> Text rule _1 , |-->Sequence{ _1 } LHS tokens = [_1, ,]
>> Text rule _1 , |-->Sequence{ _1 } RHS = Sequence{ _1 }
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1->union(_*`recurse)<when> _1 star_expr LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1->union(_*`recurse)<when> _1 star_expr LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1->union(_*`recurse)<when> _1 star_expr RHS = _1->union(_*`recurse)<when> _1 star_expr
+++ Condition lexicals:: [_1, star_expr]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1 star_expr]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 , _* |-->Sequence{_1}->union(_*`recurse) LHS variables = [_1, _*]
>> Text rule _1 , _* |-->Sequence{_1}->union(_*`recurse) LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->Sequence{_1}->union(_*`recurse) RHS = Sequence{_1}->union(_*`recurse)
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _2`collectPart(_1))<when> _2 comp_for LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _2`collectPart(_1))<when> _2 comp_for LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _2`collectPart(_1))<when> _2 comp_for RHS = _2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _2`collectPart(_1))<when> _2 comp_for
+++ Condition lexicals:: [_2, comp_for]
>>> found metafeature _2`domainPart for _2`
>>> found metafeature _2`variablePart for _2`
>>> found metafeature _2`selectPart for _2`
>>> found metafeature _2`variablePart for _2`
>>> found metafeature _2`collectPart for _2`
>***> Rule with condition: [_2 comp_for]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`domainPart, _2`variablePart, _2`selectPart, _2`collectPart]
>> Text rule for _1 in _2 |--> LHS variables = [_1, _2]
>> Text rule for _1 in _2 |--> LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |--> LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |--> LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->_2->characters()<when> _2 String LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->_2->characters()<when> _2 String LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->_2->characters()<when> _2 String RHS = _2->characters()<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->_2->characters()<when> _2 String LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2->characters()<when> _2 String LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2->characters()<when> _2 String RHS = _2->characters()<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->_2->keys()<when> _2 Map LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->_2->keys()<when> _2 Map LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->_2->keys()<when> _2 Map RHS = _2->keys()<when> _2 Map
+++ Condition lexicals:: [_2, Map]
>***> Rule with condition: [_2 Map]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->_2->keys()<when> _2 Map LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2->keys()<when> _2 Map LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2->keys()<when> _2 Map RHS = _2->keys()<when> _2 Map
+++ Condition lexicals:: [_2, Map]
>***> Rule with condition: [_2 Map]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->_2 LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->_2 LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->_2 RHS = _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->_2 LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2 LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_2 RHS = _2
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->_tuple<when> _1 multiple LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->_tuple<when> _1 multiple LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->_tuple<when> _1 multiple RHS = _tuple<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->_tuple<when> _1 multiple LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_tuple<when> _1 multiple LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_tuple<when> _1 multiple RHS = _tuple<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->_1 LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->_1 LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->_1 RHS = _1
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->_1_3`variableTailPart LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_1_3`variableTailPart LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_1_3`variableTailPart RHS = _1_3`variableTailPart
>>> found metafeature _3`variableTailPart for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`variableTailPart]
>> Text rule for _1 in _2 |-->; _tuple : _2<when> _1 multiple LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->; _tuple : _2<when> _1 multiple LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->; _tuple : _2<when> _1 multiple RHS = ; _tuple : _2<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->; _tuple : _2<when> _1 multiple LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->; _tuple : _2<when> _1 multiple LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->; _tuple : _2<when> _1 multiple RHS = ; _tuple : _2<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->; _1 : _2 LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->; _1 : _2 LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->; _1 : _2 RHS = ; _1 : _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->; _1 : _2_3`variableTailPart LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->; _1 : _2_3`variableTailPart LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->; _1 : _2_3`variableTailPart RHS = ; _1 : _2_3`variableTailPart
>>> found metafeature _3`variableTailPart for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`variableTailPart]
>> Text rule _1 |-->_1`variableTailPart<when> _1 comp_for LHS variables = [_1]
>> Text rule _1 |-->_1`variableTailPart<when> _1 comp_for LHS tokens = [_1]
>> Text rule _1 |-->_1`variableTailPart<when> _1 comp_for RHS = _1`variableTailPart<when> _1 comp_for
+++ Condition lexicals:: [_1, comp_for]
>>> found metafeature _1`variableTailPart for _1`
>***> Rule with condition: [_1 comp_for]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`variableTailPart]
>> Text rule if _1 |--> LHS variables = [_1]
>> Text rule if _1 |--> LHS tokens = [if, _1]
>> Text rule if _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 _2 |-->_2`variableTailPart LHS variables = [_1, _2]
>> Text rule if _1 _2 |-->_2`variableTailPart LHS tokens = [if, _1, _2]
>> Text rule if _1 _2 |-->_2`variableTailPart RHS = _2`variableTailPart
>>> found metafeature _2`variableTailPart for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`variableTailPart]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 |-->true LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->true LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->true RHS = true
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in _3`selectPart<when> _1 multiple LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in _3`selectPart<when> _1 multiple LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in _3`selectPart<when> _1 multiple RHS = let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in _3`selectPart<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`first for _1`
>>> found metafeature _1`third for _1`
>>> found metafeature _3`selectPart for _3`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_1`first, _1`third, _3`selectPart]
>> Text rule for _1 in _2 _3 |-->_3`selectPart LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->_3`selectPart LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->_3`selectPart RHS = _3`selectPart
>>> found metafeature _3`selectPart for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`selectPart]
>> Text rule _1 |-->true LHS variables = [_1]
>> Text rule _1 |-->true LHS tokens = [_1]
>> Text rule _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 |-->_1 LHS variables = [_1]
>> Text rule if _1 |-->_1 LHS tokens = [if, _1]
>> Text rule if _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 _2 |-->_1 & _2`selectPart LHS variables = [_1, _2]
>> Text rule if _1 _2 |-->_1 & _2`selectPart LHS tokens = [if, _1, _2]
>> Text rule if _1 _2 |-->_1 & _2`selectPart RHS = _1 & _2`selectPart
>>> found metafeature _2`selectPart for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`selectPart]
>> Text rule for _1 in _2 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple LHS variables = [_1, _2]
>> Text rule for _1 in _2 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple RHS = let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`first for _1`
>>> found metafeature _1`third for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`first, _1`third]
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple RHS = let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`first for _1`
>>> found metafeature _1`third for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_1`first, _1`third]
>> Text rule for _1 in _2 |--> LHS variables = [_1, _2]
>> Text rule for _1 in _2 |--> LHS tokens = [for, _1, in, _2]
>> Text rule for _1 in _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 _3 |--> LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 _3 |--> LHS tokens = [for, _1, in, _2, _3]
>> Text rule for _1 in _2 _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 |--> LHS variables = [_1]
>> Text rule if _1 |--> LHS tokens = [if, _1]
>> Text rule if _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 _2 |--> LHS variables = [_1, _2]
>> Text rule if _1 _2 |--> LHS tokens = [if, _1, _2]
>> Text rule if _1 _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 if _2 else _3 |-->if _2 then _1 else _3 endif LHS variables = [_1, _2, _3]
>> Text rule _1 if _2 else _3 |-->if _2 then _1 else _3 endif LHS tokens = [_1, if, _2, else, _3]
>> Text rule _1 if _2 else _3 |-->if _2 then _1 else _3 endif RHS = if _2 then _1 else _3 endif
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule lambda _1 : _2 |-->lambda _1 in (_2) LHS variables = [_1, _2]
>> Text rule lambda _1 : _2 |-->lambda _1 in (_2) LHS tokens = [lambda, _1, :, _2]
>> Text rule lambda _1 : _2 |-->lambda _1 in (_2) RHS = lambda _1 in (_2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule lambda : _2 |-->lambda $$ : OclAny in (_2) LHS variables = [_2]
>> Text rule lambda : _2 |-->lambda $$ : OclAny in (_2) LHS tokens = [lambda, :, _2]
>> Text rule lambda : _2 |-->lambda $$ : OclAny in (_2) RHS = lambda $$ : OclAny in (_2)
>***> Rule variables are: [_2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule not _1 |-->not(_1 = 0)<when> _1 real LHS variables = [_1]
>> Text rule not _1 |-->not(_1 = 0)<when> _1 real LHS tokens = [not, _1]
>> Text rule not _1 |-->not(_1 = 0)<when> _1 real RHS = not(_1 = 0)<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule not _1 |-->not(_1 = "")<when> _1 String LHS variables = [_1]
>> Text rule not _1 |-->not(_1 = "")<when> _1 String LHS tokens = [not, _1]
>> Text rule not _1 |-->not(_1 = "")<when> _1 String RHS = not(_1 = "")<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule not _1 |-->not(_1) LHS variables = [_1]
>> Text rule not _1 |-->not(_1) LHS tokens = [not, _1]
>> Text rule not _1 |-->not(_1) RHS = not(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 and _2 |-->if _1 = 0 then _1 else _2 endif<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 and _2 |-->if _1 = 0 then _1 else _2 endif<when> _1 real LHS tokens = [_1, and, _2]
>> Text rule _1 and _2 |-->if _1 = 0 then _1 else _2 endif<when> _1 real RHS = if _1 = 0 then _1 else _2 endif<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 and _2 |-->if _1 = "" then _1 else _2 endif<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 and _2 |-->if _1 = "" then _1 else _2 endif<when> _1 String LHS tokens = [_1, and, _2]
>> Text rule _1 and _2 |-->if _1 = "" then _1 else _2 endif<when> _1 String RHS = if _1 = "" then _1 else _2 endif<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 and _2 |-->_1 & _2 LHS variables = [_1, _2]
>> Text rule _1 and _2 |-->_1 & _2 LHS tokens = [_1, and, _2]
>> Text rule _1 and _2 |-->_1 & _2 RHS = _1 & _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 or _2 |-->if _1 /= 0 then _1 else _2 endif<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 or _2 |-->if _1 /= 0 then _1 else _2 endif<when> _1 real LHS tokens = [_1, or, _2]
>> Text rule _1 or _2 |-->if _1 /= 0 then _1 else _2 endif<when> _1 real RHS = if _1 /= 0 then _1 else _2 endif<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 or _2 |-->if _1 /= "" then _1 else _2 endif<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 or _2 |-->if _1 /= "" then _1 else _2 endif<when> _1 String LHS tokens = [_1, or, _2]
>> Text rule _1 or _2 |-->if _1 /= "" then _1 else _2 endif<when> _1 String RHS = if _1 /= "" then _1 else _2 endif<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 or _2 |-->_1 or _2 LHS variables = [_1, _2]
>> Text rule _1 or _2 |-->_1 or _2 LHS tokens = [_1, or, _2]
>> Text rule _1 or _2 |-->_1 or _2 RHS = _1 or _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->_1 & (_1`last < _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->_1 & (_1`last < _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->_1 & (_1`last < _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last < _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 < _2 |-->MatrixLib.matrixLess(_1,_2)<when> _1 Sequence, _2 Sequence LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->MatrixLib.matrixLess(_1,_2)<when> _1 Sequence, _2 Sequence LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->MatrixLib.matrixLess(_1,_2)<when> _1 Sequence, _2 Sequence RHS = MatrixLib.matrixLess(_1,_2)<when> _1 Sequence, _2 Sequence
+++ Condition lexicals:: [_1, Sequence, ,, _2, Sequence]
>***> Rule with condition: [_1 Sequence, _2 Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->MatrixLib.elementwiseLess(_1,_2)<when> _1 Sequence, _2 real LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->MatrixLib.elementwiseLess(_1,_2)<when> _1 Sequence, _2 real LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->MatrixLib.elementwiseLess(_1,_2)<when> _1 Sequence, _2 real RHS = MatrixLib.elementwiseLess(_1,_2)<when> _1 Sequence, _2 real
+++ Condition lexicals:: [_1, Sequence, ,, _2, real]
>***> Rule with condition: [_1 Sequence, _2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->_1 < _2<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _1 String LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _1 String RHS = _1 < _2<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->_1 < _2<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _1 real LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _1 real RHS = _1 < _2<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->_1 < _2<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _2 String LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _2 String RHS = _1 < _2<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->_1 < _2<when> _2 real LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _2 real LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->_1 < _2<when> _2 real RHS = _1 < _2<when> _2 real
+++ Condition lexicals:: [_2, real]
>***> Rule with condition: [_2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->(_1->compareTo(_2)) < 0 LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->(_1->compareTo(_2)) < 0 LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->(_1->compareTo(_2)) < 0 RHS = (_1->compareTo(_2)) < 0
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->_1 & (_1`last > _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->_1 & (_1`last > _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->_1 & (_1`last > _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last > _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 > _2 |-->_1 > _2<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _1 String LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _1 String RHS = _1 > _2<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->_1 > _2<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _1 real LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _1 real RHS = _1 > _2<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->_1 > _2<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _2 String LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _2 String RHS = _1 > _2<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->_1 > _2<when> _2 real LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _2 real LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->_1 > _2<when> _2 real RHS = _1 > _2<when> _2 real
+++ Condition lexicals:: [_2, real]
>***> Rule with condition: [_2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->(_1->compareTo(_2)) > 0 LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->(_1->compareTo(_2)) > 0 LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->(_1->compareTo(_2)) > 0 RHS = (_1->compareTo(_2)) > 0
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->_1 & (_1`last >= _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->_1 & (_1`last >= _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->_1 & (_1`last >= _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last >= _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 String LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 String RHS = _1 >= _2<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 real LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _1 real RHS = _1 >= _2<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 String LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 String RHS = _1 >= _2<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 real LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 real LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->_1 >= _2<when> _2 real RHS = _1 >= _2<when> _2 real
+++ Condition lexicals:: [_2, real]
>***> Rule with condition: [_2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->(_1->compareTo(_2)) >= 0 LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->(_1->compareTo(_2)) >= 0 LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->(_1->compareTo(_2)) >= 0 RHS = (_1->compareTo(_2)) >= 0
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->_1 & (_1`last <= _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->_1 & (_1`last <= _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->_1 & (_1`last <= _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last <= _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 String LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 String RHS = _1 <= _2<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 real LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 real LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _1 real RHS = _1 <= _2<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 String LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 String RHS = _1 <= _2<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 real LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 real LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->_1 <= _2<when> _2 real RHS = _1 <= _2<when> _2 real
+++ Condition lexicals:: [_2, real]
>***> Rule with condition: [_2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->(_1->compareTo(_2)) <= 0 LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->(_1->compareTo(_2)) <= 0 LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->(_1->compareTo(_2)) <= 0 RHS = (_1->compareTo(_2)) <= 0
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 == _2 |-->_1 & (_1`last == _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 == _2 |-->_1 & (_1`last == _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, ==, _2]
>> Text rule _1 == _2 |-->_1 & (_1`last == _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last == _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 == _2 |-->_1 = _2 LHS variables = [_1, _2]
>> Text rule _1 == _2 |-->_1 = _2 LHS tokens = [_1, ==, _2]
>> Text rule _1 == _2 |-->_1 = _2 RHS = _1 = _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <> _2 |-->_1 & (_1`last <> _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 <> _2 |-->_1 & (_1`last <> _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, <>, _2]
>> Text rule _1 <> _2 |-->_1 & (_1`last <> _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last <> _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 <> _2 |-->_1 /= _2 LHS variables = [_1, _2]
>> Text rule _1 <> _2 |-->_1 /= _2 LHS tokens = [_1, <>, _2]
>> Text rule _1 <> _2 |-->_1 /= _2 RHS = _1 /= _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 != _2 |-->_1 & (_1`last != _2)<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 != _2 |-->_1 & (_1`last != _2)<when> _1 comparison, _1 multiple LHS tokens = [_1, !=, _2]
>> Text rule _1 != _2 |-->_1 & (_1`last != _2)<when> _1 comparison, _1 multiple RHS = _1 & (_1`last != _2)<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 != _2 |-->_1 /= _2 LHS variables = [_1, _2]
>> Text rule _1 != _2 |-->_1 /= _2 LHS tokens = [_1, !=, _2]
>> Text rule _1 != _2 |-->_1 /= _2 RHS = _1 /= _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 in _2 |-->_1 & (_2->includes(_1`last))<when> _1 comparison, _1 multiple LHS variables = [_1, _2]
>> Text rule _1 in _2 |-->_1 & (_2->includes(_1`last))<when> _1 comparison, _1 multiple LHS tokens = [_1, in, _2]
>> Text rule _1 in _2 |-->_1 & (_2->includes(_1`last))<when> _1 comparison, _1 multiple RHS = _1 & (_2->includes(_1`last))<when> _1 comparison, _1 multiple
+++ Condition lexicals:: [_1, comparison, ,, _1, multiple]
>>> found metafeature _1`last for _1`
>***> Rule with condition: [_1 comparison, _1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`last]
>> Text rule _1 not in _2 |-->(_2)->characters()->excludes(_1)<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 not in _2 |-->(_2)->characters()->excludes(_1)<when> _2 String LHS tokens = [_1, not, in, _2]
>> Text rule _1 not in _2 |-->(_2)->characters()->excludes(_1)<when> _2 String RHS = (_2)->characters()->excludes(_1)<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 in _2 |-->(_2)->characters()->includes(_1)<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 in _2 |-->(_2)->characters()->includes(_1)<when> _2 String LHS tokens = [_1, in, _2]
>> Text rule _1 in _2 |-->(_2)->characters()->includes(_1)<when> _2 String RHS = (_2)->characters()->includes(_1)<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 not in _2 |-->(_2)->excludes(_1) LHS variables = [_1, _2]
>> Text rule _1 not in _2 |-->(_2)->excludes(_1) LHS tokens = [_1, not, in, _2]
>> Text rule _1 not in _2 |-->(_2)->excludes(_1) RHS = (_2)->excludes(_1)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 in _2 |-->(_2)->includes(_1) LHS variables = [_1, _2]
>> Text rule _1 in _2 |-->(_2)->includes(_1) LHS tokens = [_1, in, _2]
>> Text rule _1 in _2 |-->(_2)->includes(_1) RHS = (_2)->includes(_1)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 is not _2 |-->not(_1 <>= _2) LHS variables = [_1, _2]
>> Text rule _1 is not _2 |-->not(_1 <>= _2) LHS tokens = [_1, is, not, _2]
>> Text rule _1 is not _2 |-->not(_1 <>= _2) RHS = not(_1 <>= _2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 is _2 |-->_1 <>= _2 LHS variables = [_1, _2]
>> Text rule _1 is _2 |-->_1 <>= _2 LHS tokens = [_1, is, _2]
>> Text rule _1 is _2 |-->_1 <>= _2 RHS = _1 <>= _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule abs _1 |-->_1->abs() LHS variables = [_1]
>> Text rule abs _1 |-->_1->abs() LHS tokens = [abs, _1]
>> Text rule abs _1 |-->_1->abs() RHS = _1->abs()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule all _1 |-->_1->forAll( _x | _x = true ) LHS variables = [_1]
>> Text rule all _1 |-->_1->forAll( _x | _x = true ) LHS tokens = [all, _1]
>> Text rule all _1 |-->_1->forAll( _x | _x = true ) RHS = _1->forAll( _x | _x = true )
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule any _1 |-->_1->exists( _x | _x = true ) LHS variables = [_1]
>> Text rule any _1 |-->_1->exists( _x | _x = true ) LHS tokens = [any, _1]
>> Text rule any _1 |-->_1->exists( _x | _x = true ) RHS = _1->exists( _x | _x = true )
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ascii _1 |-->(_1 + "") LHS variables = [_1]
>> Text rule ascii _1 |-->(_1 + "") LHS tokens = [ascii, _1]
>> Text rule ascii _1 |-->(_1 + "") RHS = (_1 + "")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule await asyncio _1 |-->_1`asyncioTrailer<when> _1 trailer LHS variables = [_1]
>> Text rule await asyncio _1 |-->_1`asyncioTrailer<when> _1 trailer LHS tokens = [await, asyncio, _1]
>> Text rule await asyncio _1 |-->_1`asyncioTrailer<when> _1 trailer RHS = _1`asyncioTrailer<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`asyncioTrailer for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asyncioTrailer]
>> Text rule await _1 |-->_1.join() LHS variables = [_1]
>> Text rule await _1 |-->_1.join() LHS tokens = [await, _1]
>> Text rule await _1 |-->_1.join() RHS = _1.join()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule bool _1 |-->_1->toBoolean() LHS variables = [_1]
>> Text rule bool _1 |-->_1->toBoolean() LHS tokens = [bool, _1]
>> Text rule bool _1 |-->_1->toBoolean() RHS = _1->toBoolean()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule dict _1 |-->_1`dictarguments LHS variables = [_1]
>> Text rule dict _1 |-->_1`dictarguments LHS tokens = [dict, _1]
>> Text rule dict _1 |-->_1`dictarguments RHS = _1`dictarguments
>>> found metafeature _1`dictarguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule set _1 |-->Set{}->union(_1) LHS variables = [_1]
>> Text rule set _1 |-->Set{}->union(_1) LHS tokens = [set, _1]
>> Text rule set _1 |-->Set{}->union(_1) RHS = Set{}->union(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule set _1 _2 |-->Set{}->union(_1)_2 LHS variables = [_1, _2]
>> Text rule set _1 _2 |-->Set{}->union(_1)_2 LHS tokens = [set, _1, _2]
>> Text rule set _1 _2 |-->Set{}->union(_1)_2 RHS = Set{}->union(_1)_2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule divmod _1 |-->Sequence{(_1`firstArg div _1`secondArg), (_1`firstArg mod _1`secondArg)} LHS variables = [_1]
>> Text rule divmod _1 |-->Sequence{(_1`firstArg div _1`secondArg), (_1`firstArg mod _1`secondArg)} LHS tokens = [divmod, _1]
>> Text rule divmod _1 |-->Sequence{(_1`firstArg div _1`secondArg), (_1`firstArg mod _1`secondArg)} RHS = Sequence{(_1`firstArg div _1`secondArg), (_1`firstArg mod _1`secondArg)}
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule filter _1 |-->(_1`secondArg)->select( _x | (_1`firstArg)->apply(_x) = true ) LHS variables = [_1]
>> Text rule filter _1 |-->(_1`secondArg)->select( _x | (_1`firstArg)->apply(_x) = true ) LHS tokens = [filter, _1]
>> Text rule filter _1 |-->(_1`secondArg)->select( _x | (_1`firstArg)->apply(_x) = true ) RHS = (_1`secondArg)->select( _x | (_1`firstArg)->apply(_x) = true )
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule format _1 |-->(_1`firstArg + "") LHS variables = [_1]
>> Text rule format _1 |-->(_1`firstArg + "") LHS tokens = [format, _1]
>> Text rule format _1 |-->(_1`firstArg + "") RHS = (_1`firstArg + "")
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule frozenset _1 |-->Set{} LHS variables = [_1]
>> Text rule frozenset _1 |-->Set{} LHS tokens = [frozenset, _1]
>> Text rule frozenset _1 |-->Set{} RHS = Set{}
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule map _1 |-->(_1`secondArg)->collect( _x | (_1`firstArg)->apply(_x) ) LHS variables = [_1]
>> Text rule map _1 |-->(_1`secondArg)->collect( _x | (_1`firstArg)->apply(_x) ) LHS tokens = [map, _1]
>> Text rule map _1 |-->(_1`secondArg)->collect( _x | (_1`firstArg)->apply(_x) ) RHS = (_1`secondArg)->collect( _x | (_1`firstArg)->apply(_x) )
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule hex _1 |-->MathLib.decimal2hex_1 LHS variables = [_1]
>> Text rule hex _1 |-->MathLib.decimal2hex_1 LHS tokens = [hex, _1]
>> Text rule hex _1 |-->MathLib.decimal2hex_1 RHS = MathLib.decimal2hex_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule oct _1 |-->MathLib.decimal2octal_1 LHS variables = [_1]
>> Text rule oct _1 |-->MathLib.decimal2octal_1 LHS tokens = [oct, _1]
>> Text rule oct _1 |-->MathLib.decimal2octal_1 RHS = MathLib.decimal2octal_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule id _1 |-->?_1 LHS variables = [_1]
>> Text rule id _1 |-->?_1 LHS tokens = [id, _1]
>> Text rule id _1 |-->?_1 RHS = ?_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule input _1 |-->(OclFile["System.in"]).readLine_1 LHS variables = [_1]
>> Text rule input _1 |-->(OclFile["System.in"]).readLine_1 LHS tokens = [input, _1]
>> Text rule input _1 |-->(OclFile["System.in"]).readLine_1 RHS = (OclFile["System.in"]).readLine_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule isinstance _1 |-->(_1`secondArg).isInstance(_1`firstArg) LHS variables = [_1]
>> Text rule isinstance _1 |-->(_1`secondArg).isInstance(_1`firstArg) LHS tokens = [isinstance, _1]
>> Text rule isinstance _1 |-->(_1`secondArg).isInstance(_1`firstArg) RHS = (_1`secondArg).isInstance(_1`firstArg)
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule issubclass _1 |-->(_1`firstArg).isAssignableFrom(_1`secondArg) LHS variables = [_1]
>> Text rule issubclass _1 |-->(_1`firstArg).isAssignableFrom(_1`secondArg) LHS tokens = [issubclass, _1]
>> Text rule issubclass _1 |-->(_1`firstArg).isAssignableFrom(_1`secondArg) RHS = (_1`firstArg).isAssignableFrom(_1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule iter _1 |-->OclIterator.newOclIterator_Sequence_1 LHS variables = [_1]
>> Text rule iter _1 |-->OclIterator.newOclIterator_Sequence_1 LHS tokens = [iter, _1]
>> Text rule iter _1 |-->OclIterator.newOclIterator_Sequence_1 RHS = OclIterator.newOclIterator_Sequence_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule len _1 |-->_1->size() LHS variables = [_1]
>> Text rule len _1 |-->_1->size() LHS tokens = [len, _1]
>> Text rule len _1 |-->_1->size() RHS = _1->size()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule list _1 |-->_1->characters()<when> _1`ocltype String LHS variables = [_1]
>> Text rule list _1 |-->_1->characters()<when> _1`ocltype String LHS tokens = [list, _1]
>> Text rule list _1 |-->_1->characters()<when> _1`ocltype String RHS = _1->characters()<when> _1`ocltype String
+++ Condition lexicals:: [_1, `, ocltype, String]
>***> Rule with condition: [_1`ocltype String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule list _1 |-->_1->keys()->asSequence()<when> _1`ocltype Map LHS variables = [_1]
>> Text rule list _1 |-->_1->keys()->asSequence()<when> _1`ocltype Map LHS tokens = [list, _1]
>> Text rule list _1 |-->_1->keys()->asSequence()<when> _1`ocltype Map RHS = _1->keys()->asSequence()<when> _1`ocltype Map
+++ Condition lexicals:: [_1, `, ocltype, Map]
>***> Rule with condition: [_1`ocltype Map]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule list _1 |-->_1 LHS variables = [_1]
>> Text rule list _1 |-->_1 LHS tokens = [list, _1]
>> Text rule list _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule deque _1 |-->_1 LHS variables = [_1]
>> Text rule deque _1 |-->_1 LHS tokens = [deque, _1]
>> Text rule deque _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule OrderedDict _1 |-->_1 LHS variables = [_1]
>> Text rule OrderedDict _1 |-->_1 LHS tokens = [OrderedDict, _1]
>> Text rule OrderedDict _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule max _1 |-->_1->max()<when> _1`argCount 1 LHS variables = [_1]
>> Text rule max _1 |-->_1->max()<when> _1`argCount 1 LHS tokens = [max, _1]
>> Text rule max _1 |-->_1->max()<when> _1`argCount 1 RHS = _1->max()<when> _1`argCount 1
+++ Condition lexicals:: [_1, `, argCount, 1]
>***> Rule with condition: [_1`argCount 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule max _1 |-->Set{_1`argList}->max() LHS variables = [_1]
>> Text rule max _1 |-->Set{_1`argList}->max() LHS tokens = [max, _1]
>> Text rule max _1 |-->Set{_1`argList}->max() RHS = Set{_1`argList}->max()
>>> found metafeature _1`argList for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argList]
>> Text rule min _1 |-->_1->min()<when> _1`argCount 1 LHS variables = [_1]
>> Text rule min _1 |-->_1->min()<when> _1`argCount 1 LHS tokens = [min, _1]
>> Text rule min _1 |-->_1->min()<when> _1`argCount 1 RHS = _1->min()<when> _1`argCount 1
+++ Condition lexicals:: [_1, `, argCount, 1]
>***> Rule with condition: [_1`argCount 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule min _1 |-->Set{_1`argList}->min() LHS variables = [_1]
>> Text rule min _1 |-->Set{_1`argList}->min() LHS tokens = [min, _1]
>> Text rule min _1 |-->Set{_1`argList}->min() RHS = Set{_1`argList}->min()
>>> found metafeature _1`argList for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argList]
>> Text rule next _1 |-->_1.next() LHS variables = [_1]
>> Text rule next _1 |-->_1.next() LHS tokens = [next, _1]
>> Text rule next _1 |-->_1.next() RHS = _1.next()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule round _1 |-->_1->round()<when> _1`numberOfArguments 1 LHS variables = [_1]
>> Text rule round _1 |-->_1->round()<when> _1`numberOfArguments 1 LHS tokens = [round, _1]
>> Text rule round _1 |-->_1->round()<when> _1`numberOfArguments 1 RHS = _1->round()<when> _1`numberOfArguments 1
+++ Condition lexicals:: [_1, `, numberOfArguments, 1]
>***> Rule with condition: [_1`numberOfArguments 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule round _1 |-->MathLib.roundN(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule round _1 |-->MathLib.roundN(_1`firstArg, _1`secondArg) LHS tokens = [round, _1]
>> Text rule round _1 |-->MathLib.roundN(_1`firstArg, _1`secondArg) RHS = MathLib.roundN(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule slice _1 |-->Integer.subrange(1,_1`firstArg)<when> _1`numberOfArguments 1 LHS variables = [_1]
>> Text rule slice _1 |-->Integer.subrange(1,_1`firstArg)<when> _1`numberOfArguments 1 LHS tokens = [slice, _1]
>> Text rule slice _1 |-->Integer.subrange(1,_1`firstArg)<when> _1`numberOfArguments 1 RHS = Integer.subrange(1,_1`firstArg)<when> _1`numberOfArguments 1
+++ Condition lexicals:: [_1, `, numberOfArguments, 1]
>>> found metafeature _1`firstArg for _1`
>***> Rule with condition: [_1`numberOfArguments 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule slice _1 |-->Integer.subrange(_1`firstArg+1,_1`secondArg) LHS variables = [_1]
>> Text rule slice _1 |-->Integer.subrange(_1`firstArg+1,_1`secondArg) LHS tokens = [slice, _1]
>> Text rule slice _1 |-->Integer.subrange(_1`firstArg+1,_1`secondArg) RHS = Integer.subrange(_1`firstArg+1,_1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule sum _1 |-->_1->sum() LHS variables = [_1]
>> Text rule sum _1 |-->_1->sum() LHS tokens = [sum, _1]
>> Text rule sum _1 |-->_1->sum() RHS = _1->sum()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule type _1 |-->_1->oclType()<when> _1`numberOfArguments 1 LHS variables = [_1]
>> Text rule type _1 |-->_1->oclType()<when> _1`numberOfArguments 1 LHS tokens = [type, _1]
>> Text rule type _1 |-->_1->oclType()<when> _1`numberOfArguments 1 RHS = _1->oclType()<when> _1`numberOfArguments 1
+++ Condition lexicals:: [_1, `, numberOfArguments, 1]
>***> Rule with condition: [_1`numberOfArguments 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule type _1 |-->OclType.newOclType(_1`firstArg) LHS variables = [_1]
>> Text rule type _1 |-->OclType.newOclType(_1`firstArg) LHS tokens = [type, _1]
>> Text rule type _1 |-->OclType.newOclType(_1`firstArg) RHS = OclType.newOclType(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule print _1 |-->_1`printTrailer->display() LHS variables = [_1]
>> Text rule print _1 |-->_1`printTrailer->display() LHS tokens = [print, _1]
>> Text rule print _1 |-->_1`printTrailer->display() RHS = _1`printTrailer->display()
>>> found metafeature _1`printTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule int _1 |-->("" + (_1))->toInteger() LHS variables = [_1]
>> Text rule int _1 |-->("" + (_1))->toInteger() LHS tokens = [int, _1]
>> Text rule int _1 |-->("" + (_1))->toInteger() RHS = ("" + (_1))->toInteger()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule float _1 |-->("" + (_1))->toReal() LHS variables = [_1]
>> Text rule float _1 |-->("" + (_1))->toReal() LHS tokens = [float, _1]
>> Text rule float _1 |-->("" + (_1))->toReal() RHS = ("" + (_1))->toReal()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule str _1 |-->("" + (_1)) LHS variables = [_1]
>> Text rule str _1 |-->("" + (_1)) LHS tokens = [str, _1]
>> Text rule str _1 |-->("" + (_1)) RHS = ("" + (_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule chr _1 |-->_1->byte2char() LHS variables = [_1]
>> Text rule chr _1 |-->_1->byte2char() LHS tokens = [chr, _1]
>> Text rule chr _1 |-->_1->byte2char() RHS = _1->byte2char()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule unichr _1 |-->_1->byte2char() LHS variables = [_1]
>> Text rule unichr _1 |-->_1->byte2char() LHS tokens = [unichr, _1]
>> Text rule unichr _1 |-->_1->byte2char() RHS = _1->byte2char()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ord _1 |-->_1->char2byte() LHS variables = [_1]
>> Text rule ord _1 |-->_1->char2byte() LHS tokens = [ord, _1]
>> Text rule ord _1 |-->_1->char2byte() RHS = _1->char2byte()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule pow _1 |-->(_1`firstArg)->pow(_1`secondArg) LHS variables = [_1]
>> Text rule pow _1 |-->(_1`firstArg)->pow(_1`secondArg) LHS tokens = [pow, _1]
>> Text rule pow _1 |-->(_1`firstArg)->pow(_1`secondArg) RHS = (_1`firstArg)->pow(_1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule repr _1 |-->("" + (_1)) LHS variables = [_1]
>> Text rule repr _1 |-->("" + (_1)) LHS tokens = [repr, _1]
>> Text rule repr _1 |-->("" + (_1)) RHS = ("" + (_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule reversed _1 |-->_1->reverse() LHS variables = [_1]
>> Text rule reversed _1 |-->_1->reverse() LHS tokens = [reversed, _1]
>> Text rule reversed _1 |-->_1->reverse() RHS = _1->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule sorted _1 |-->_1`sortedTrailer LHS variables = [_1]
>> Text rule sorted _1 |-->_1`sortedTrailer LHS tokens = [sorted, _1]
>> Text rule sorted _1 |-->_1`sortedTrailer RHS = _1`sortedTrailer
>>> found metafeature _1`sortedTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sortedTrailer]
>> Text rule tuple _1 |-->_1 LHS variables = [_1]
>> Text rule tuple _1 |-->_1 LHS tokens = [tuple, _1]
>> Text rule tuple _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule range _1 |-->_1`rangeTrailer LHS variables = [_1]
>> Text rule range _1 |-->_1`rangeTrailer LHS tokens = [range, _1]
>> Text rule range _1 |-->_1`rangeTrailer RHS = _1`rangeTrailer
>>> found metafeature _1`rangeTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`rangeTrailer]
>> Text rule enumerate _1 |-->Integer.subrange(1, _1->size())->collect( _indx | Sequence{_indx-1, _1->at(_indx)} ) LHS variables = [_1]
>> Text rule enumerate _1 |-->Integer.subrange(1, _1->size())->collect( _indx | Sequence{_indx-1, _1->at(_indx)} ) LHS tokens = [enumerate, _1]
>> Text rule enumerate _1 |-->Integer.subrange(1, _1->size())->collect( _indx | Sequence{_indx-1, _1->at(_indx)} ) RHS = Integer.subrange(1, _1->size())->collect( _indx | Sequence{_indx-1, _1->at(_indx)} )
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule zip _1 |-->Integer.subrange(1, _1`firstArg->size())->collect( _indx | Sequence{_1`firstArg->at(_indx), _1`secondArg->at(_indx)} ) LHS variables = [_1]
>> Text rule zip _1 |-->Integer.subrange(1, _1`firstArg->size())->collect( _indx | Sequence{_1`firstArg->at(_indx), _1`secondArg->at(_indx)} ) LHS tokens = [zip, _1]
>> Text rule zip _1 |-->Integer.subrange(1, _1`firstArg->size())->collect( _indx | Sequence{_1`firstArg->at(_indx), _1`secondArg->at(_indx)} ) RHS = Integer.subrange(1, _1`firstArg->size())->collect( _indx | Sequence{_1`firstArg->at(_indx), _1`secondArg->at(_indx)} )
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule open _1 |-->OclFile.newOclFile_Write(OclFile.newOclFile(_1`firstArg))<when> _1`lastArg matches .*[wWaA].* LHS variables = [_1]
>> Text rule open _1 |-->OclFile.newOclFile_Write(OclFile.newOclFile(_1`firstArg))<when> _1`lastArg matches .*[wWaA].* LHS tokens = [open, _1]
>> Text rule open _1 |-->OclFile.newOclFile_Write(OclFile.newOclFile(_1`firstArg))<when> _1`lastArg matches .*[wWaA].* RHS = OclFile.newOclFile_Write(OclFile.newOclFile(_1`firstArg))<when> _1`lastArg matches .*[wWaA].*
+++ Condition lexicals:: [_1, `, lastArg, matches, ., *, [, wWaA, ], ., *]
>>> found metafeature _1`firstArg for _1`
>***> Rule with condition: [_1`lastArg matches .*[wWaA].*]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule open _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1`firstArg)) LHS variables = [_1]
>> Text rule open _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1`firstArg)) LHS tokens = [open, _1]
>> Text rule open _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1`firstArg)) RHS = OclFile.newOclFile_Read(OclFile.newOclFile(_1`firstArg))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule setattr _1 |-->OclType.setAttributeValue_1 LHS variables = [_1]
>> Text rule setattr _1 |-->OclType.setAttributeValue_1 LHS tokens = [setattr, _1]
>> Text rule setattr _1 |-->OclType.setAttributeValue_1 RHS = OclType.setAttributeValue_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule getattr _1 |-->OclType.getAttributeValue_1 LHS variables = [_1]
>> Text rule getattr _1 |-->OclType.getAttributeValue_1 LHS tokens = [getattr, _1]
>> Text rule getattr _1 |-->OclType.getAttributeValue_1 RHS = OclType.getAttributeValue_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule hasattr _1 |-->OclType.hasAttribute_1 LHS variables = [_1]
>> Text rule hasattr _1 |-->OclType.hasAttribute_1 LHS tokens = [hasattr, _1]
>> Text rule hasattr _1 |-->OclType.hasAttribute_1 RHS = OclType.hasAttribute_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule delattr _1 |-->OclType.removeAttribute_1 LHS variables = [_1]
>> Text rule delattr _1 |-->OclType.removeAttribute_1 LHS tokens = [delattr, _1]
>> Text rule delattr _1 |-->OclType.removeAttribute_1 RHS = OclType.removeAttribute_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule eval _1 |-->_0`pythonEval LHS variables = [_1]
>> Text rule eval _1 |-->_0`pythonEval LHS tokens = [eval, _1]
>> Text rule eval _1 |-->_0`pythonEval RHS = _0`pythonEval
>> These will be treated as global variables: [_0]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule collections _1 |-->_1 LHS variables = [_1]
>> Text rule collections _1 |-->_1 LHS tokens = [collections, _1]
>> Text rule collections _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule math _1 |-->_1`mathTrailer LHS variables = [_1]
>> Text rule math _1 |-->_1`mathTrailer LHS tokens = [math, _1]
>> Text rule math _1 |-->_1`mathTrailer RHS = _1`mathTrailer
>>> found metafeature _1`mathTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`mathTrailer]
>> Text rule re _1 |-->_1`reTrailer LHS variables = [_1]
>> Text rule re _1 |-->_1`reTrailer LHS tokens = [re, _1]
>> Text rule re _1 |-->_1`reTrailer RHS = _1`reTrailer
>>> found metafeature _1`reTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reTrailer]
>> Text rule random _1 |-->_1`randomTrailer LHS variables = [_1]
>> Text rule random _1 |-->_1`randomTrailer LHS tokens = [random, _1]
>> Text rule random _1 |-->_1`randomTrailer RHS = _1`randomTrailer
>>> found metafeature _1`randomTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`randomTrailer]
>> Text rule pickle _1 |-->_1`pickleTrailer LHS variables = [_1]
>> Text rule pickle _1 |-->_1`pickleTrailer LHS tokens = [pickle, _1]
>> Text rule pickle _1 |-->_1`pickleTrailer RHS = _1`pickleTrailer
>>> found metafeature _1`pickleTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`pickleTrailer]
>> Text rule datetime _1 |-->_1`datetimeTrailer LHS variables = [_1]
>> Text rule datetime _1 |-->_1`datetimeTrailer LHS tokens = [datetime, _1]
>> Text rule datetime _1 |-->_1`datetimeTrailer RHS = _1`datetimeTrailer
>>> found metafeature _1`datetimeTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`datetimeTrailer]
>> Text rule asyncio _1 |-->_1`asyncioTrailer LHS variables = [_1]
>> Text rule asyncio _1 |-->_1`asyncioTrailer LHS tokens = [asyncio, _1]
>> Text rule asyncio _1 |-->_1`asyncioTrailer RHS = _1`asyncioTrailer
>>> found metafeature _1`asyncioTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asyncioTrailer]
>> Text rule sqlite3 _1 |-->_1`sqliteTrailer LHS variables = [_1]
>> Text rule sqlite3 _1 |-->_1`sqliteTrailer LHS tokens = [sqlite3, _1]
>> Text rule sqlite3 _1 |-->_1`sqliteTrailer RHS = _1`sqliteTrailer
>>> found metafeature _1`sqliteTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sqliteTrailer]
>> Text rule np _1 |-->_1`numpyTrailer LHS variables = [_1]
>> Text rule np _1 |-->_1`numpyTrailer LHS tokens = [np, _1]
>> Text rule np _1 |-->_1`numpyTrailer RHS = _1`numpyTrailer
>>> found metafeature _1`numpyTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numpyTrailer]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS tokens = [np, _1, _2]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random RHS = _2`npRandomTrailer<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomTrailer for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomTrailer]
>> Text rule numpy _1 |-->_1`numpyTrailer LHS variables = [_1]
>> Text rule numpy _1 |-->_1`numpyTrailer LHS tokens = [numpy, _1]
>> Text rule numpy _1 |-->_1`numpyTrailer RHS = _1`numpyTrailer
>>> found metafeature _1`numpyTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numpyTrailer]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS tokens = [numpy, _1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random RHS = _2`npRandomTrailer<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomTrailer for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomTrailer]
>> Text rule pd _1 |-->_1`pandasTrailer LHS variables = [_1]
>> Text rule pd _1 |-->_1`pandasTrailer LHS tokens = [pd, _1]
>> Text rule pd _1 |-->_1`pandasTrailer RHS = _1`pandasTrailer
>>> found metafeature _1`pandasTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`pandasTrailer]
>> Text rule sys _1 |-->_1`sysTrailer LHS variables = [_1]
>> Text rule sys _1 |-->_1`sysTrailer LHS tokens = [sys, _1]
>> Text rule sys _1 |-->_1`sysTrailer RHS = _1`sysTrailer
>>> found metafeature _1`sysTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sysTrailer]
>> Text rule sys _1 _2 |-->(_1`sysTrailer)_2 LHS variables = [_1, _2]
>> Text rule sys _1 _2 |-->(_1`sysTrailer)_2 LHS tokens = [sys, _1, _2]
>> Text rule sys _1 _2 |-->(_1`sysTrailer)_2 RHS = (_1`sysTrailer)_2
>>> found metafeature _1`sysTrailer for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`sysTrailer]
>> Text rule _1 ** _2 |-->(_1)->pow(_2) LHS variables = [_1, _2]
>> Text rule _1 ** _2 |-->(_1)->pow(_2) LHS tokens = [_1, **, _2]
>> Text rule _1 ** _2 |-->(_1)->pow(_2) RHS = (_1)->pow(_2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule + _1 |-->_1 LHS variables = [_1]
>> Text rule + _1 |-->_1 LHS tokens = [+, _1]
>> Text rule + _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->-_1 LHS variables = [_1]
>> Text rule - _1 |-->-_1 LHS tokens = [-, _1]
>> Text rule - _1 |-->-_1 RHS = -_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ~ _1 |-->MathLib.bitwiseNot(_1) LHS variables = [_1]
>> Text rule ~ _1 |-->MathLib.bitwiseNot(_1) LHS tokens = [~, _1]
>> Text rule ~ _1 |-->MathLib.bitwiseNot(_1) RHS = MathLib.bitwiseNot(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->StringLib.nCopies(_1, _2)<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->StringLib.nCopies(_1, _2)<when> _1 String LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->StringLib.nCopies(_1, _2)<when> _1 String RHS = StringLib.nCopies(_1, _2)<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->MatrixLib.dotProduct(_1,_2)<when> _1`ocltype Sequence, _2`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->MatrixLib.dotProduct(_1,_2)<when> _1`ocltype Sequence, _2`ocltype Sequence LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->MatrixLib.dotProduct(_1,_2)<when> _1`ocltype Sequence, _2`ocltype Sequence RHS = MatrixLib.dotProduct(_1,_2)<when> _1`ocltype Sequence, _2`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence, ,, _2, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence, _2`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_1, _2)<when> _1`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_1, _2)<when> _1`ocltype Sequence LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_1, _2)<when> _1`ocltype Sequence RHS = MatrixLib.elementwiseMult(_1, _2)<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_2, _1)<when> _2`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_2, _1)<when> _2`ocltype Sequence LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->MatrixLib.elementwiseMult(_2, _1)<when> _2`ocltype Sequence RHS = MatrixLib.elementwiseMult(_2, _1)<when> _2`ocltype Sequence
+++ Condition lexicals:: [_2, `, ocltype, Sequence]
>***> Rule with condition: [_2`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->_1 * _2 LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->_1 * _2 LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->_1 * _2 RHS = _1 * _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 / _2 |-->_1 / _2 LHS variables = [_1, _2]
>> Text rule _1 / _2 |-->_1 / _2 LHS tokens = [_1, /, _2]
>> Text rule _1 / _2 |-->_1 / _2 RHS = _1 / _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 % _2 |-->StringLib.format(_1,_2)<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 % _2 |-->StringLib.format(_1,_2)<when> _1 String LHS tokens = [_1, %, _2]
>> Text rule _1 % _2 |-->StringLib.format(_1,_2)<when> _1 String RHS = StringLib.format(_1,_2)<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 % _2 |-->_1 mod _2 LHS variables = [_1, _2]
>> Text rule _1 % _2 |-->_1 mod _2 LHS tokens = [_1, %, _2]
>> Text rule _1 % _2 |-->_1 mod _2 RHS = _1 mod _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 // _2 |-->_1 div _2 LHS variables = [_1, _2]
>> Text rule _1 // _2 |-->_1 div _2 LHS tokens = [_1, //, _2]
>> Text rule _1 // _2 |-->_1 div _2 RHS = _1 div _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 @ _2 |-->MatrixLib.matrixMultiplication(_1,_2) LHS variables = [_1, _2]
>> Text rule _1 @ _2 |-->MatrixLib.matrixMultiplication(_1,_2) LHS tokens = [_1, @, _2]
>> Text rule _1 @ _2 |-->MatrixLib.matrixMultiplication(_1,_2) RHS = MatrixLib.matrixMultiplication(_1,_2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype int LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype int LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype int RHS = MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype int
+++ Condition lexicals:: [_1, `, ocltype, Sequence, ,, _2, `, ocltype, int]
>***> Rule with condition: [_1`ocltype Sequence, _2`ocltype int]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype double LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype double LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype double RHS = MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype double
+++ Condition lexicals:: [_1, `, ocltype, Sequence, ,, _2, `, ocltype, double]
>***> Rule with condition: [_1`ocltype Sequence, _2`ocltype double]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->_1->union(_2)<when> _1`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->_1->union(_2)<when> _1`ocltype Sequence LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->_1->union(_2)<when> _1`ocltype Sequence RHS = _1->union(_2)<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->_1->union(_2)<when> _2`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->_1->union(_2)<when> _2`ocltype Sequence LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->_1->union(_2)<when> _2`ocltype Sequence RHS = _1->union(_2)<when> _2`ocltype Sequence
+++ Condition lexicals:: [_2, `, ocltype, Sequence]
>***> Rule with condition: [_2`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->_1 + _2 LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->_1 + _2 LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->_1 + _2 RHS = _1 + _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 - _2 |-->_1 - _2 LHS variables = [_1, _2]
>> Text rule _1 - _2 |-->_1 - _2 LHS tokens = [_1, -, _2]
>> Text rule _1 - _2 |-->_1 - _2 RHS = _1 - _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 << _2 |-->_1 * (2->pow(_2)) LHS variables = [_1, _2]
>> Text rule _1 << _2 |-->_1 * (2->pow(_2)) LHS tokens = [_1, <<, _2]
>> Text rule _1 << _2 |-->_1 * (2->pow(_2)) RHS = _1 * (2->pow(_2))
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >> _2 |-->_1 /(2->pow(_2)) LHS variables = [_1, _2]
>> Text rule _1 >> _2 |-->_1 /(2->pow(_2)) LHS tokens = [_1, >>, _2]
>> Text rule _1 >> _2 |-->_1 /(2->pow(_2)) RHS = _1 /(2->pow(_2))
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 & _2 |-->MathLib.bitwiseAnd(_1, _2) LHS variables = [_1, _2]
>> Text rule _1 & _2 |-->MathLib.bitwiseAnd(_1, _2) LHS tokens = [_1, &, _2]
>> Text rule _1 & _2 |-->MathLib.bitwiseAnd(_1, _2) RHS = MathLib.bitwiseAnd(_1, _2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 ^ _2 |-->MathLib.bitwiseXor(_1, _2) LHS variables = [_1, _2]
>> Text rule _1 ^ _2 |-->MathLib.bitwiseXor(_1, _2) LHS tokens = [_1, ^, _2]
>> Text rule _1 ^ _2 |-->MathLib.bitwiseXor(_1, _2) RHS = MathLib.bitwiseXor(_1, _2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 | _2 |-->_1->union(_2)<when> _1 Map LHS variables = [_1, _2]
>> Text rule _1 | _2 |-->_1->union(_2)<when> _1 Map LHS tokens = [_1, |, _2]
>> Text rule _1 | _2 |-->_1->union(_2)<when> _1 Map RHS = _1->union(_2)<when> _1 Map
+++ Condition lexicals:: [_1, Map]
>***> Rule with condition: [_1 Map]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 | _2 |-->MathLib.bitwiseOr(_1, _2) LHS variables = [_1, _2]
>> Text rule _1 | _2 |-->MathLib.bitwiseOr(_1, _2) LHS tokens = [_1, |, _2]
>> Text rule _1 | _2 |-->MathLib.bitwiseOr(_1, _2) RHS = MathLib.bitwiseOr(_1, _2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 _3 |-->_1_2<when> _2`isBasicTypeTrailer true, _3 matches .value LHS variables = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_1_2<when> _2`isBasicTypeTrailer true, _3 matches .value LHS tokens = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_1_2<when> _2`isBasicTypeTrailer true, _3 matches .value RHS = _1_2<when> _2`isBasicTypeTrailer true, _3 matches .value
+++ Condition lexicals:: [_2, `, isBasicTypeTrailer, true, ,, _3, matches, .value]
>***> Rule with condition: [_2`isBasicTypeTrailer true, _3 matches .value]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MatrixLib.shape(_1)<when> _2 matches .shape LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)<when> _2 matches .shape LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)<when> _2 matches .shape RHS = MatrixLib.shape(_1)<when> _2 matches .shape
+++ Condition lexicals:: [_2, matches, .shape]
>***> Rule with condition: [_2 matches .shape]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim RHS = MatrixLib.shape(_1)->size()<when> _2 matches .ndim
+++ Condition lexicals:: [_2, matches, .ndim]
>***> Rule with condition: [_2 matches .ndim]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size RHS = MatrixLib.shape(_1)->prd()<when> _2 matches .size
+++ Condition lexicals:: [_2, matches, .size]
>***> Rule with condition: [_2 matches .size]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype RHS = MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype
+++ Condition lexicals:: [_2, matches, .dtype]
>***> Rule with condition: [_2 matches .dtype]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->_1<when> _1 atom, _2 matches .head\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1<when> _1 atom, _2 matches .head\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1<when> _1 atom, _2 matches .head\(\) RHS = _1<when> _1 atom, _2 matches .head\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .head, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .head\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer RHS = OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer
+++ Condition lexicals:: [_1, generator, ,, _2, trailer]
>***> Rule with condition: [_1 generator, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer RHS = (_1.new_1()).initialise_2<when> _1 Class, _2 trailer
+++ Condition lexicals:: [_1, Class, ,, _2, trailer]
>***> Rule with condition: [_1 Class, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) RHS = MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .mean, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .mean\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) RHS = MathLib.median(_1)<when> _1 atom, _2 matches .median\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .median, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .median\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 _3 |-->MathLib.median(_1_2)<when> _1 atom, _3 matches .median\(\) LHS variables = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->MathLib.median(_1_2)<when> _1 atom, _3 matches .median\(\) LHS tokens = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->MathLib.median(_1_2)<when> _1 atom, _3 matches .median\(\) RHS = MathLib.median(_1_2)<when> _1 atom, _3 matches .median\(\)
+++ Condition lexicals:: [_1, atom, ,, _3, matches, .median, \, (, \, )]
>***> Rule with condition: [_1 atom, _3 matches .median\(\)]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) RHS = StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .capitalize, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .capitalize\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join RHS = StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, join]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second join]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) RHS = StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .title, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .title\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) RHS = StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .swapcase, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .swapcase\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) RHS = StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .lstrip, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .lstrip\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) RHS = StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .rstrip, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .rstrip\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) LHS variables = [_1, _2]
>> Text rule _1 _2 |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) RHS = (_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\)
+++ Condition lexicals:: [_1, atom, ,, _2, matches, .istitle, \, (, \, )]
>***> Rule with condition: [_1 atom, _2 matches .istitle\(\)]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust RHS = StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, rjust]
>>> found metafeature _2`justificationArguments for _2`
>***> Rule with condition: [_1 atom, _2`second rjust]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`justificationArguments]
>> Text rule _1 _2 |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust RHS = StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, ljust]
>>> found metafeature _2`justificationArguments for _2`
>***> Rule with condition: [_1 atom, _2`second ljust]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`justificationArguments]
>> Text rule _1 _2 |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format LHS variables = [_1, _2]
>> Text rule _1 _2 |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format RHS = StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, format]
>>> found metafeature _2`formatArguments for _2`
>***> Rule with condition: [_1 atom, _2`second format]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`formatArguments]
>> Text rule _1 _* |-->_1->apply_*<when> _1 Function LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1->apply_*<when> _1 Function LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1->apply_*<when> _1 Function RHS = _1->apply_*<when> _1 Function
+++ Condition lexicals:: [_1, Function]
>***> Rule with condition: [_1 Function]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->_1_2`mapQueryForm<when> _1 Map LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1_2`mapQueryForm<when> _1 Map LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1_2`mapQueryForm<when> _1 Map RHS = _1_2`mapQueryForm<when> _1 Map
+++ Condition lexicals:: [_1, Map]
>>> found metafeature _2`mapQueryForm for _2`
>***> Rule with condition: [_1 Map]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`mapQueryForm]
>> Text rule _1 _2 |-->_1_2`sequenceQueryForm<when> _1 Sequence LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1_2`sequenceQueryForm<when> _1 Sequence LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1_2`sequenceQueryForm<when> _1 Sequence RHS = _1_2`sequenceQueryForm<when> _1 Sequence
+++ Condition lexicals:: [_1, Sequence]
>>> found metafeature _2`sequenceQueryForm for _2`
>***> Rule with condition: [_1 Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`sequenceQueryForm]
>> Text rule _1 _* |-->_1_*<when> _1 atom LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1_*<when> _1 atom LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1_*<when> _1 atom RHS = _1_*<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1`dictarguments) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1`dictarguments) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1`dictarguments) RHS = (_1`dictarguments)
>>> found metafeature _1`dictarguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule { } |-->Map{} LHS variables = []
>> Text rule { } |-->Map{} LHS tokens = [{, }]
>> Text rule { } |-->Map{} RHS = Map{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule { _1 } |-->_1 LHS variables = [_1]
>> Text rule { _1 } |-->_1 LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`dictarguments<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 arguments RHS = _1`dictarguments<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 arglist LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 arglist LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 arglist RHS = _1`dictarguments<when> _1 arglist
+++ Condition lexicals:: [_1, arglist]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 arglist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 argument LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 argument LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 argument RHS = _1`dictarguments<when> _1 argument
+++ Condition lexicals:: [_1, argument]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 argument]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 test RHS = _1`dictarguments<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 logical_test RHS = _1`dictarguments<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 comparison RHS = _1`dictarguments<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 expr RHS = _1`dictarguments<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule _1 |-->_1`dictarguments<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->_1`dictarguments<when> _1 atom RHS = _1`dictarguments<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>>> found metafeature _1`dictarguments for _1`
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`dictarguments]
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple RHS = Sequence{_1}<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1) RHS = (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->Sequence{} LHS variables = []
>> Text rule [ ] |-->Sequence{} LHS tokens = [[, ]]
>> Text rule [ ] |-->Sequence{} RHS = Sequence{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule { } |-->Set{} LHS variables = []
>> Text rule { } |-->Set{} LHS tokens = [{, }]
>> Text rule { } |-->Set{} RHS = Set{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`sequenceFormation RHS = _1`sequenceFormation
>>> found metafeature _1`sequenceFormation for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sequenceFormation]
>> Text rule { _1 } |-->_1 LHS variables = [_1]
>> Text rule { _1 } |-->_1 LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ` _1 ` |-->"_1" LHS variables = [_1]
>> Text rule ` _1 ` |-->"_1" LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->"_1" RHS = "_1"
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule "" _1 "" |-->_1 LHS variables = [_1]
>> Text rule "" _1 "" |-->_1 LHS tokens = ["", _1, ""]
>> Text rule "" _1 "" |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->-_1 LHS variables = [_1]
>> Text rule - _1 |-->-_1 LHS tokens = [-, _1]
>> Text rule - _1 |-->-_1 RHS = -_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->null LHS variables = []
>> Text rule None |-->null LHS tokens = [None]
>> Text rule None |-->null RHS = null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule True |-->true LHS variables = []
>> Text rule True |-->true LHS tokens = [True]
>> Text rule True |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule False |-->false LHS variables = []
>> Text rule False |-->false LHS tokens = [False]
>> Text rule False |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule inf |-->Math_PINFINITY LHS variables = []
>> Text rule inf |-->Math_PINFINITY LHS tokens = [inf]
>> Text rule inf |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Infinity |-->Math_PINFINITY LHS variables = []
>> Text rule Infinity |-->Math_PINFINITY LHS tokens = [Infinity]
>> Text rule Infinity |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule nan |-->Math_NaN LHS variables = []
>> Text rule nan |-->Math_NaN LHS tokens = [nan]
>> Text rule nan |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->... LHS variables = []
>> Text rule ... |-->... LHS tokens = [...]
>> Text rule ... |-->... RHS = ...
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule print |-->print LHS variables = []
>> Text rule print |-->print LHS tokens = [print]
>> Text rule print |-->print RHS = print
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule exec |-->exec LHS variables = []
>> Text rule exec |-->exec LHS tokens = [exec]
>> Text rule exec |-->exec RHS = exec
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule int |-->OclType["int"] LHS variables = []
>> Text rule int |-->OclType["int"] LHS tokens = [int]
>> Text rule int |-->OclType["int"] RHS = OclType["int"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule float |-->OclType["double"] LHS variables = []
>> Text rule float |-->OclType["double"] LHS tokens = [float]
>> Text rule float |-->OclType["double"] RHS = OclType["double"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule str |-->OclType["String"] LHS variables = []
>> Text rule str |-->OclType["String"] LHS tokens = [str]
>> Text rule str |-->OclType["String"] RHS = OclType["String"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule bool |-->OclType["boolean"] LHS variables = []
>> Text rule bool |-->OclType["boolean"] LHS tokens = [bool]
>> Text rule bool |-->OclType["boolean"] RHS = OclType["boolean"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule dict |-->OclType["Map"] LHS variables = []
>> Text rule dict |-->OclType["Map"] LHS tokens = [dict]
>> Text rule dict |-->OclType["Map"] RHS = OclType["Map"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule list |-->OclType["Sequence"] LHS variables = []
>> Text rule list |-->OclType["Sequence"] LHS tokens = [list]
>> Text rule list |-->OclType["Sequence"] RHS = OclType["Sequence"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule set |-->OclType["Set"] LHS variables = []
>> Text rule set |-->OclType["Set"] LHS tokens = [set]
>> Text rule set |-->OclType["Set"] RHS = OclType["Set"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule R _1 |-->StringLib.rawString(_1) LHS variables = [_1]
>> Text rule R _1 |-->StringLib.rawString(_1) LHS tokens = [R, _1]
>> Text rule R _1 |-->StringLib.rawString(_1) RHS = StringLib.rawString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule r _1 |-->StringLib.rawString(_1) LHS variables = [_1]
>> Text rule r _1 |-->StringLib.rawString(_1) LHS tokens = [r, _1]
>> Text rule r _1 |-->StringLib.rawString(_1) RHS = StringLib.rawString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule f _1 |-->StringLib.formattedString(_1) LHS variables = [_1]
>> Text rule f _1 |-->StringLib.formattedString(_1) LHS tokens = [f, _1]
>> Text rule f _1 |-->StringLib.formattedString(_1) RHS = StringLib.formattedString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`first<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`first<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`first<when> _1 multiple RHS = _1`first<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`first for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`first]
>> Text rule ( _1 ) |-->_1 LHS variables = [_1]
>> Text rule ( _1 ) |-->_1 LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->Sequence{} LHS variables = []
>> Text rule [ ] |-->Sequence{} LHS tokens = [[, ]]
>> Text rule [ ] |-->Sequence{} RHS = Sequence{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule { } |-->Set{} LHS variables = []
>> Text rule { } |-->Set{} LHS tokens = [{, }]
>> Text rule { } |-->Set{} RHS = Set{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`sequenceFormation RHS = _1`sequenceFormation
>>> found metafeature _1`sequenceFormation for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sequenceFormation]
>> Text rule { _1 } |-->_1 LHS variables = [_1]
>> Text rule { _1 } |-->_1 LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ` _1 ` |-->"_1" LHS variables = [_1]
>> Text rule ` _1 ` |-->"_1" LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->"_1" RHS = "_1"
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->-_1 LHS variables = [_1]
>> Text rule - _1 |-->-_1 LHS tokens = [-, _1]
>> Text rule - _1 |-->-_1 RHS = -_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->null LHS variables = []
>> Text rule None |-->null LHS tokens = [None]
>> Text rule None |-->null RHS = null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule True |-->true LHS variables = []
>> Text rule True |-->true LHS tokens = [True]
>> Text rule True |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule False |-->false LHS variables = []
>> Text rule False |-->false LHS tokens = [False]
>> Text rule False |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule inf |-->Math_PINFINITY LHS variables = []
>> Text rule inf |-->Math_PINFINITY LHS tokens = [inf]
>> Text rule inf |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Infinity |-->Math_PINFINITY LHS variables = []
>> Text rule Infinity |-->Math_PINFINITY LHS tokens = [Infinity]
>> Text rule Infinity |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule nan |-->Math_NaN LHS variables = []
>> Text rule nan |-->Math_NaN LHS tokens = [nan]
>> Text rule nan |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->... LHS variables = []
>> Text rule ... |-->... LHS tokens = [...]
>> Text rule ... |-->... RHS = ...
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule print |-->print LHS variables = []
>> Text rule print |-->print LHS tokens = [print]
>> Text rule print |-->print RHS = print
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule exec |-->exec LHS variables = []
>> Text rule exec |-->exec LHS tokens = [exec]
>> Text rule exec |-->exec RHS = exec
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule int |-->OclType["int"] LHS variables = []
>> Text rule int |-->OclType["int"] LHS tokens = [int]
>> Text rule int |-->OclType["int"] RHS = OclType["int"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule float |-->OclType["double"] LHS variables = []
>> Text rule float |-->OclType["double"] LHS tokens = [float]
>> Text rule float |-->OclType["double"] RHS = OclType["double"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule str |-->OclType["String"] LHS variables = []
>> Text rule str |-->OclType["String"] LHS tokens = [str]
>> Text rule str |-->OclType["String"] RHS = OclType["String"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule bool |-->OclType["boolean"] LHS variables = []
>> Text rule bool |-->OclType["boolean"] LHS tokens = [bool]
>> Text rule bool |-->OclType["boolean"] RHS = OclType["boolean"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule dict |-->OclType["Map"] LHS variables = []
>> Text rule dict |-->OclType["Map"] LHS tokens = [dict]
>> Text rule dict |-->OclType["Map"] RHS = OclType["Map"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule list |-->OclType["Sequence"] LHS variables = []
>> Text rule list |-->OclType["Sequence"] LHS tokens = [list]
>> Text rule list |-->OclType["Sequence"] RHS = OclType["Sequence"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule set |-->OclType["Set"] LHS variables = []
>> Text rule set |-->OclType["Set"] LHS tokens = [set]
>> Text rule set |-->OclType["Set"] RHS = OclType["Set"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule R _1 |-->StringLib.rawString(_1) LHS variables = [_1]
>> Text rule R _1 |-->StringLib.rawString(_1) LHS tokens = [R, _1]
>> Text rule R _1 |-->StringLib.rawString(_1) RHS = StringLib.rawString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule r _1 |-->StringLib.rawString(_1) LHS variables = [_1]
>> Text rule r _1 |-->StringLib.rawString(_1) LHS tokens = [r, _1]
>> Text rule r _1 |-->StringLib.rawString(_1) RHS = StringLib.rawString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule f _1 |-->StringLib.formattedString(_1) LHS variables = [_1]
>> Text rule f _1 |-->StringLib.formattedString(_1) LHS tokens = [f, _1]
>> Text rule f _1 |-->StringLib.formattedString(_1) RHS = StringLib.formattedString(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`removeAtomBrackets<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`removeAtomBrackets<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`removeAtomBrackets<when> _1 arguments RHS = _1`removeAtomBrackets<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`removeAtomBrackets for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeAtomBrackets]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->Map{ _1 |-> _2 } LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->Map{ _1 |-> _2 } LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->Map{ _1 |-> _2 } RHS = Map{ _1 |-> _2 }
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 _3 |-->_3`domainPart->select(_3`variablePart | _3`selectPart)->collect(_3`variablePart | Map{_1 |-> _2})->unionAll()<when> _3 comp_for LHS variables = [_1, _2, _3]
>> Text rule _1 : _2 _3 |-->_3`domainPart->select(_3`variablePart | _3`selectPart)->collect(_3`variablePart | Map{_1 |-> _2})->unionAll()<when> _3 comp_for LHS tokens = [_1, :, _2, _3]
>> Text rule _1 : _2 _3 |-->_3`domainPart->select(_3`variablePart | _3`selectPart)->collect(_3`variablePart | Map{_1 |-> _2})->unionAll()<when> _3 comp_for RHS = _3`domainPart->select(_3`variablePart | _3`selectPart)->collect(_3`variablePart | Map{_1 |-> _2})->unionAll()<when> _3 comp_for
+++ Condition lexicals:: [_3, comp_for]
>>> found metafeature _3`domainPart for _3`
>>> found metafeature _3`variablePart for _3`
>>> found metafeature _3`selectPart for _3`
>>> found metafeature _3`variablePart for _3`
>***> Rule with condition: [_3 comp_for]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`domainPart, _3`variablePart, _3`selectPart]
>> Text rule ** _1 |-->_1 LHS variables = [_1]
>> Text rule ** _1 |-->_1 LHS tokens = [**, _1]
>> Text rule ** _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 , _* |-->Map{ _1 |-> _2 }->union(_*`recurse) LHS variables = [_1, _2, _*]
>> Text rule _1 : _2 , _* |-->Map{ _1 |-> _2 }->union(_*`recurse) LHS tokens = [_1, :, _2, ,, _*]
>> Text rule _1 : _2 , _* |-->Map{ _1 |-> _2 }->union(_*`recurse) RHS = Map{ _1 |-> _2 }->union(_*`recurse)
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) LHS variables = [_1, _*]
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) LHS tokens = [**, _1, ,, _*]
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) RHS = _1->union(_*`recurse)
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1`setFormation LHS variables = [_1]
>> Text rule _1 |-->_1`setFormation LHS tokens = [_1]
>> Text rule _1 |-->_1`setFormation RHS = _1`setFormation
>>> found metafeature _1`setFormation for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`setFormation]
>> Text rule _1 : _2 |-->true LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->true LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->true RHS = true
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 _3 |-->true<when> _3 comp_for LHS variables = [_1, _2, _3]
>> Text rule _1 : _2 _3 |-->true<when> _3 comp_for LHS tokens = [_1, :, _2, _3]
>> Text rule _1 : _2 _3 |-->true<when> _3 comp_for RHS = true<when> _3 comp_for
+++ Condition lexicals:: [_3, comp_for]
>***> Rule with condition: [_3 comp_for]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule ** _1 |-->true LHS variables = [_1]
>> Text rule ** _1 |-->true LHS tokens = [**, _1]
>> Text rule ** _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 , _* |-->true LHS variables = [_1, _2, _*]
>> Text rule _1 : _2 , _* |-->true LHS tokens = [_1, :, _2, ,, _*]
>> Text rule _1 : _2 , _* |-->true RHS = true
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: []
>> Text rule ** _1 , _* |-->true LHS variables = [_1, _*]
>> Text rule ** _1 , _* |-->true LHS tokens = [**, _1, ,, _*]
>> Text rule ** _1 , _* |-->true RHS = true
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule * _1 |-->_1 LHS variables = [_1]
>> Text rule * _1 |-->_1 LHS tokens = [*, _1]
>> Text rule * _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ** _1 |-->_1 LHS variables = [_1]
>> Text rule ** _1 |-->_1 LHS tokens = [**, _1]
>> Text rule ** _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->Set{ _1 } LHS variables = [_1]
>> Text rule _1 |-->Set{ _1 } LHS tokens = [_1]
>> Text rule _1 |-->Set{ _1 } RHS = Set{ _1 }
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) LHS variables = [_1, _*]
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) LHS tokens = [**, _1, ,, _*]
>> Text rule ** _1 , _* |-->_1->union(_*`recurse) RHS = _1->union(_*`recurse)
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 , _* |-->Set{_1}->union(_*`recurse) LHS variables = [_1, _*]
>> Text rule _1 , _* |-->Set{_1}->union(_*`recurse) LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->Set{_1}->union(_*`recurse) RHS = Set{_1}->union(_*`recurse)
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _1)->asSet()<when> _2 comp_for LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _1)->asSet()<when> _2 comp_for LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _1)->asSet()<when> _2 comp_for RHS = _2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _1)->asSet()<when> _2 comp_for
+++ Condition lexicals:: [_2, comp_for]
>>> found metafeature _2`domainPart for _2`
>>> found metafeature _2`variablePart for _2`
>>> found metafeature _2`selectPart for _2`
>>> found metafeature _2`variablePart for _2`
>***> Rule with condition: [_2 comp_for]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`domainPart, _2`variablePart, _2`selectPart]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1,_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1,_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1,_*`recurse RHS = _1,_*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 testlist RHS = _1`hasSideEffect<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 test RHS = _1`hasSideEffect<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 logical_test RHS = _1`hasSideEffect<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 comparison RHS = _1`hasSideEffect<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`hasSideEffect<when> _1 expr RHS = _1`hasSideEffect<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule print _1 |-->_1`hasSideEffect LHS variables = [_1]
>> Text rule print _1 |-->_1`hasSideEffect LHS tokens = [print, _1]
>> Text rule print _1 |-->_1`hasSideEffect RHS = _1`hasSideEffect
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule del _1 |-->_1`hasSideEffect LHS variables = [_1]
>> Text rule del _1 |-->_1`hasSideEffect LHS tokens = [del, _1]
>> Text rule del _1 |-->_1`hasSideEffect RHS = _1`hasSideEffect
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 _2 |-->_2`trailerSideEffect<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`trailerSideEffect<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`trailerSideEffect<when> _1 atom, _2 trailer RHS = _2`trailerSideEffect<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>>> found metafeature _2`trailerSideEffect for _2`
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`trailerSideEffect]
>> Text rule _1 , _* |-->_1`hasSideEffect LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`hasSideEffect LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`hasSideEffect RHS = _1`hasSideEffect
>>> found metafeature _1`hasSideEffect for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_1`hasSideEffect]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`isMapExpression<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 testlist RHS = _1`isMapExpression<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule _1 |-->_1`isMapExpression<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 test RHS = _1`isMapExpression<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule _1 |-->_1`isMapExpression<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 logical_test RHS = _1`isMapExpression<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule _1 |-->_1`isMapExpression<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 comparison RHS = _1`isMapExpression<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule _1 |-->_1`isMapExpression<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 expr RHS = _1`isMapExpression<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule _1 |-->_1`isMapExpression<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->_1`isMapExpression<when> _1 atom RHS = _1`isMapExpression<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>>> found metafeature _1`isMapExpression for _1`
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule print _1 |-->false LHS variables = [_1]
>> Text rule print _1 |-->false LHS tokens = [print, _1]
>> Text rule print _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule del _1 |-->false LHS variables = [_1]
>> Text rule del _1 |-->false LHS tokens = [del, _1]
>> Text rule del _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule dict _1 |-->true LHS variables = [_1]
>> Text rule dict _1 |-->true LHS tokens = [dict, _1]
>> Text rule dict _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->false LHS variables = []
>> Text rule ( ) |-->false LHS tokens = [(, )]
>> Text rule ( ) |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->false<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->false<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->false<when> _1 multiple RHS = false<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`isMapExpression LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`isMapExpression LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`isMapExpression RHS = _1`isMapExpression
>>> found metafeature _1`isMapExpression for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapExpression]
>> Text rule [ ] |-->false LHS variables = []
>> Text rule [ ] |-->false LHS tokens = [[, ]]
>> Text rule [ ] |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->false LHS variables = [_1]
>> Text rule [ _1 ] |-->false LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule { _1 } |-->_1`isMapAtomExpression LHS variables = [_1]
>> Text rule { _1 } |-->_1`isMapAtomExpression LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->_1`isMapAtomExpression RHS = _1`isMapAtomExpression
>>> found metafeature _1`isMapAtomExpression for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isMapAtomExpression]
>> Text rule ` _1 ` |-->false LHS variables = [_1]
>> Text rule ` _1 ` |-->false LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->false LHS variables = [_1]
>> Text rule - _1 |-->false LHS tokens = [-, _1]
>> Text rule - _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->false LHS variables = []
>> Text rule None |-->false LHS tokens = [None]
>> Text rule None |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->false LHS variables = []
>> Text rule ... |-->false LHS tokens = [...]
>> Text rule ... |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer RHS = false<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->false LHS variables = [_1, _*]
>> Text rule _1 , _* |-->false LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->false RHS = false
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 testlist RHS = _1`isSequenceExpression<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 test RHS = _1`isSequenceExpression<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 logical_test RHS = _1`isSequenceExpression<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 comparison RHS = _1`isSequenceExpression<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 expr RHS = _1`isSequenceExpression<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->_1`isSequenceExpression<when> _1 atom RHS = _1`isSequenceExpression<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule print _1 |-->false LHS variables = [_1]
>> Text rule print _1 |-->false LHS tokens = [print, _1]
>> Text rule print _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule del _1 |-->false LHS variables = [_1]
>> Text rule del _1 |-->false LHS tokens = [del, _1]
>> Text rule del _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule dict _1 |-->false LHS variables = [_1]
>> Text rule dict _1 |-->false LHS tokens = [dict, _1]
>> Text rule dict _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule range _1 |-->true LHS variables = [_1]
>> Text rule range _1 |-->true LHS tokens = [range, _1]
>> Text rule range _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->false LHS variables = []
>> Text rule ( ) |-->false LHS tokens = [(, )]
>> Text rule ( ) |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->false<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->false<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->false<when> _1 multiple RHS = false<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`isSequenceExpression LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`isSequenceExpression LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`isSequenceExpression RHS = _1`isSequenceExpression
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule [ ] |-->true LHS variables = []
>> Text rule [ ] |-->true LHS tokens = [[, ]]
>> Text rule [ ] |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->true LHS variables = [_1]
>> Text rule [ _1 ] |-->true LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule { _1 } |-->false LHS variables = [_1]
>> Text rule { _1 } |-->false LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ` _1 ` |-->false LHS variables = [_1]
>> Text rule ` _1 ` |-->false LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->false LHS variables = [_1]
>> Text rule - _1 |-->false LHS tokens = [-, _1]
>> Text rule - _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->false LHS variables = []
>> Text rule None |-->false LHS tokens = [None]
>> Text rule None |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->false LHS variables = []
>> Text rule ... |-->false LHS tokens = [...]
>> Text rule ... |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->_1`isSequenceExpression LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->_1`isSequenceExpression LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->_1`isSequenceExpression RHS = _1`isSequenceExpression
>>> found metafeature _1`isSequenceExpression for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`isSequenceExpression]
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false<when> _1 atom, _2 trailer RHS = false<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->false LHS variables = [_1, _*]
>> Text rule _1 , _* |-->false LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->false RHS = false
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->true<when> _1 Sequence LHS variables = [_1]
>> Text rule _1 |-->true<when> _1 Sequence LHS tokens = [_1]
>> Text rule _1 |-->true<when> _1 Sequence RHS = true<when> _1 Sequence
+++ Condition lexicals:: [_1, Sequence]
>***> Rule with condition: [_1 Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expression LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expression LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expression RHS = _1`updateForm<when> _1 testlist_star_expression
+++ Condition lexicals:: [_1, testlist_star_expression]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 testlist_star_expression]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist RHS = _1`updateForm<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule _1 |-->_1`updateForm<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 test RHS = _1`updateForm<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule _1 |-->_1`updateForm<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 logical_test RHS = _1`updateForm<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule _1 |-->_1`updateForm<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 comparison RHS = _1`updateForm<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule _1 |-->_1`updateForm<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 expr RHS = _1`updateForm<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule exec _1 |-->_0`pythonExec LHS variables = [_1]
>> Text rule exec _1 |-->_0`pythonExec LHS tokens = [exec, _1]
>> Text rule exec _1 |-->_0`pythonExec RHS = _0`pythonExec
>> These will be treated as global variables: [_0]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule exec _* |-->    execute _* LHS variables = [_*]
>> Text rule exec _* |-->    execute _* LHS tokens = [exec, _*]
>> Text rule exec _* |-->    execute _* RHS =     execute _*
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->    execute _1`printTrailer->display() LHS variables = [_1]
>> Text rule print _1 |-->    execute _1`printTrailer->display() LHS tokens = [print, _1]
>> Text rule print _1 |-->    execute _1`printTrailer->display() RHS =     execute _1`printTrailer->display()
>>> found metafeature _1`printTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule del _1 |-->    execute _1->isDeleted() LHS variables = [_1]
>> Text rule del _1 |-->    execute _1->isDeleted() LHS tokens = [del, _1]
>> Text rule del _1 |-->    execute _1->isDeleted() RHS =     execute _1->isDeleted()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule await asyncio _1 |-->    _1`asyncioTrailer<when> _1 trailer LHS variables = [_1]
>> Text rule await asyncio _1 |-->    _1`asyncioTrailer<when> _1 trailer LHS tokens = [await, asyncio, _1]
>> Text rule await asyncio _1 |-->    _1`asyncioTrailer<when> _1 trailer RHS =     _1`asyncioTrailer<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`asyncioTrailer for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asyncioTrailer]
>> Text rule await _1 |-->    _1.join() LHS variables = [_1]
>> Text rule await _1 |-->    _1.join() LHS tokens = [await, _1]
>> Text rule await _1 |-->    _1.join() RHS =     _1.join()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule np _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer LHS variables = [_1]
>> Text rule np _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer LHS tokens = [np, _1]
>> Text rule np _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer RHS =     _1`removeTrailerBrackets := _1`numpyTrailer
>>> found metafeature _1`removeTrailerBrackets for _1`
>>> found metafeature _1`numpyTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeTrailerBrackets, _1`numpyTrailer]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS tokens = [np, _1, _2]
>> Text rule np _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random RHS = _2`npRandomTrailer<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomTrailer for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomTrailer]
>> Text rule pickle _1 |-->    _1`thirdSecondArg.writeObject(_1`thirdFirstArg)<when> _1`second dump LHS variables = [_1]
>> Text rule pickle _1 |-->    _1`thirdSecondArg.writeObject(_1`thirdFirstArg)<when> _1`second dump LHS tokens = [pickle, _1]
>> Text rule pickle _1 |-->    _1`thirdSecondArg.writeObject(_1`thirdFirstArg)<when> _1`second dump RHS =     _1`thirdSecondArg.writeObject(_1`thirdFirstArg)<when> _1`second dump
+++ Condition lexicals:: [_1, `, second, dump]
>>> found metafeature _1`thirdSecondArg for _1`
>>> found metafeature _1`thirdFirstArg for _1`
>***> Rule with condition: [_1`second dump]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`thirdSecondArg, _1`thirdFirstArg]
>> Text rule asyncio _1 |-->    _1`asyncioTrailer LHS variables = [_1]
>> Text rule asyncio _1 |-->    _1`asyncioTrailer LHS tokens = [asyncio, _1]
>> Text rule asyncio _1 |-->    _1`asyncioTrailer RHS =     _1`asyncioTrailer
>>> found metafeature _1`asyncioTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asyncioTrailer]
>> Text rule numpy _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer LHS variables = [_1]
>> Text rule numpy _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer LHS tokens = [numpy, _1]
>> Text rule numpy _1 |-->    _1`removeTrailerBrackets := _1`numpyTrailer RHS =     _1`removeTrailerBrackets := _1`numpyTrailer
>>> found metafeature _1`removeTrailerBrackets for _1`
>>> found metafeature _1`numpyTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeTrailerBrackets, _1`numpyTrailer]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random LHS tokens = [numpy, _1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomTrailer<when> _1 matches .random RHS = _2`npRandomTrailer<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomTrailer for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomTrailer]
>> Text rule _1 _2 |-->    _1.closeFile()<when> _1 atom, _2`second close LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1.closeFile()<when> _1 atom, _2`second close LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1.closeFile()<when> _1 atom, _2`second close RHS =     _1.closeFile()<when> _1 atom, _2`second close
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, close]
>***> Rule with condition: [_1 atom, _2`second close]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1.write_2`third<when> _1 atom, _2`second write LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1.write_2`third<when> _1 atom, _2`second write LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1.write_2`third<when> _1 atom, _2`second write RHS =     _1.write_2`third<when> _1 atom, _2`second write
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, write]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second write]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second append LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second append LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second append RHS =     execute (_2`third : _1)<when> _1 atom, _2`second append
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, append]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second append]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second add LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second add LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third : _1)<when> _1 atom, _2`second add RHS =     execute (_2`third : _1)<when> _1 atom, _2`second add
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, add]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second add]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second remove LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second remove LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second remove RHS =     execute (_2`third /: _1)<when> _1 atom, _2`second remove
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, remove]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second remove]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second discard LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second discard LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /: _1)<when> _1 atom, _2`second discard RHS =     execute (_2`third /: _1)<when> _1 atom, _2`second discard
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, discard]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second discard]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third <: _1)<when> _1 atom, _2`second update LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third <: _1)<when> _1 atom, _2`second update LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third <: _1)<when> _1 atom, _2`second update RHS =     execute (_2`third <: _1)<when> _1 atom, _2`second update
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, update]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second update]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_2`third /<: _1)<when> _1 atom, _2`second difference_update LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /<: _1)<when> _1 atom, _2`second difference_update LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_2`third /<: _1)<when> _1 atom, _2`second difference_update RHS =     execute (_2`third /<: _1)<when> _1 atom, _2`second difference_update
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, difference_update]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second difference_update]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute ((_1 - _2`third) /<: _1)<when> _1 atom, _2`second intersection_update LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute ((_1 - _2`third) /<: _1)<when> _1 atom, _2`second intersection_update LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute ((_1 - _2`third) /<: _1)<when> _1 atom, _2`second intersection_update RHS =     execute ((_1 - _2`third) /<: _1)<when> _1 atom, _2`second intersection_update
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, intersection_update]
>>> found metafeature _2`third for _2`
>***> Rule with condition: [_1 atom, _2`second intersection_update]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`third]
>> Text rule _1 _2 |-->    execute (_1 /<: _1)<when> _1 atom, _2`second clear LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    execute (_1 /<: _1)<when> _1 atom, _2`second clear LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    execute (_1 /<: _1)<when> _1 atom, _2`second clear RHS =     execute (_1 /<: _1)<when> _1 atom, _2`second clear
+++ Condition lexicals:: [_1, atom, ,, _2, `, second, clear]
>***> Rule with condition: [_1 atom, _2`second clear]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1`removeAtomBrackets := _1_2`trailerUpdateForm<when> _1 atom, _2 trailer, _2`isUpdating true LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1`removeAtomBrackets := _1_2`trailerUpdateForm<when> _1 atom, _2 trailer, _2`isUpdating true LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1`removeAtomBrackets := _1_2`trailerUpdateForm<when> _1 atom, _2 trailer, _2`isUpdating true RHS =     _1`removeAtomBrackets := _1_2`trailerUpdateForm<when> _1 atom, _2 trailer, _2`isUpdating true
+++ Condition lexicals:: [_1, atom, ,, _2, trailer, ,, _2, `, isUpdating, true]
>>> found metafeature _1`removeAtomBrackets for _1`
>>> found metafeature _2`trailerUpdateForm for _2`
>***> Rule with condition: [_1 atom, _2 trailer, _2`isUpdating true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`removeAtomBrackets, _2`trailerUpdateForm]
>> Text rule _1 _2 |-->    _1_2<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1_2<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1_2<when> _1 atom, _2 trailer RHS =     _1_2<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->    _1 ;\n_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->    _1 ;\n_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->    _1 ;\n_*`recurse RHS =     _1 ;\n_*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`errorToUML<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 testlist RHS = _1`errorToUML<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 |-->_1`errorToUML<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 test RHS = _1`errorToUML<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 |-->_1`errorToUML<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 logical_test RHS = _1`errorToUML<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 |-->_1`errorToUML<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 comparison RHS = _1`errorToUML<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 |-->_1`errorToUML<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 expr RHS = _1`errorToUML<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 |-->_1`errorToUML<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->_1`errorToUML<when> _1 atom RHS = _1`errorToUML<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 _2 |-->_1`errorToUML_2<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1`errorToUML_2<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1`errorToUML_2<when> _1 atom, _2 trailer RHS = _1`errorToUML_2<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>>> found metafeature _1`errorToUML for _1`
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->Sequence{_1}<when> _1 multiple RHS = Sequence{_1}<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1`errorToUML) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1`errorToUML) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1`errorToUML) RHS = (_1`errorToUML)
>>> found metafeature _1`errorToUML for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule [ ] |-->Sequence{} LHS variables = []
>> Text rule [ ] |-->Sequence{} LHS tokens = [[, ]]
>> Text rule [ ] |-->Sequence{} RHS = Sequence{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`sequenceFormation LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`sequenceFormation RHS = _1`sequenceFormation
>>> found metafeature _1`sequenceFormation for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sequenceFormation]
>> Text rule { _1 } |-->_1 LHS variables = [_1]
>> Text rule { _1 } |-->_1 LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ` _1 ` |-->"_1" LHS variables = [_1]
>> Text rule ` _1 ` |-->"_1" LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->"_1" RHS = "_1"
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->-_1 LHS variables = [_1]
>> Text rule - _1 |-->-_1 LHS tokens = [-, _1]
>> Text rule - _1 |-->-_1 RHS = -_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->null LHS variables = []
>> Text rule None |-->null LHS tokens = [None]
>> Text rule None |-->null RHS = null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->... LHS variables = []
>> Text rule ... |-->... LHS tokens = [...]
>> Text rule ... |-->... RHS = ...
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule print |-->print LHS variables = []
>> Text rule print |-->print LHS tokens = [print]
>> Text rule print |-->print RHS = print
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule exec |-->exec LHS variables = []
>> Text rule exec |-->exec LHS tokens = [exec]
>> Text rule exec |-->exec RHS = exec
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule int |-->int LHS variables = []
>> Text rule int |-->int LHS tokens = [int]
>> Text rule int |-->int RHS = int
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule float |-->double LHS variables = []
>> Text rule float |-->double LHS tokens = [float]
>> Text rule float |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule str |-->String LHS variables = []
>> Text rule str |-->String LHS tokens = [str]
>> Text rule str |-->String RHS = String
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1.new_1<when> _1 name LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1.new_1<when> _1 name LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1.new_1<when> _1 name RHS = _1.new_1<when> _1 name
+++ Condition lexicals:: [_1, name]
>***> Rule with condition: [_1 name]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1.new_1<when> _1 name LHS variables = [_1]
>> Text rule _1 |-->_1.new_1<when> _1 name LHS tokens = [_1]
>> Text rule _1 |-->_1.new_1<when> _1 name RHS = _1.new_1<when> _1 name
+++ Condition lexicals:: [_1, name]
>***> Rule with condition: [_1 name]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |--> LHS variables = [_1, _*]
>> Text rule _1 , _* |--> LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 . _2 |-->_1._2 LHS variables = [_1, _2]
>> Text rule _1 . _2 |-->_1._2 LHS tokens = [_1, ., _2]
>> Text rule _1 . _2 |-->_1._2 RHS = _1._2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _ |-->_anon LHS variables = []
>> Text rule _ |-->_anon LHS tokens = [_]
>> Text rule _ |-->_anon RHS = _anon
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule True |-->true LHS variables = []
>> Text rule True |-->true LHS tokens = [True]
>> Text rule True |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule False |-->false LHS variables = []
>> Text rule False |-->false LHS tokens = [False]
>> Text rule False |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule None |-->null LHS variables = []
>> Text rule None |-->null LHS tokens = [None]
>> Text rule None |-->null RHS = null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule inf |-->Math_PINFINITY LHS variables = []
>> Text rule inf |-->Math_PINFINITY LHS tokens = [inf]
>> Text rule inf |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Infinity |-->Math_PINFINITY LHS variables = []
>> Text rule Infinity |-->Math_PINFINITY LHS tokens = [Infinity]
>> Text rule Infinity |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule nan |-->Math_NaN LHS variables = []
>> Text rule nan |-->Math_NaN LHS tokens = [nan]
>> Text rule nan |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ValueError |-->IncorrectElementException LHS variables = []
>> Text rule ValueError |-->IncorrectElementException LHS tokens = [ValueError]
>> Text rule ValueError |-->IncorrectElementException RHS = IncorrectElementException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule BaseException |-->OclException LHS variables = []
>> Text rule BaseException |-->OclException LHS tokens = [BaseException]
>> Text rule BaseException |-->OclException RHS = OclException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Exception |-->ProgramException LHS variables = []
>> Text rule Exception |-->ProgramException LHS tokens = [Exception]
>> Text rule Exception |-->ProgramException RHS = ProgramException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule OSError |-->SystemException LHS variables = []
>> Text rule OSError |-->SystemException LHS tokens = [OSError]
>> Text rule OSError |-->SystemException RHS = SystemException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule IOError |-->IOException LHS variables = []
>> Text rule IOError |-->IOException LHS tokens = [IOError]
>> Text rule IOError |-->IOException RHS = IOException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule TypeError |-->CastingException LHS variables = []
>> Text rule TypeError |-->CastingException LHS tokens = [TypeError]
>> Text rule TypeError |-->CastingException RHS = CastingException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule AttributeError |-->NullAccessException LHS variables = []
>> Text rule AttributeError |-->NullAccessException LHS tokens = [AttributeError]
>> Text rule AttributeError |-->NullAccessException RHS = NullAccessException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule LookupError |-->IndexingException LHS variables = []
>> Text rule LookupError |-->IndexingException LHS tokens = [LookupError]
>> Text rule LookupError |-->IndexingException RHS = IndexingException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ArithmeticError |-->ArithmeticException LHS variables = []
>> Text rule ArithmeticError |-->ArithmeticException LHS tokens = [ArithmeticError]
>> Text rule ArithmeticError |-->ArithmeticException RHS = ArithmeticException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule AssertionError |-->AssertionException LHS variables = []
>> Text rule AssertionError |-->AssertionException LHS tokens = [AssertionError]
>> Text rule AssertionError |-->AssertionException RHS = AssertionException
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Random |-->OclRandom LHS variables = []
>> Text rule Random |-->OclRandom LHS tokens = [Random]
>> Text rule Random |-->OclRandom RHS = OclRandom
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule int |-->OclType["int"] LHS variables = []
>> Text rule int |-->OclType["int"] LHS tokens = [int]
>> Text rule int |-->OclType["int"] RHS = OclType["int"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule float |-->OclType["double"] LHS variables = []
>> Text rule float |-->OclType["double"] LHS tokens = [float]
>> Text rule float |-->OclType["double"] RHS = OclType["double"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule str |-->OclType["String"] LHS variables = []
>> Text rule str |-->OclType["String"] LHS tokens = [str]
>> Text rule str |-->OclType["String"] RHS = OclType["String"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule bool |-->OclType["boolean"] LHS variables = []
>> Text rule bool |-->OclType["boolean"] LHS tokens = [bool]
>> Text rule bool |-->OclType["boolean"] RHS = OclType["boolean"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*E.* LHS variables = [_1]
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*E.* LHS tokens = [_1]
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*E.* RHS = ("_1")->toReal()<when> _1 matches .*E.*
+++ Condition lexicals:: [_1, matches, ., *, E., *]
>***> Rule with condition: [_1 matches .*E.*]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*e.* LHS variables = [_1]
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*e.* LHS tokens = [_1]
>> Text rule _1 |-->("_1")->toReal()<when> _1 matches .*e.* RHS = ("_1")->toReal()<when> _1 matches .*e.*
+++ Condition lexicals:: [_1, matches, ., *, e., *]
>***> Rule with condition: [_1 matches .*e.*]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule * |-->$star : Sequence(OclAny) LHS variables = []
>> Text rule * |-->$star : Sequence(OclAny) LHS tokens = [*]
>> Text rule * |-->$star : Sequence(OclAny) RHS = $star : Sequence(OclAny)
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 : OclAny LHS variables = [_1]
>> Text rule _1 |-->_1 : OclAny LHS tokens = [_1]
>> Text rule _1 |-->_1 : OclAny RHS = _1 : OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->_1 : int<when> _2 integer LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 : int<when> _2 integer LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 : int<when> _2 integer RHS = _1 : int<when> _2 integer
+++ Condition lexicals:: [_2, integer]
>***> Rule with condition: [_2 integer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->_1 : double<when> _2 real LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 : double<when> _2 real LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 : double<when> _2 real RHS = _1 : double<when> _2 real
+++ Condition lexicals:: [_2, real]
>***> Rule with condition: [_2 real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->_1 : String<when> _2 String LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 : String<when> _2 String LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 : String<when> _2 String RHS = _1 : String<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->_1 : boolean<when> _2 boolean LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 : boolean<when> _2 boolean LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 : boolean<when> _2 boolean RHS = _1 : boolean<when> _2 boolean
+++ Condition lexicals:: [_2, boolean]
>***> Rule with condition: [_2 boolean]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->_1 : OclAny LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 : OclAny LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 : OclAny RHS = _1 : OclAny
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule * _1 |-->_1 : Sequence(OclAny) LHS variables = [_1]
>> Text rule * _1 |-->_1 : Sequence(OclAny) LHS tokens = [*, _1]
>> Text rule * _1 |-->_1 : Sequence(OclAny) RHS = _1 : Sequence(OclAny)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ** _1 |-->_1 : Map(String, OclAny) LHS variables = [_1]
>> Text rule ** _1 |-->_1 : Map(String, OclAny) LHS tokens = [**, _1]
>> Text rule ** _1 |-->_1 : Map(String, OclAny) RHS = _1 : Map(String, OclAny)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , |-->_1 LHS variables = [_1]
>> Text rule _1 , |-->_1 LHS tokens = [_1, ,]
>> Text rule _1 , |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1`defaultParamCode LHS variables = [_1]
>> Text rule _1 |-->_1`defaultParamCode LHS tokens = [_1]
>> Text rule _1 |-->_1`defaultParamCode RHS = _1`defaultParamCode
>>> found metafeature _1`defaultParamCode for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`defaultParamCode]
>> Text rule _1 , |-->_1`defaultParamCode LHS variables = [_1]
>> Text rule _1 , |-->_1`defaultParamCode LHS tokens = [_1, ,]
>> Text rule _1 , |-->_1`defaultParamCode RHS = _1`defaultParamCode
>>> found metafeature _1`defaultParamCode for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`defaultParamCode]
>> Text rule _1 , _* |-->_1`defaultParamCode_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`defaultParamCode_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`defaultParamCode_*`recurse RHS = _1`defaultParamCode_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`defaultParamCode for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`defaultParamCode]
>> Text rule _1 |-->_1`asAttributes LHS variables = [_1]
>> Text rule _1 |-->_1`asAttributes LHS tokens = [_1]
>> Text rule _1 |-->_1`asAttributes RHS = _1`asAttributes
>>> found metafeature _1`asAttributes for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asAttributes]
>> Text rule _1 , |-->_1`asAttributes LHS variables = [_1]
>> Text rule _1 , |-->_1`asAttributes LHS tokens = [_1, ,]
>> Text rule _1 , |-->_1`asAttributes RHS = _1`asAttributes
>>> found metafeature _1`asAttributes for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asAttributes]
>> Text rule _1 , _* |-->_1`asAttributes_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`asAttributes_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`asAttributes_*`recurse RHS = _1`asAttributes_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`asAttributes for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`asAttributes]
>> Text rule _1 |-->_1`asSettings LHS variables = [_1]
>> Text rule _1 |-->_1`asSettings LHS tokens = [_1]
>> Text rule _1 |-->_1`asSettings RHS = _1`asSettings
>>> found metafeature _1`asSettings for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asSettings]
>> Text rule _1 , |-->_1`asSettings LHS variables = [_1]
>> Text rule _1 , |-->_1`asSettings LHS tokens = [_1, ,]
>> Text rule _1 , |-->_1`asSettings RHS = _1`asSettings
>>> found metafeature _1`asSettings for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asSettings]
>> Text rule _1 , _* |-->_1`asSettings_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`asSettings_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`asSettings_*`recurse RHS = _1`asSettings_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`asSettings for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`asSettings]
>> Text rule self |--> LHS variables = []
>> Text rule self |--> LHS tokens = [self]
>> Text rule self |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`parametersTail<when> _1 def_parameters LHS variables = [_1]
>> Text rule _1 |-->_1`parametersTail<when> _1 def_parameters LHS tokens = [_1]
>> Text rule _1 |-->_1`parametersTail<when> _1 def_parameters RHS = _1`parametersTail<when> _1 def_parameters
+++ Condition lexicals:: [_1, def_parameters]
>>> found metafeature _1`parametersTail for _1`
>***> Rule with condition: [_1 def_parameters]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`parametersTail]
>> Text rule self , |--> LHS variables = []
>> Text rule self , |--> LHS tokens = [self, ,]
>> Text rule self , |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 , |-->_1 LHS variables = [_1]
>> Text rule _1 , |-->_1 LHS tokens = [_1, ,]
>> Text rule _1 , |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule self , _* |-->_* LHS variables = [_*]
>> Text rule self , _* |-->_* LHS tokens = [self, ,, _*]
>> Text rule self , _* |-->_* RHS = _*
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1 , _* LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1 , _* LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1 , _* RHS = _1 , _*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule * _1 |-->_1 : Sequence(OclAny)<action> _1 Sequence LHS variables = [_1]
>> Text rule * _1 |-->_1 : Sequence(OclAny)<action> _1 Sequence LHS tokens = [*, _1]
>> Text rule * _1 |-->_1 : Sequence(OclAny)<action> _1 Sequence RHS = _1 : Sequence(OclAny)<action> _1 Sequence
+++ Action lexicals:: [_1, Sequence]
>> Rule actions are:  _1 Sequence [_1 Sequence]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ** _1 |-->_1 : Map(String, OclAny)<action> _1 Map LHS variables = [_1]
>> Text rule ** _1 |-->_1 : Map(String, OclAny)<action> _1 Map LHS tokens = [**, _1]
>> Text rule ** _1 |-->_1 : Map(String, OclAny)<action> _1 Map RHS = _1 : Map(String, OclAny)<action> _1 Map
+++ Action lexicals:: [_1, Map]
>> Rule actions are:  _1 Map [_1 Map]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1`paramDefaultCode LHS variables = [_1]
>> Text rule _1 |-->_1`paramDefaultCode LHS tokens = [_1]
>> Text rule _1 |-->_1`paramDefaultCode RHS = _1`paramDefaultCode
>>> found metafeature _1`paramDefaultCode for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`paramDefaultCode]
>> Text rule _1 , _* |-->_1`paramDefaultCode_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`paramDefaultCode_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`paramDefaultCode_*`recurse RHS = _1`paramDefaultCode_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`paramDefaultCode for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`paramDefaultCode]
>> Text rule _1 |-->_1`asAttribute LHS variables = [_1]
>> Text rule _1 |-->_1`asAttribute LHS tokens = [_1]
>> Text rule _1 |-->_1`asAttribute RHS = _1`asAttribute
>>> found metafeature _1`asAttribute for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asAttribute]
>> Text rule _1 , _* |-->_1`asAttribute_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`asAttribute_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`asAttribute_*`recurse RHS = _1`asAttribute_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`asAttribute for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`asAttribute]
>> Text rule _1 |-->_1`asSetting LHS variables = [_1]
>> Text rule _1 |-->_1`asSetting LHS tokens = [_1]
>> Text rule _1 |-->_1`asSetting RHS = _1`asSetting
>>> found metafeature _1`asSetting for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asSetting]
>> Text rule _1 , _* |-->_1`asSetting_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1`asSetting_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1`asSetting_*`recurse RHS = _1`asSetting_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`asSetting for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`asSetting]
>> Text rule _1 = _2 |-->_1`parameterName : String<when> _2 String, _1 1ary <action> _1`parameterName String, _1`defined true LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1`parameterName : String<when> _2 String, _1 1ary <action> _1`parameterName String, _1`defined true LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1`parameterName : String<when> _2 String, _1 1ary <action> _1`parameterName String, _1`defined true RHS = _1`parameterName : String<when> _2 String, _1 1ary <action> _1`parameterName String, _1`defined true
+++ Action lexicals:: [_1, `, parameterName, String, ,, _1, `, defined, true]
>> Rule actions are:  _1`parameterName String, _1`defined true [_1`parameterName String, _1`defined true]
+++ Condition lexicals:: [_2, String, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 String, _1 1ary] and actions: [_1`parameterName String, _1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->_1`parameterName : int<when> _2 int, _1 1ary <action> _1`parameterName int, _1`defined true LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1`parameterName : int<when> _2 int, _1 1ary <action> _1`parameterName int, _1`defined true LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1`parameterName : int<when> _2 int, _1 1ary <action> _1`parameterName int, _1`defined true RHS = _1`parameterName : int<when> _2 int, _1 1ary <action> _1`parameterName int, _1`defined true
+++ Action lexicals:: [_1, `, parameterName, int, ,, _1, `, defined, true]
>> Rule actions are:  _1`parameterName int, _1`defined true [_1`parameterName int, _1`defined true]
+++ Condition lexicals:: [_2, int, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 int, _1 1ary] and actions: [_1`parameterName int, _1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->_1`parameterName : double<when> _2 real, _1 1ary <action> _1`parameterName real, _1`defined true LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1`parameterName : double<when> _2 real, _1 1ary <action> _1`parameterName real, _1`defined true LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1`parameterName : double<when> _2 real, _1 1ary <action> _1`parameterName real, _1`defined true RHS = _1`parameterName : double<when> _2 real, _1 1ary <action> _1`parameterName real, _1`defined true
+++ Action lexicals:: [_1, `, parameterName, real, ,, _1, `, defined, true]
>> Rule actions are:  _1`parameterName real, _1`defined true [_1`parameterName real, _1`defined true]
+++ Condition lexicals:: [_2, real, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 real, _1 1ary] and actions: [_1`parameterName real, _1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->_1<action> _1`defined true LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1<action> _1`defined true LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1<action> _1`defined true RHS = _1<action> _1`defined true
+++ Action lexicals:: [_1, `, defined, true]
>> Rule actions are:  _1`defined true [_1`defined true]
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<action> _1`defined true LHS variables = [_1]
>> Text rule _1 |-->_1<action> _1`defined true LHS tokens = [_1]
>> Text rule _1 |-->_1<action> _1`defined true RHS = _1<action> _1`defined true
+++ Action lexicals:: [_1, `, defined, true]
>> Rule actions are:  _1`defined true [_1`defined true]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule * |--> LHS variables = []
>> Text rule * |--> LHS tokens = [*]
>> Text rule * |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->    if _1`parameterName->oclIsUndefined() then _1`parameterName := _2 else skip;\n LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->    if _1`parameterName->oclIsUndefined() then _1`parameterName := _2 else skip;\n LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->    if _1`parameterName->oclIsUndefined() then _1`parameterName := _2 else skip;\n RHS =     if _1`parameterName->oclIsUndefined() then _1`parameterName := _2 else skip;\n
>>> found metafeature _1`parameterName for _1`
>>> found metafeature _1`parameterName for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule * |--> LHS variables = []
>> Text rule * |--> LHS tokens = [*]
>> Text rule * |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->  attribute _1`parameterName : String;\n<when> _2 String, _1 1ary <action> _1`parameterName String LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : String;\n<when> _2 String, _1 1ary <action> _1`parameterName String LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : String;\n<when> _2 String, _1 1ary <action> _1`parameterName String RHS =   attribute _1`parameterName : String;\n<when> _2 String, _1 1ary <action> _1`parameterName String
+++ Action lexicals:: [_1, `, parameterName, String]
>> Rule actions are:  _1`parameterName String [_1`parameterName String]
+++ Condition lexicals:: [_2, String, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 String, _1 1ary] and actions: [_1`parameterName String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : int;\n<when> _2 int, _1 1ary <action> _1`parameterName int LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : int;\n<when> _2 int, _1 1ary <action> _1`parameterName int LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : int;\n<when> _2 int, _1 1ary <action> _1`parameterName int RHS =   attribute _1`parameterName : int;\n<when> _2 int, _1 1ary <action> _1`parameterName int
+++ Action lexicals:: [_1, `, parameterName, int]
>> Rule actions are:  _1`parameterName int [_1`parameterName int]
+++ Condition lexicals:: [_2, int, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 int, _1 1ary] and actions: [_1`parameterName int]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : double;\n<when> _2 real, _1 1ary <action> _1`parameterName real LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : double;\n<when> _2 real, _1 1ary <action> _1`parameterName real LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->  attribute _1`parameterName : double;\n<when> _2 real, _1 1ary <action> _1`parameterName real RHS =   attribute _1`parameterName : double;\n<when> _2 real, _1 1ary <action> _1`parameterName real
+++ Action lexicals:: [_1, `, parameterName, real]
>> Rule actions are:  _1`parameterName real [_1`parameterName real]
+++ Condition lexicals:: [_2, real, ,, _1, 1ary]
>>> found metafeature _1`parameterName for _1`
>> Global variables: []
>***> Rule with condition: [_2 real, _1 1ary] and actions: [_1`parameterName real]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule _1 = _2 |-->_1 LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_1 LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_1 RHS = _1
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule * |--> LHS variables = []
>> Text rule * |--> LHS tokens = [*]
>> Text rule * |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`asAttribute<when> _1 named_parameter LHS variables = [_1]
>> Text rule _1 |-->_1`asAttribute<when> _1 named_parameter LHS tokens = [_1]
>> Text rule _1 |-->_1`asAttribute<when> _1 named_parameter RHS = _1`asAttribute<when> _1 named_parameter
+++ Condition lexicals:: [_1, named_parameter]
>>> found metafeature _1`asAttribute for _1`
>***> Rule with condition: [_1 named_parameter]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asAttribute]
>> Text rule _1 |-->  attribute _1 : OclAny;\n LHS variables = [_1]
>> Text rule _1 |-->  attribute _1 : OclAny;\n LHS tokens = [_1]
>> Text rule _1 |-->  attribute _1 : OclAny;\n RHS =   attribute _1 : OclAny;\n
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : int |-->  attribute _1 : int;\n<action> _1 int LHS variables = [_1]
>> Text rule _1 : int |-->  attribute _1 : int;\n<action> _1 int LHS tokens = [_1, :, int]
>> Text rule _1 : int |-->  attribute _1 : int;\n<action> _1 int RHS =   attribute _1 : int;\n<action> _1 int
+++ Action lexicals:: [_1, int]
>> Rule actions are:  _1 int [_1 int]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : bool |-->  attribute _1 : boolean;\n<action> _1 boolean LHS variables = [_1]
>> Text rule _1 : bool |-->  attribute _1 : boolean;\n<action> _1 boolean LHS tokens = [_1, :, bool]
>> Text rule _1 : bool |-->  attribute _1 : boolean;\n<action> _1 boolean RHS =   attribute _1 : boolean;\n<action> _1 boolean
+++ Action lexicals:: [_1, boolean]
>> Rule actions are:  _1 boolean [_1 boolean]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : float |-->  attribute _1 : double;\n<action> _1 real LHS variables = [_1]
>> Text rule _1 : float |-->  attribute _1 : double;\n<action> _1 real LHS tokens = [_1, :, float]
>> Text rule _1 : float |-->  attribute _1 : double;\n<action> _1 real RHS =   attribute _1 : double;\n<action> _1 real
+++ Action lexicals:: [_1, real]
>> Rule actions are:  _1 real [_1 real]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : dict |-->  attribute _1 : Map(String,OclAny);\n<action> _1 Map LHS variables = [_1]
>> Text rule _1 : dict |-->  attribute _1 : Map(String,OclAny);\n<action> _1 Map LHS tokens = [_1, :, dict]
>> Text rule _1 : dict |-->  attribute _1 : Map(String,OclAny);\n<action> _1 Map RHS =   attribute _1 : Map(String,OclAny);\n<action> _1 Map
+++ Action lexicals:: [_1, Map]
>> Rule actions are:  _1 Map [_1 Map]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : str |-->  attribute _1 : String;\n<action> _1 String LHS variables = [_1]
>> Text rule _1 : str |-->  attribute _1 : String;\n<action> _1 String LHS tokens = [_1, :, str]
>> Text rule _1 : str |-->  attribute _1 : String;\n<action> _1 String RHS =   attribute _1 : String;\n<action> _1 String
+++ Action lexicals:: [_1, String]
>> Rule actions are:  _1 String [_1 String]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : list |-->  attribute _1 : Sequence(OclAny);\n<action> _1 Sequence LHS variables = [_1]
>> Text rule _1 : list |-->  attribute _1 : Sequence(OclAny);\n<action> _1 Sequence LHS tokens = [_1, :, list]
>> Text rule _1 : list |-->  attribute _1 : Sequence(OclAny);\n<action> _1 Sequence RHS =   attribute _1 : Sequence(OclAny);\n<action> _1 Sequence
+++ Action lexicals:: [_1, Sequence]
>> Rule actions are:  _1 Sequence [_1 Sequence]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : set |-->  attribute _1 : Set(OclAny);\n<action> _1 Set LHS variables = [_1]
>> Text rule _1 : set |-->  attribute _1 : Set(OclAny);\n<action> _1 Set LHS tokens = [_1, :, set]
>> Text rule _1 : set |-->  attribute _1 : Set(OclAny);\n<action> _1 Set RHS =   attribute _1 : Set(OclAny);\n<action> _1 Set
+++ Action lexicals:: [_1, Set]
>> Rule actions are:  _1 Set [_1 Set]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->  attribute _1 : _2;\n<action> _1 _2 LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->  attribute _1 : _2;\n<action> _1 _2 LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->  attribute _1 : _2;\n<action> _1 _2 RHS =   attribute _1 : _2;\n<action> _1 _2
+++ Action lexicals:: [_1, _2]
>> Rule actions are:  _1 _2 [_1 _2]
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 = _2 |-->resx._1`parameterName = _1`parameterName & LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->resx._1`parameterName = _1`parameterName & LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->resx._1`parameterName = _1`parameterName & RHS = resx._1`parameterName = _1`parameterName &
>>> found metafeature _1`parameterName for _1`
>>> found metafeature _1`parameterName for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parameterName]
>> Text rule * |--> LHS variables = []
>> Text rule * |--> LHS tokens = [*]
>> Text rule * |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`asSetting<when> _1 named_parameter LHS variables = [_1]
>> Text rule _1 |-->_1`asSetting<when> _1 named_parameter LHS tokens = [_1]
>> Text rule _1 |-->_1`asSetting<when> _1 named_parameter RHS = _1`asSetting<when> _1 named_parameter
+++ Condition lexicals:: [_1, named_parameter]
>>> found metafeature _1`asSetting for _1`
>***> Rule with condition: [_1 named_parameter]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`asSetting]
>> Text rule _1 |-->resx._1 = _1 & LHS variables = [_1]
>> Text rule _1 |-->resx._1 = _1 & LHS tokens = [_1]
>> Text rule _1 |-->resx._1 = _1 & RHS = resx._1 = _1 &
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : int |-->resx._1 = _1 & <action> _1 int LHS variables = [_1]
>> Text rule _1 : int |-->resx._1 = _1 & <action> _1 int LHS tokens = [_1, :, int]
>> Text rule _1 : int |-->resx._1 = _1 & <action> _1 int RHS = resx._1 = _1 & <action> _1 int
+++ Action lexicals:: [_1, int]
>> Rule actions are:  _1 int [_1 int]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : bool |-->resx._1 = _1 & <action> _1 boolean LHS variables = [_1]
>> Text rule _1 : bool |-->resx._1 = _1 & <action> _1 boolean LHS tokens = [_1, :, bool]
>> Text rule _1 : bool |-->resx._1 = _1 & <action> _1 boolean RHS = resx._1 = _1 & <action> _1 boolean
+++ Action lexicals:: [_1, boolean]
>> Rule actions are:  _1 boolean [_1 boolean]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : float |-->resx._1 = _1 & <action> _1 real LHS variables = [_1]
>> Text rule _1 : float |-->resx._1 = _1 & <action> _1 real LHS tokens = [_1, :, float]
>> Text rule _1 : float |-->resx._1 = _1 & <action> _1 real RHS = resx._1 = _1 & <action> _1 real
+++ Action lexicals:: [_1, real]
>> Rule actions are:  _1 real [_1 real]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : dict |-->resx._1 = _1 & <action> _1 Map LHS variables = [_1]
>> Text rule _1 : dict |-->resx._1 = _1 & <action> _1 Map LHS tokens = [_1, :, dict]
>> Text rule _1 : dict |-->resx._1 = _1 & <action> _1 Map RHS = resx._1 = _1 & <action> _1 Map
+++ Action lexicals:: [_1, Map]
>> Rule actions are:  _1 Map [_1 Map]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : str |-->resx._1 = _1 & <action> _1 String LHS variables = [_1]
>> Text rule _1 : str |-->resx._1 = _1 & <action> _1 String LHS tokens = [_1, :, str]
>> Text rule _1 : str |-->resx._1 = _1 & <action> _1 String RHS = resx._1 = _1 & <action> _1 String
+++ Action lexicals:: [_1, String]
>> Rule actions are:  _1 String [_1 String]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : list |-->resx._1 = _1 & <action> _1 Sequence LHS variables = [_1]
>> Text rule _1 : list |-->resx._1 = _1 & <action> _1 Sequence LHS tokens = [_1, :, list]
>> Text rule _1 : list |-->resx._1 = _1 & <action> _1 Sequence RHS = resx._1 = _1 & <action> _1 Sequence
+++ Action lexicals:: [_1, Sequence]
>> Rule actions are:  _1 Sequence [_1 Sequence]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : set |-->resx._1 = _1 & <action> _1 Set LHS variables = [_1]
>> Text rule _1 : set |-->resx._1 = _1 & <action> _1 Set LHS tokens = [_1, :, set]
>> Text rule _1 : set |-->resx._1 = _1 & <action> _1 Set RHS = resx._1 = _1 & <action> _1 Set
+++ Action lexicals:: [_1, Set]
>> Rule actions are:  _1 Set [_1 Set]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->resx._1 = _1 & <action> _1 _2 LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->resx._1 = _1 & <action> _1 _2 LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->resx._1 = _1 & <action> _1 _2 RHS = resx._1 = _1 & <action> _1 _2
+++ Action lexicals:: [_1, _2]
>> Rule actions are:  _1 _2 [_1 _2]
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 : OclAny LHS variables = [_1]
>> Text rule _1 |-->_1 : OclAny LHS tokens = [_1]
>> Text rule _1 |-->_1 : OclAny RHS = _1 : OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : int |-->_1 : int<action> _1 int LHS variables = [_1]
>> Text rule _1 : int |-->_1 : int<action> _1 int LHS tokens = [_1, :, int]
>> Text rule _1 : int |-->_1 : int<action> _1 int RHS = _1 : int<action> _1 int
+++ Action lexicals:: [_1, int]
>> Rule actions are:  _1 int [_1 int]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : bool |-->_1 : boolean<action> _1 boolean LHS variables = [_1]
>> Text rule _1 : bool |-->_1 : boolean<action> _1 boolean LHS tokens = [_1, :, bool]
>> Text rule _1 : bool |-->_1 : boolean<action> _1 boolean RHS = _1 : boolean<action> _1 boolean
+++ Action lexicals:: [_1, boolean]
>> Rule actions are:  _1 boolean [_1 boolean]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : float |-->_1 : double<action> _1 real LHS variables = [_1]
>> Text rule _1 : float |-->_1 : double<action> _1 real LHS tokens = [_1, :, float]
>> Text rule _1 : float |-->_1 : double<action> _1 real RHS = _1 : double<action> _1 real
+++ Action lexicals:: [_1, real]
>> Rule actions are:  _1 real [_1 real]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : dict |-->_1 : Map(String,OclAny)<action> _1 Map LHS variables = [_1]
>> Text rule _1 : dict |-->_1 : Map(String,OclAny)<action> _1 Map LHS tokens = [_1, :, dict]
>> Text rule _1 : dict |-->_1 : Map(String,OclAny)<action> _1 Map RHS = _1 : Map(String,OclAny)<action> _1 Map
+++ Action lexicals:: [_1, Map]
>> Rule actions are:  _1 Map [_1 Map]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : str |-->_1 : String<action> _1 String LHS variables = [_1]
>> Text rule _1 : str |-->_1 : String<action> _1 String LHS tokens = [_1, :, str]
>> Text rule _1 : str |-->_1 : String<action> _1 String RHS = _1 : String<action> _1 String
+++ Action lexicals:: [_1, String]
>> Rule actions are:  _1 String [_1 String]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : list |-->_1 : Sequence(OclAny)<action> _1 Sequence LHS variables = [_1]
>> Text rule _1 : list |-->_1 : Sequence(OclAny)<action> _1 Sequence LHS tokens = [_1, :, list]
>> Text rule _1 : list |-->_1 : Sequence(OclAny)<action> _1 Sequence RHS = _1 : Sequence(OclAny)<action> _1 Sequence
+++ Action lexicals:: [_1, Sequence]
>> Rule actions are:  _1 Sequence [_1 Sequence]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : set |-->_1 : Set(OclAny)<action> _1 Set LHS variables = [_1]
>> Text rule _1 : set |-->_1 : Set(OclAny)<action> _1 Set LHS tokens = [_1, :, set]
>> Text rule _1 : set |-->_1 : Set(OclAny)<action> _1 Set RHS = _1 : Set(OclAny)<action> _1 Set
+++ Action lexicals:: [_1, Set]
>> Rule actions are:  _1 Set [_1 Set]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->_1 : _2<action> _1 _2 LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->_1 : _2<action> _1 _2 LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->_1 : _2<action> _1 _2 RHS = _1 : _2<action> _1 _2
+++ Action lexicals:: [_1, _2]
>> Rule actions are:  _1 _2 [_1 _2]
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->_1 LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->_1 LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->_1 RHS = _1
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->true<when> _1 int LHS variables = [_1]
>> Text rule . _1 |-->true<when> _1 int LHS tokens = [., _1]
>> Text rule . _1 |-->true<when> _1 int RHS = true<when> _1 int
+++ Condition lexicals:: [_1, int]
>***> Rule with condition: [_1 int]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->true<when> _1 real LHS variables = [_1]
>> Text rule . _1 |-->true<when> _1 real LHS tokens = [., _1]
>> Text rule . _1 |-->true<when> _1 real RHS = true<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->true<when> _1 String LHS variables = [_1]
>> Text rule . _1 |-->true<when> _1 String LHS tokens = [., _1]
>> Text rule . _1 |-->true<when> _1 String RHS = true<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->true<when> _1 boolean LHS variables = [_1]
>> Text rule . _1 |-->true<when> _1 boolean LHS tokens = [., _1]
>> Text rule . _1 |-->true<when> _1 boolean RHS = true<when> _1 boolean
+++ Condition lexicals:: [_1, boolean]
>***> Rule with condition: [_1 boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->false LHS variables = [_1]
>> Text rule . _1 |-->false LHS tokens = [., _1]
>> Text rule . _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`printTrailer<when> _1 trailer LHS variables = [_1]
>> Text rule _1 |-->_1`printTrailer<when> _1 trailer LHS tokens = [_1]
>> Text rule _1 |-->_1`printTrailer<when> _1 trailer RHS = _1`printTrailer<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`printTrailer for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule _1 |-->_1`printTrailer<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`printTrailer<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`printTrailer<when> _1 arguments RHS = _1`printTrailer<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`printTrailer for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule ( _1 ) |-->(_1`printTrailer) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1`printTrailer) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1`printTrailer) RHS = (_1`printTrailer)
>>> found metafeature _1`printTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule _1 _* |-->_1 LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1 LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1 RHS = _1
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _2 |-->_2`removeAtomBrackets LHS variables = [_1, _2]
>> Text rule . _1 _2 |-->_2`removeAtomBrackets LHS tokens = [., _1, _2]
>> Text rule . _1 _2 |-->_2`removeAtomBrackets RHS = _2`removeAtomBrackets
>>> found metafeature _2`removeAtomBrackets for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`removeAtomBrackets]
>> Text rule . count _1 |-->->count_1 LHS variables = [_1]
>> Text rule . count _1 |-->->count_1 LHS tokens = [., count, _1]
>> Text rule . count _1 |-->->count_1 RHS = ->count_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS variables = [_1]
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS tokens = [., index, _1]
>> Text rule . index _1 |-->->indexOf_1 - 1 RHS = ->indexOf_1 - 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->->sort() LHS variables = [_1]
>> Text rule . sort _1 |-->->sort() LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->->sort() RHS = ->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->->reverse() LHS variables = [_1]
>> Text rule . reverse _1 |-->->reverse() LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->->reverse() RHS = ->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->_1`popArguments LHS variables = [_1]
>> Text rule . pop _1 |-->_1`popArguments LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->_1`popArguments RHS = _1`popArguments
>>> found metafeature _1`popArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popArguments]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS variables = [_1]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->_1`popleftArguments RHS = _1`popleftArguments
>>> found metafeature _1`popleftArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popleftArguments]
>> Text rule . add _1 |-->->including_1 LHS variables = [_1]
>> Text rule . add _1 |-->->including_1 LHS tokens = [., add, _1]
>> Text rule . add _1 |-->->including_1 RHS = ->including_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->->copy() LHS variables = [_1]
>> Text rule . copy _1 |-->->copy() LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->->copy() RHS = ->copy()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection _1 |-->->intersection_1 LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection_update _1 |-->->intersection_1 LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference _1 |--> - _1 LHS tokens = [., difference, _1]
>> Text rule . difference _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference_update _1 |--> - _1 LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->->excludesAll_1 LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->->excludesAll_1 LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->->excludesAll_1 RHS = ->excludesAll_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |--> <: _1 LHS variables = [_1]
>> Text rule . issubset _1 |--> <: _1 LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |--> <: _1 RHS =  <: _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->->includesAll_1 LHS variables = [_1]
>> Text rule . issuperset _1 |-->->includesAll_1 LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->->includesAll_1 RHS = ->includesAll_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 RHS = ->symmetricDifference_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->_1`allUnion LHS variables = [_1]
>> Text rule . update _1 |-->_1`allUnion LHS tokens = [., update, _1]
>> Text rule . update _1 |-->_1`allUnion RHS = _1`allUnion
>>> found metafeature _1`allUnion for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`allUnion]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS variables = [_1]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->->excludingFirst_1 RHS = ->excludingFirst_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->->excluding_1 LHS variables = [_1]
>> Text rule . discard _1 |-->->excluding_1 LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->->excluding_1 RHS = ->excluding_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->->intersection(Set{}) LHS variables = [_1]
>> Text rule . clear _1 |-->->intersection(Set{}) LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->->intersection(Set{}) RHS = ->intersection(Set{})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS variables = [_1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS tokens = [., items, _1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) RHS = ->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . upper _1 |-->->toUpperCase() LHS variables = [_1]
>> Text rule . upper _1 |-->->toUpperCase() LHS tokens = [., upper, _1]
>> Text rule . upper _1 |-->->toUpperCase() RHS = ->toUpperCase()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . lower _1 |-->->toLowerCase() LHS variables = [_1]
>> Text rule . lower _1 |-->->toLowerCase() LHS tokens = [., lower, _1]
>> Text rule . lower _1 |-->->toLowerCase() RHS = ->toLowerCase()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . strip _1 |-->->trim() LHS variables = [_1]
>> Text rule . strip _1 |-->->trim() LHS tokens = [., strip, _1]
>> Text rule . strip _1 |-->->trim() RHS = ->trim()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . split _1 |-->->split_1 LHS variables = [_1]
>> Text rule . split _1 |-->->split_1 LHS tokens = [., split, _1]
>> Text rule . split _1 |-->->split_1 RHS = ->split_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . replace _1 |-->.replace_1 LHS variables = [_1]
>> Text rule . replace _1 |-->.replace_1 LHS tokens = [., replace, _1]
>> Text rule . replace _1 |-->.replace_1 RHS = .replace_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . find _1 |-->_1`findQualifier->indexOf(_1`firstArg) - 1 LHS variables = [_1]
>> Text rule . find _1 |-->_1`findQualifier->indexOf(_1`firstArg) - 1 LHS tokens = [., find, _1]
>> Text rule . find _1 |-->_1`findQualifier->indexOf(_1`firstArg) - 1 RHS = _1`findQualifier->indexOf(_1`firstArg) - 1
>>> found metafeature _1`findQualifier for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`findQualifier, _1`firstArg]
>> Text rule . startswith _1 |-->->hasPrefix_1 LHS variables = [_1]
>> Text rule . startswith _1 |-->->hasPrefix_1 LHS tokens = [., startswith, _1]
>> Text rule . startswith _1 |-->->hasPrefix_1 RHS = ->hasPrefix_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . endswith _1 |-->->hasSuffix_1 LHS variables = [_1]
>> Text rule . endswith _1 |-->->hasSuffix_1 LHS tokens = [., endswith, _1]
>> Text rule . endswith _1 |-->->hasSuffix_1 RHS = ->hasSuffix_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isalpha _1 |-->->matches("[a-zA-Z]*") LHS variables = [_1]
>> Text rule . isalpha _1 |-->->matches("[a-zA-Z]*") LHS tokens = [., isalpha, _1]
>> Text rule . isalpha _1 |-->->matches("[a-zA-Z]*") RHS = ->matches("[a-zA-Z]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isnumeric _1 |-->->matches("[0-9]*") LHS variables = [_1]
>> Text rule . isnumeric _1 |-->->matches("[0-9]*") LHS tokens = [., isnumeric, _1]
>> Text rule . isnumeric _1 |-->->matches("[0-9]*") RHS = ->matches("[0-9]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isalnum _1 |-->->matches("[a-zA-Z0-9]*") LHS variables = [_1]
>> Text rule . isalnum _1 |-->->matches("[a-zA-Z0-9]*") LHS tokens = [., isalnum, _1]
>> Text rule . isalnum _1 |-->->matches("[a-zA-Z0-9]*") RHS = ->matches("[a-zA-Z0-9]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . islower _1 |-->->matches("[a-z ]*") LHS variables = [_1]
>> Text rule . islower _1 |-->->matches("[a-z ]*") LHS tokens = [., islower, _1]
>> Text rule . islower _1 |-->->matches("[a-z ]*") RHS = ->matches("[a-z ]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isupper _1 |-->->matches("[A-Z ]*") LHS variables = [_1]
>> Text rule . isupper _1 |-->->matches("[A-Z ]*") LHS tokens = [., isupper, _1]
>> Text rule . isupper _1 |-->->matches("[A-Z ]*") RHS = ->matches("[A-Z ]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isspace _1 |-->->matches("[ \t\n\r]*") LHS variables = [_1]
>> Text rule . isspace _1 |-->->matches("[ \t\n\r]*") LHS tokens = [., isspace, _1]
>> Text rule . isspace _1 |-->->matches("[ \t\n\r]*") RHS = ->matches("[ \t\n\r]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdigit _1 |-->->matches("[0-9]*") LHS variables = [_1]
>> Text rule . isdigit _1 |-->->matches("[0-9]*") LHS tokens = [., isdigit, _1]
>> Text rule . isdigit _1 |-->->matches("[0-9]*") RHS = ->matches("[0-9]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdecimal _1 |-->->matches("[0-9]*") LHS variables = [_1]
>> Text rule . isdecimal _1 |-->->matches("[0-9]*") LHS tokens = [., isdecimal, _1]
>> Text rule . isdecimal _1 |-->->matches("[0-9]*") RHS = ->matches("[0-9]*")
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . readable _1 |-->.canRead() LHS variables = [_1]
>> Text rule . readable _1 |-->.canRead() LHS tokens = [., readable, _1]
>> Text rule . readable _1 |-->.canRead() RHS = .canRead()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . writable _1 |-->.canWrite() LHS variables = [_1]
>> Text rule . writable _1 |-->.canWrite() LHS tokens = [., writable, _1]
>> Text rule . writable _1 |-->.canWrite() RHS = .canWrite()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . close _1 |-->.closeFile() LHS variables = [_1]
>> Text rule . close _1 |-->.closeFile() LHS tokens = [., close, _1]
>> Text rule . close _1 |-->.closeFile() RHS = .closeFile()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read _1 |-->.readAll() LHS variables = [_1]
>> Text rule . read _1 |-->.readAll() LHS tokens = [., read, _1]
>> Text rule . read _1 |-->.readAll() RHS = .readAll()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . write _1 |-->.write_1 LHS variables = [_1]
>> Text rule . write _1 |-->.write_1 LHS tokens = [., write, _1]
>> Text rule . write _1 |-->.write_1 RHS = .write_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . seek _1 |-->.setPosition_1 LHS variables = [_1]
>> Text rule . seek _1 |-->.setPosition_1 LHS tokens = [., seek, _1]
>> Text rule . seek _1 |-->.setPosition_1 RHS = .setPosition_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tell _1 |-->.getPosition() LHS variables = [_1]
>> Text rule . tell _1 |-->.getPosition() LHS tokens = [., tell, _1]
>> Text rule . tell _1 |-->.getPosition() RHS = .getPosition()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . readline _1 |-->.readLine() LHS variables = [_1]
>> Text rule . readline _1 |-->.readLine() LHS tokens = [., readline, _1]
>> Text rule . readline _1 |-->.readLine() RHS = .readLine()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 LHS variables = [_1]
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 LHS tokens = [., sleep, _1]
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 RHS = OclProcess.sleepSeconds_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() LHS variables = [_1]
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() LHS tokens = [., create_task, _1]
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() RHS = (OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess()
>>> found metafeature _1`createTaskArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArguments]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() LHS variables = [_1]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() LHS tokens = [., run, _1]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() RHS = (OclProcess.newOclProcess(_1`createTaskArguments, "")).start()
>>> found metafeature _1`createTaskArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArguments]
>> Text rule . cursor _1 |-->.createStatement() LHS variables = [_1]
>> Text rule . cursor _1 |-->.createStatement() LHS tokens = [., cursor, _1]
>> Text rule . cursor _1 |-->.createStatement() RHS = .createStatement()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . commit _1 |-->.commit() LHS variables = [_1]
>> Text rule . commit _1 |-->.commit() LHS tokens = [., commit, _1]
>> Text rule . commit _1 |-->.commit() RHS = .commit()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . rollback _1 |-->.rollback() LHS variables = [_1]
>> Text rule . rollback _1 |-->.rollback() LHS tokens = [., rollback, _1]
>> Text rule . rollback _1 |-->.rollback() RHS = .rollback()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . execute _1 |-->.executeQuery(_1`firstArg) LHS variables = [_1]
>> Text rule . execute _1 |-->.executeQuery(_1`firstArg) LHS tokens = [., execute, _1]
>> Text rule . execute _1 |-->.executeQuery(_1`firstArg) RHS = .executeQuery(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . executemany _1 |-->.executeMany(_1`firstArg,_1`secondArg) LHS variables = [_1]
>> Text rule . executemany _1 |-->.executeMany(_1`firstArg,_1`secondArg) LHS tokens = [., executemany, _1]
>> Text rule . executemany _1 |-->.executeMany(_1`firstArg,_1`secondArg) RHS = .executeMany(_1`firstArg,_1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . fetchone _1 |-->.next() LHS variables = [_1]
>> Text rule . fetchone _1 |-->.next() LHS tokens = [., fetchone, _1]
>> Text rule . fetchone _1 |-->.next() RHS = .next()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fetchall _1 |-->.getElements() LHS variables = [_1]
>> Text rule . fetchall _1 |-->.getElements() LHS tokens = [., fetchall, _1]
>> Text rule . fetchall _1 |-->.getElements() RHS = .getElements()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . close _1 |-->.close() LHS variables = [_1]
>> Text rule . close _1 |-->.close() LHS tokens = [., close, _1]
>> Text rule . close _1 |-->.close() RHS = .close()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . deque _1 |-->_1 LHS variables = [_1]
>> Text rule . deque _1 |-->_1 LHS tokens = [., deque, _1]
>> Text rule . deque _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . OrderedDict _1 |-->_1 LHS variables = [_1]
>> Text rule . OrderedDict _1 |-->_1 LHS tokens = [., OrderedDict, _1]
>> Text rule . OrderedDict _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gauss _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) LHS variables = [_1]
>> Text rule . gauss _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) LHS tokens = [., gauss, _1]
>> Text rule . gauss _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) RHS = .nextNormal(_1`firstArg, (_1`secondArg)->sqr())
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . normalvariate _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) LHS variables = [_1]
>> Text rule . normalvariate _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) LHS tokens = [., normalvariate, _1]
>> Text rule . normalvariate _1 |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr()) RHS = .nextNormal(_1`firstArg, (_1`secondArg)->sqr())
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . standard_normal _1 |-->.nextGaussian_1 LHS variables = [_1]
>> Text rule . standard_normal _1 |-->.nextGaussian_1 LHS tokens = [., standard_normal, _1]
>> Text rule . standard_normal _1 |-->.nextGaussian_1 RHS = .nextGaussian_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . uniform _1 |-->.nextUniform_1 LHS variables = [_1]
>> Text rule . uniform _1 |-->.nextUniform_1 LHS tokens = [., uniform, _1]
>> Text rule . uniform _1 |-->.nextUniform_1 RHS = .nextUniform_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randrange _1 |-->.nextInt_1 LHS variables = [_1]
>> Text rule . randrange _1 |-->.nextInt_1 LHS tokens = [., randrange, _1]
>> Text rule . randrange _1 |-->.nextInt_1 RHS = .nextInt_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . random _1 |-->.nextDouble() LHS variables = [_1]
>> Text rule . random _1 |-->.nextDouble() LHS tokens = [., random, _1]
>> Text rule . random _1 |-->.nextDouble() RHS = .nextDouble()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randint _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg LHS variables = [_1]
>> Text rule . randint _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg LHS tokens = [., randint, _1]
>> Text rule . randint _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg RHS = .nextInt(_1`lastArg - _1`firstArg) + _1`firstArg
>>> found metafeature _1`lastArg for _1`
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`lastArg, _1`firstArg]
>> Text rule . integers _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg LHS variables = [_1]
>> Text rule . integers _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg LHS tokens = [., integers, _1]
>> Text rule . integers _1 |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg RHS = .nextInt(_1`lastArg - _1`firstArg) + _1`firstArg
>>> found metafeature _1`lastArg for _1`
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`lastArg, _1`firstArg]
>> Text rule . seed _1 |-->.setSeed_1 LHS variables = [_1]
>> Text rule . seed _1 |-->.setSeed_1 LHS tokens = [., seed, _1]
>> Text rule . seed _1 |-->.setSeed_1 RHS = .setSeed_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->->max() LHS variables = [_1]
>> Text rule . max _1 |-->->max() LHS tokens = [., max, _1]
>> Text rule . max _1 |-->->max() RHS = ->max()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->->min() LHS variables = [_1]
>> Text rule . min _1 |-->->min() LHS tokens = [., min, _1]
>> Text rule . min _1 |-->->min() RHS = ->min()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS variables = [_1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS tokens = [., head, _1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) RHS = ->collect( _ser | _ser.subrange(1,_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS variables = [_1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS tokens = [., tail, _1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) RHS = ->collect( _ser | _ser.subrange(_1, _ser->size()))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->_1`reversedAccess LHS variables = [_1]
>> Text rule . at _1 |-->_1`reversedAccess LHS tokens = [., at, _1]
>> Text rule . at _1 |-->_1`reversedAccess RHS = _1`reversedAccess
>>> found metafeature _1`reversedAccess for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reversedAccess]
>> Text rule . day |-->.getDate() LHS variables = []
>> Text rule . day |-->.getDate() LHS tokens = [., day]
>> Text rule . day |-->.getDate() RHS = .getDate()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . year |-->.getYear() LHS variables = []
>> Text rule . year |-->.getYear() LHS tokens = [., year]
>> Text rule . year |-->.getYear() RHS = .getYear()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . month |-->.getMonth() LHS variables = []
>> Text rule . month |-->.getMonth() LHS tokens = [., month]
>> Text rule . month |-->.getMonth() RHS = .getMonth()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . hour |-->.getHours() LHS variables = []
>> Text rule . hour |-->.getHours() LHS tokens = [., hour]
>> Text rule . hour |-->.getHours() RHS = .getHours()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . minute |-->.getMinutes() LHS variables = []
>> Text rule . minute |-->.getMinutes() LHS tokens = [., minute]
>> Text rule . minute |-->.getMinutes() RHS = .getMinutes()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . second |-->.getSeconds() LHS variables = []
>> Text rule . second |-->.getSeconds() LHS tokens = [., second]
>> Text rule . second |-->.getSeconds() RHS = .getSeconds()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . maxlen |-->->size() LHS variables = []
>> Text rule . maxlen |-->->size() LHS tokens = [., maxlen]
>> Text rule . maxlen |-->->size() RHS = ->size()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . _1 |-->._1 LHS variables = [_1]
>> Text rule . _1 |-->._1 LHS tokens = [., _1]
>> Text rule . _1 |-->._1 RHS = ._1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->._1_* LHS variables = [_1, _*]
>> Text rule . _1 _* |-->._1_* LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->._1_* RHS = ._1_*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`findQualifier<when> _1 arglist LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`findQualifier<when> _1 arglist LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`findQualifier<when> _1 arglist RHS = _1`findQualifier<when> _1 arglist
+++ Condition lexicals:: [_1, arglist]
>>> found metafeature _1`findQualifier for _1`
>***> Rule with condition: [_1 arglist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`findQualifier]
>> Text rule _1 , _2 |-->.substring(_2) LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->.substring(_2) LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->.substring(_2) RHS = .substring(_2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , _3 |-->.substring(_2,_3) LHS variables = [_1, _2, _3]
>> Text rule _1 , _2 , _3 |-->.substring(_2,_3) LHS tokens = [_1, ,, _2, ,, _3]
>> Text rule _1 , _2 , _3 |-->.substring(_2,_3) RHS = .substring(_2,_3)
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . count _1 |-->->count_1 LHS variables = [_1]
>> Text rule . count _1 |-->->count_1 LHS tokens = [., count, _1]
>> Text rule . count _1 |-->->count_1 RHS = ->count_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS variables = [_1]
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS tokens = [., index, _1]
>> Text rule . index _1 |-->->indexOf_1 - 1 RHS = ->indexOf_1 - 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->->sort() LHS variables = [_1]
>> Text rule . sort _1 |-->->sort() LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->->sort() RHS = ->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->->reverse() LHS variables = [_1]
>> Text rule . reverse _1 |-->->reverse() LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->->reverse() RHS = ->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->_1`popArguments LHS variables = [_1]
>> Text rule . pop _1 |-->_1`popArguments LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->_1`popArguments RHS = _1`popArguments
>>> found metafeature _1`popArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popArguments]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS variables = [_1]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->_1`popleftArguments RHS = _1`popleftArguments
>>> found metafeature _1`popleftArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popleftArguments]
>> Text rule . add _1 |-->->including_1 LHS variables = [_1]
>> Text rule . add _1 |-->->including_1 LHS tokens = [., add, _1]
>> Text rule . add _1 |-->->including_1 RHS = ->including_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->->copy() LHS variables = [_1]
>> Text rule . copy _1 |-->->copy() LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->->copy() RHS = ->copy()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection _1 |-->->intersection_1 LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection_update _1 |-->->intersection_1 LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference _1 |--> - _1 LHS tokens = [., difference, _1]
>> Text rule . difference _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference_update _1 |--> - _1 LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() RHS = ->intersection_1->isEmpty()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |--> <: _1 LHS variables = [_1]
>> Text rule . issubset _1 |--> <: _1 LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |--> <: _1 RHS =  <: _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->->includesAll_1 LHS variables = [_1]
>> Text rule . issuperset _1 |-->->includesAll_1 LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->->includesAll_1 RHS = ->includesAll_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 RHS = ->symmetricDifference_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->_1`allUnion LHS variables = [_1]
>> Text rule . update _1 |-->_1`allUnion LHS tokens = [., update, _1]
>> Text rule . update _1 |-->_1`allUnion RHS = _1`allUnion
>>> found metafeature _1`allUnion for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`allUnion]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS variables = [_1]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->->excludingFirst_1 RHS = ->excludingFirst_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->->excluding_1 LHS variables = [_1]
>> Text rule . discard _1 |-->->excluding_1 LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->->excluding_1 RHS = ->excluding_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->->intersection(Set{}) LHS variables = [_1]
>> Text rule . clear _1 |-->->intersection(Set{}) LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->->intersection(Set{}) RHS = ->intersection(Set{})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS variables = [_1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS tokens = [., items, _1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) RHS = ->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->->max() LHS variables = [_1]
>> Text rule . max _1 |-->->max() LHS tokens = [., max, _1]
>> Text rule . max _1 |-->->max() RHS = ->max()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->->min() LHS variables = [_1]
>> Text rule . min _1 |-->->min() LHS tokens = [., min, _1]
>> Text rule . min _1 |-->->min() RHS = ->min()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS variables = [_1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS tokens = [., head, _1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) RHS = ->collect( _ser | _ser.subrange(1,_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS variables = [_1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS tokens = [., tail, _1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) RHS = ->collect( _ser | _ser.subrange(_1, _ser->size()))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->_1`reversedAccess LHS variables = [_1]
>> Text rule . at _1 |-->_1`reversedAccess LHS tokens = [., at, _1]
>> Text rule . at _1 |-->_1`reversedAccess RHS = _1`reversedAccess
>>> found metafeature _1`reversedAccess for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reversedAccess]
>> Text rule . maxlen |-->->size() LHS variables = []
>> Text rule . maxlen |-->->size() LHS tokens = [., maxlen]
>> Text rule . maxlen |-->->size() RHS = ->size()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . _1 |-->._1 LHS variables = [_1]
>> Text rule . _1 |-->._1 LHS tokens = [., _1]
>> Text rule . _1 |-->._1 RHS = ._1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->._1_* LHS variables = [_1, _*]
>> Text rule . _1 _* |-->._1_* LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->._1_* RHS = ._1_*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`mapArgumentsQueryForm<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`mapArgumentsQueryForm<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`mapArgumentsQueryForm<when> _1 arguments RHS = _1`mapArgumentsQueryForm<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`mapArgumentsQueryForm for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`mapArgumentsQueryForm]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . count _1 |-->int LHS variables = [_1]
>> Text rule . count _1 |-->int LHS tokens = [., count, _1]
>> Text rule . count _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->int LHS variables = [_1]
>> Text rule . index _1 |-->int LHS tokens = [., index, _1]
>> Text rule . index _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->Map LHS variables = [_1]
>> Text rule . sort _1 |-->Map LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->Map LHS variables = [_1]
>> Text rule . reverse _1 |-->Map LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . add _1 |-->Map LHS variables = [_1]
>> Text rule . add _1 |-->Map LHS tokens = [., add, _1]
>> Text rule . add _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->Map LHS variables = [_1]
>> Text rule . copy _1 |-->Map LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->Map LHS variables = [_1]
>> Text rule . intersection _1 |-->Map LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->Map LHS variables = [_1]
>> Text rule . intersection_update _1 |-->Map LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |-->Map LHS variables = [_1]
>> Text rule . difference _1 |-->Map LHS tokens = [., difference, _1]
>> Text rule . difference _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |-->Map LHS variables = [_1]
>> Text rule . difference_update _1 |-->Map LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->boolean LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->boolean LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |-->boolean LHS variables = [_1]
>> Text rule . issubset _1 |-->boolean LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->boolean LHS variables = [_1]
>> Text rule . issuperset _1 |-->boolean LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->Map LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->Map LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->Map LHS variables = [_1]
>> Text rule . update _1 |-->Map LHS tokens = [., update, _1]
>> Text rule . update _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . remove _1 |-->Map LHS variables = [_1]
>> Text rule . remove _1 |-->Map LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->Map LHS variables = [_1]
>> Text rule . discard _1 |-->Map LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->Map LHS variables = [_1]
>> Text rule . clear _1 |-->Map LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->Sequence LHS variables = [_1]
>> Text rule . items _1 |-->Sequence LHS tokens = [., items, _1]
>> Text rule . items _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->OclAny LHS variables = [_1]
>> Text rule . max _1 |-->OclAny LHS tokens = [., max, _1]
>> Text rule . max _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->OclAny LHS variables = [_1]
>> Text rule . min _1 |-->OclAny LHS tokens = [., min, _1]
>> Text rule . min _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->Map LHS variables = [_1]
>> Text rule . head _1 |-->Map LHS tokens = [., head, _1]
>> Text rule . head _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |--> LHS variables = [_1]
>> Text rule . tail _1 |--> LHS tokens = [., tail, _1]
>> Text rule . tail _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->OclAny LHS variables = [_1]
>> Text rule . at _1 |-->OclAny LHS tokens = [., at, _1]
>> Text rule . at _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . maxlen |-->int LHS variables = []
>> Text rule . maxlen |-->int LHS tokens = [., maxlen]
>> Text rule . maxlen |-->int RHS = int
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->OclAny LHS variables = [_1, _*]
>> Text rule . _1 _* |-->OclAny LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`mapArgumentsType<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`mapArgumentsType<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`mapArgumentsType<when> _1 arguments RHS = _1`mapArgumentsType<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`mapArgumentsType for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`mapArgumentsType]
>> Text rule _1 |-->_1`ocltype LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule . count _1 |-->->count_1 LHS variables = [_1]
>> Text rule . count _1 |-->->count_1 LHS tokens = [., count, _1]
>> Text rule . count _1 |-->->count_1 RHS = ->count_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS variables = [_1]
>> Text rule . index _1 |-->->indexOf_1 - 1 LHS tokens = [., index, _1]
>> Text rule . index _1 |-->->indexOf_1 - 1 RHS = ->indexOf_1 - 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->->sort() LHS variables = [_1]
>> Text rule . sort _1 |-->->sort() LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->->sort() RHS = ->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->->reverse() LHS variables = [_1]
>> Text rule . reverse _1 |-->->reverse() LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->->reverse() RHS = ->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->_1`popArguments LHS variables = [_1]
>> Text rule . pop _1 |-->_1`popArguments LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->_1`popArguments RHS = _1`popArguments
>>> found metafeature _1`popArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popArguments]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS variables = [_1]
>> Text rule . popleft _1 |-->_1`popleftArguments LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->_1`popleftArguments RHS = _1`popleftArguments
>>> found metafeature _1`popleftArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popleftArguments]
>> Text rule . add _1 |-->->including_1 LHS variables = [_1]
>> Text rule . add _1 |-->->including_1 LHS tokens = [., add, _1]
>> Text rule . add _1 |-->->including_1 RHS = ->including_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->->copy() LHS variables = [_1]
>> Text rule . copy _1 |-->->copy() LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->->copy() RHS = ->copy()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection _1 |-->->intersection_1 LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection_update _1 |-->->intersection_1 LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference _1 |--> - _1 LHS tokens = [., difference, _1]
>> Text rule . difference _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference_update _1 |--> - _1 LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->->intersection_1->isEmpty() RHS = ->intersection_1->isEmpty()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |--> <: _1 LHS variables = [_1]
>> Text rule . issubset _1 |--> <: _1 LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |--> <: _1 RHS =  <: _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->->includesAll_1 LHS variables = [_1]
>> Text rule . issuperset _1 |-->->includesAll_1 LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->->includesAll_1 RHS = ->includesAll_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 RHS = ->symmetricDifference_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->_1`allUnion LHS variables = [_1]
>> Text rule . update _1 |-->_1`allUnion LHS tokens = [., update, _1]
>> Text rule . update _1 |-->_1`allUnion RHS = _1`allUnion
>>> found metafeature _1`allUnion for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`allUnion]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS variables = [_1]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->->excludingFirst_1 RHS = ->excludingFirst_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->->excluding_1 LHS variables = [_1]
>> Text rule . discard _1 |-->->excluding_1 LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->->excluding_1 RHS = ->excluding_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->->intersection(Set{}) LHS variables = [_1]
>> Text rule . clear _1 |-->->intersection(Set{}) LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->->intersection(Set{}) RHS = ->intersection(Set{})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS variables = [_1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) LHS tokens = [., items, _1]
>> Text rule . items _1 |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()}) RHS = ->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->->max() LHS variables = [_1]
>> Text rule . max _1 |-->->max() LHS tokens = [., max, _1]
>> Text rule . max _1 |-->->max() RHS = ->max()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->->min() LHS variables = [_1]
>> Text rule . min _1 |-->->min() LHS tokens = [., min, _1]
>> Text rule . min _1 |-->->min() RHS = ->min()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS variables = [_1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) LHS tokens = [., head, _1]
>> Text rule . head _1 |-->->collect( _ser | _ser.subrange(1,_1)) RHS = ->collect( _ser | _ser.subrange(1,_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS variables = [_1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) LHS tokens = [., tail, _1]
>> Text rule . tail _1 |-->->collect( _ser | _ser.subrange(_1, _ser->size())) RHS = ->collect( _ser | _ser.subrange(_1, _ser->size()))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->_1`reversedAccess LHS variables = [_1]
>> Text rule . at _1 |-->_1`reversedAccess LHS tokens = [., at, _1]
>> Text rule . at _1 |-->_1`reversedAccess RHS = _1`reversedAccess
>>> found metafeature _1`reversedAccess for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reversedAccess]
>> Text rule . maxlen |-->->size() LHS variables = []
>> Text rule . maxlen |-->->size() LHS tokens = [., maxlen]
>> Text rule . maxlen |-->->size() RHS = ->size()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . _1 |-->._1 LHS variables = [_1]
>> Text rule . _1 |-->._1 LHS tokens = [., _1]
>> Text rule . _1 |-->._1 RHS = ._1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->._1_* LHS variables = [_1, _*]
>> Text rule . _1 _* |-->._1_* LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->._1_* RHS = ._1_*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`sequenceArgumentsQueryForm<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`sequenceArgumentsQueryForm<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`sequenceArgumentsQueryForm<when> _1 arguments RHS = _1`sequenceArgumentsQueryForm<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`sequenceArgumentsQueryForm for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sequenceArgumentsQueryForm]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . count _1 |-->int LHS variables = [_1]
>> Text rule . count _1 |-->int LHS tokens = [., count, _1]
>> Text rule . count _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->int LHS variables = [_1]
>> Text rule . index _1 |-->int LHS tokens = [., index, _1]
>> Text rule . index _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->Sequence LHS variables = [_1]
>> Text rule . sort _1 |-->Sequence LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->Sequence LHS variables = [_1]
>> Text rule . reverse _1 |-->Sequence LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->OclAny LHS variables = [_1]
>> Text rule . pop _1 |-->OclAny LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . popleft _1 |-->OclAny LHS variables = [_1]
>> Text rule . popleft _1 |-->OclAny LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . add _1 |-->Sequence LHS variables = [_1]
>> Text rule . add _1 |-->Sequence LHS tokens = [., add, _1]
>> Text rule . add _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->Sequence LHS variables = [_1]
>> Text rule . copy _1 |-->Sequence LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->Sequence LHS variables = [_1]
>> Text rule . intersection _1 |-->Sequence LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->Sequence LHS variables = [_1]
>> Text rule . intersection_update _1 |-->Sequence LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |-->Sequence LHS variables = [_1]
>> Text rule . difference _1 |-->Sequence LHS tokens = [., difference, _1]
>> Text rule . difference _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |-->Sequence LHS variables = [_1]
>> Text rule . difference_update _1 |-->Sequence LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->boolean LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->boolean LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |-->boolean LHS variables = [_1]
>> Text rule . issubset _1 |-->boolean LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->boolean LHS variables = [_1]
>> Text rule . issuperset _1 |-->boolean LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->Sequence LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->Sequence LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->Sequence LHS variables = [_1]
>> Text rule . update _1 |-->Sequence LHS tokens = [., update, _1]
>> Text rule . update _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . remove _1 |-->Sequence LHS variables = [_1]
>> Text rule . remove _1 |-->Sequence LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->Sequence LHS variables = [_1]
>> Text rule . discard _1 |-->Sequence LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->Sequence LHS variables = [_1]
>> Text rule . clear _1 |-->Sequence LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->Sequence LHS variables = [_1]
>> Text rule . items _1 |-->Sequence LHS tokens = [., items, _1]
>> Text rule . items _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->OclAny LHS variables = [_1]
>> Text rule . max _1 |-->OclAny LHS tokens = [., max, _1]
>> Text rule . max _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->OclAny LHS variables = [_1]
>> Text rule . min _1 |-->OclAny LHS tokens = [., min, _1]
>> Text rule . min _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->Sequence LHS variables = [_1]
>> Text rule . head _1 |-->Sequence LHS tokens = [., head, _1]
>> Text rule . head _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |-->Sequence LHS variables = [_1]
>> Text rule . tail _1 |-->Sequence LHS tokens = [., tail, _1]
>> Text rule . tail _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->OclAny LHS variables = [_1]
>> Text rule . at _1 |-->OclAny LHS tokens = [., at, _1]
>> Text rule . at _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . maxlen |-->int LHS variables = []
>> Text rule . maxlen |-->int LHS tokens = [., maxlen]
>> Text rule . maxlen |-->int RHS = int
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->OclAny LHS variables = [_1, _*]
>> Text rule . _1 _* |-->OclAny LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`sequenceArgumentsType<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`sequenceArgumentsType<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`sequenceArgumentsType<when> _1 arguments RHS = _1`sequenceArgumentsType<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`sequenceArgumentsType for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sequenceArgumentsType]
>> Text rule _1 |-->_1`ocltype LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 LHS variables = [_1]
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 LHS tokens = [., sleep, _1]
>> Text rule . sleep _1 |-->OclProcess.sleepSeconds_1 RHS = OclProcess.sleepSeconds_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() LHS variables = [_1]
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() LHS tokens = [., create_task, _1]
>> Text rule . create_task _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess() RHS = (OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess()
>>> found metafeature _1`createTaskArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArguments]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() LHS variables = [_1]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() LHS tokens = [., run, _1]
>> Text rule . run _1 |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start() RHS = (OclProcess.newOclProcess(_1`createTaskArguments, "")).start()
>>> found metafeature _1`createTaskArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArguments]
>> Text rule . _1 |-->0 LHS variables = [_1]
>> Text rule . _1 |-->0 LHS tokens = [., _1]
>> Text rule . _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->0 LHS variables = [_1, _*]
>> Text rule . _1 _* |-->0 LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->0 RHS = 0
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`numberOfArguments<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 testlist RHS = _1`numberOfArguments<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 test RHS = _1`numberOfArguments<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 logical_test RHS = _1`numberOfArguments<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 comparison RHS = _1`numberOfArguments<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 expr RHS = _1`numberOfArguments<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 trailer LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 trailer LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 trailer RHS = _1`numberOfArguments<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`numberOfArguments<when> _1 arguments RHS = _1`numberOfArguments<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`numberOfArguments for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberOfArguments]
>> Text rule _1 |-->0<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->0<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->0<when> _1 atom RHS = 0<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->0 LHS variables = [_1]
>> Text rule print _1 |-->0 LHS tokens = [print, _1]
>> Text rule print _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule del _1 |-->0 LHS variables = [_1]
>> Text rule del _1 |-->0 LHS tokens = [del, _1]
>> Text rule del _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule dict _1 |-->0 LHS variables = [_1]
>> Text rule dict _1 |-->0 LHS tokens = [dict, _1]
>> Text rule dict _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->0 LHS variables = []
>> Text rule ( ) |-->0 LHS tokens = [(, )]
>> Text rule ( ) |-->0 RHS = 0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`arity<when> _1 multiple LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`arity<when> _1 multiple LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`arity<when> _1 multiple RHS = _1`arity<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`arity for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`arity]
>> Text rule ( _1 ) |-->1 LHS variables = [_1]
>> Text rule ( _1 ) |-->1 LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->1 RHS = 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->0 LHS variables = []
>> Text rule [ ] |-->0 LHS tokens = [[, ]]
>> Text rule [ ] |-->0 RHS = 0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->0 LHS variables = [_1]
>> Text rule [ _1 ] |-->0 LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule { _1 } |-->0 LHS variables = [_1]
>> Text rule { _1 } |-->0 LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ` _1 ` |-->0 LHS variables = [_1]
>> Text rule ` _1 ` |-->0 LHS tokens = [`, _1, `]
>> Text rule ` _1 ` |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule - _1 |-->0 LHS variables = [_1]
>> Text rule - _1 |-->0 LHS tokens = [-, _1]
>> Text rule - _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule None |-->0 LHS variables = []
>> Text rule None |-->0 LHS tokens = [None]
>> Text rule None |-->0 RHS = 0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ... |-->0 LHS variables = []
>> Text rule ... |-->0 LHS tokens = [...]
>> Text rule ... |-->0 RHS = 0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->0 LHS variables = [_1]
>> Text rule _1 |-->0 LHS tokens = [_1]
>> Text rule _1 |-->0 RHS = 0
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->0 LHS variables = [_*]
>> Text rule _* |-->0 LHS tokens = [_*]
>> Text rule _* |-->0 RHS = 0
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`argCount<when> _1 trailer LHS variables = [_1]
>> Text rule _1 |-->_1`argCount<when> _1 trailer LHS tokens = [_1]
>> Text rule _1 |-->_1`argCount<when> _1 trailer RHS = _1`argCount<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`argCount for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argCount]
>> Text rule _1 |-->_1`argCount<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`argCount<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`argCount<when> _1 arguments RHS = _1`argCount<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`argCount for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argCount]
>> Text rule ( ) |-->0 LHS variables = []
>> Text rule ( ) |-->0 LHS tokens = [(, )]
>> Text rule ( ) |-->0 RHS = 0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`argsCount<when> _1 arglist LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`argsCount<when> _1 arglist LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`argsCount<when> _1 arglist RHS = _1`argsCount<when> _1 arglist
+++ Condition lexicals:: [_1, arglist]
>>> found metafeature _1`argsCount for _1`
>***> Rule with condition: [_1 arglist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argsCount]
>> Text rule ( _1 ) |-->1 LHS variables = [_1]
>> Text rule ( _1 ) |-->1 LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->1 RHS = 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , _3 , _4 , _5 |-->9 LHS variables = [_1, _2, _3, _4, _5]
>> Text rule _1 , _2 , _3 , _4 , _5 |-->9 LHS tokens = [_1, ,, _2, ,, _3, ,, _4, ,, _5]
>> Text rule _1 , _2 , _3 , _4 , _5 |-->9 RHS = 9
>***> Rule variables are: [_1, _2, _3, _4, _5]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , _3 , _4 |-->7 LHS variables = [_1, _2, _3, _4]
>> Text rule _1 , _2 , _3 , _4 |-->7 LHS tokens = [_1, ,, _2, ,, _3, ,, _4]
>> Text rule _1 , _2 , _3 , _4 |-->7 RHS = 7
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , _3 |-->5 LHS variables = [_1, _2, _3]
>> Text rule _1 , _2 , _3 |-->5 LHS tokens = [_1, ,, _2, ,, _3]
>> Text rule _1 , _2 , _3 |-->5 RHS = 5
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 |-->3 LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->3 LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->3 RHS = 3
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->1 LHS variables = [_1]
>> Text rule _1 |-->1 LHS tokens = [_1]
>> Text rule _1 |-->1 RHS = 1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`argList<when> _1 trailer LHS variables = [_1]
>> Text rule _1 |-->_1`argList<when> _1 trailer LHS tokens = [_1]
>> Text rule _1 |-->_1`argList<when> _1 trailer RHS = _1`argList<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`argList for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argList]
>> Text rule _1 |-->_1`argList<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`argList<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`argList<when> _1 arguments RHS = _1`argList<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`argList for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argList]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1 LHS variables = [_1]
>> Text rule ( _1 ) |-->_1 LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . connect _1 |-->OclDatasource.getConnection(_1`firstArg, "", "") LHS variables = [_1]
>> Text rule . connect _1 |-->OclDatasource.getConnection(_1`firstArg, "", "") LHS tokens = [., connect, _1]
>> Text rule . connect _1 |-->OclDatasource.getConnection(_1`firstArg, "", "") RHS = OclDatasource.getConnection(_1`firstArg, "", "")
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . complete_statement _1 |-->SQLStatement.isValidSQL(_1`firstArg) LHS variables = [_1]
>> Text rule . complete_statement _1 |-->SQLStatement.isValidSQL(_1`firstArg) LHS tokens = [., complete_statement, _1]
>> Text rule . complete_statement _1 |-->SQLStatement.isValidSQL(_1`firstArg) RHS = SQLStatement.isValidSQL(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . enable_callback_tracebacks _1 |--> LHS variables = [_1]
>> Text rule . enable_callback_tracebacks _1 |--> LHS tokens = [., enable_callback_tracebacks, _1]
>> Text rule . enable_callback_tracebacks _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . register_adapter _1 |--> LHS variables = [_1]
>> Text rule . register_adapter _1 |--> LHS tokens = [., register_adapter, _1]
>> Text rule . register_adapter _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . register_converter _1 |--> LHS variables = [_1]
>> Text rule . register_converter _1 |--> LHS tokens = [., register_converter, _1]
>> Text rule . register_converter _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . compile _1 |-->OclRegex.compile_1 LHS variables = [_1]
>> Text rule . compile _1 |-->OclRegex.compile_1 LHS tokens = [., compile, _1]
>> Text rule . compile _1 |-->OclRegex.compile_1 RHS = OclRegex.compile_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . search _1 |-->(_1`secondArg)->firstMatch(_1`firstArg) LHS variables = [_1]
>> Text rule . search _1 |-->(_1`secondArg)->firstMatch(_1`firstArg) LHS tokens = [., search, _1]
>> Text rule . search _1 |-->(_1`secondArg)->firstMatch(_1`firstArg) RHS = (_1`secondArg)->firstMatch(_1`firstArg)
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . match _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + ".*") LHS variables = [_1]
>> Text rule . match _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + ".*") LHS tokens = [., match, _1]
>> Text rule . match _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + ".*") RHS = (_1`secondArg)->firstMatch("^" + _1`firstArg + ".*")
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . fullmatch _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + "$") LHS variables = [_1]
>> Text rule . fullmatch _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + "$") LHS tokens = [., fullmatch, _1]
>> Text rule . fullmatch _1 |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + "$") RHS = (_1`secondArg)->firstMatch("^" + _1`firstArg + "$")
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . split _1 |-->(_1`secondArg)->split(_1`firstArg) LHS variables = [_1]
>> Text rule . split _1 |-->(_1`secondArg)->split(_1`firstArg) LHS tokens = [., split, _1]
>> Text rule . split _1 |-->(_1`secondArg)->split(_1`firstArg) RHS = (_1`secondArg)->split(_1`firstArg)
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . findall _1 |-->(_1`secondArg)->allMatches(_1`firstArg) LHS variables = [_1]
>> Text rule . findall _1 |-->(_1`secondArg)->allMatches(_1`firstArg) LHS tokens = [., findall, _1]
>> Text rule . findall _1 |-->(_1`secondArg)->allMatches(_1`firstArg) RHS = (_1`secondArg)->allMatches(_1`firstArg)
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . finditer _1 |-->OclIterator.newOclIterator_Sequence((_1`secondArg)->allMatches(_1`firstArg)) LHS variables = [_1]
>> Text rule . finditer _1 |-->OclIterator.newOclIterator_Sequence((_1`secondArg)->allMatches(_1`firstArg)) LHS tokens = [., finditer, _1]
>> Text rule . finditer _1 |-->OclIterator.newOclIterator_Sequence((_1`secondArg)->allMatches(_1`firstArg)) RHS = OclIterator.newOclIterator_Sequence((_1`secondArg)->allMatches(_1`firstArg))
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . sub _1 |-->(_1`thirdArg).replaceAllMatches(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . sub _1 |-->(_1`thirdArg).replaceAllMatches(_1`firstArg, _1`secondArg) LHS tokens = [., sub, _1]
>> Text rule . sub _1 |-->(_1`thirdArg).replaceAllMatches(_1`firstArg, _1`secondArg) RHS = (_1`thirdArg).replaceAllMatches(_1`firstArg, _1`secondArg)
>>> found metafeature _1`thirdArg for _1`
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`thirdArg, _1`firstArg, _1`secondArg]
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . compile _1 |-->OclRegex LHS variables = [_1]
>> Text rule . compile _1 |-->OclRegex LHS tokens = [., compile, _1]
>> Text rule . compile _1 |-->OclRegex RHS = OclRegex
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . search _1 |-->String LHS variables = [_1]
>> Text rule . search _1 |-->String LHS tokens = [., search, _1]
>> Text rule . search _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . match _1 |-->String LHS variables = [_1]
>> Text rule . match _1 |-->String LHS tokens = [., match, _1]
>> Text rule . match _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fullmatch _1 |-->String LHS variables = [_1]
>> Text rule . fullmatch _1 |-->String LHS tokens = [., fullmatch, _1]
>> Text rule . fullmatch _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . split _1 |-->Sequence(String) LHS variables = [_1]
>> Text rule . split _1 |-->Sequence(String) LHS tokens = [., split, _1]
>> Text rule . split _1 |-->Sequence(String) RHS = Sequence(String)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . findall _1 |-->Sequence(String) LHS variables = [_1]
>> Text rule . findall _1 |-->Sequence(String) LHS tokens = [., findall, _1]
>> Text rule . findall _1 |-->Sequence(String) RHS = Sequence(String)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . finditer _1 |-->OclIterator LHS variables = [_1]
>> Text rule . finditer _1 |-->OclIterator LHS tokens = [., finditer, _1]
>> Text rule . finditer _1 |-->OclIterator RHS = OclIterator
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sub _1 |-->String LHS variables = [_1]
>> Text rule . sub _1 |-->String LHS tokens = [., sub, _1]
>> Text rule . sub _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->OclAny LHS variables = [_1, _*]
>> Text rule . _1 _* |-->OclAny LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . exception _1 |-->OclException->allInstances()->last() LHS variables = [_1]
>> Text rule . exception _1 |-->OclException->allInstances()->last() LHS tokens = [., exception, _1]
>> Text rule . exception _1 |-->OclException->allInstances()->last() RHS = OclException->allInstances()->last()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . platform |-->OclProcess.getEnvironmentProperty("OS") LHS variables = []
>> Text rule . platform |-->OclProcess.getEnvironmentProperty("OS") LHS tokens = [., platform]
>> Text rule . platform |-->OclProcess.getEnvironmentProperty("OS") RHS = OclProcess.getEnvironmentProperty("OS")
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stdin |-->OclFile["System.in"] LHS variables = []
>> Text rule . stdin |-->OclFile["System.in"] LHS tokens = [., stdin]
>> Text rule . stdin |-->OclFile["System.in"] RHS = OclFile["System.in"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stderr |-->OclFile["System.err"] LHS variables = []
>> Text rule . stderr |-->OclFile["System.err"] LHS tokens = [., stderr]
>> Text rule . stderr |-->OclFile["System.err"] RHS = OclFile["System.err"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stdout |-->OclFile["System.out"] LHS variables = []
>> Text rule . stdout |-->OclFile["System.out"] LHS tokens = [., stdout]
>> Text rule . stdout |-->OclFile["System.out"] RHS = OclFile["System.out"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . exception _1 |-->OclException LHS variables = [_1]
>> Text rule . exception _1 |-->OclException LHS tokens = [., exception, _1]
>> Text rule . exception _1 |-->OclException RHS = OclException
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . platform |-->String LHS variables = []
>> Text rule . platform |-->String LHS tokens = [., platform]
>> Text rule . platform |-->String RHS = String
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stdin |-->OclFile LHS variables = []
>> Text rule . stdin |-->OclFile LHS tokens = [., stdin]
>> Text rule . stdin |-->OclFile RHS = OclFile
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stderr |-->OclFile LHS variables = []
>> Text rule . stderr |-->OclFile LHS tokens = [., stderr]
>> Text rule . stderr |-->OclFile RHS = OclFile
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . stdout |-->OclFile LHS variables = []
>> Text rule . stdout |-->OclFile LHS tokens = [., stdout]
>> Text rule . stdout |-->OclFile RHS = OclFile
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . Random _1 |-->OclRandom.newOclRandom() LHS variables = [_1]
>> Text rule . Random _1 |-->OclRandom.newOclRandom() LHS tokens = [., Random, _1]
>> Text rule . Random _1 |-->OclRandom.newOclRandom() RHS = OclRandom.newOclRandom()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . choice _1 |-->OclRandom.randomElement_1 LHS variables = [_1]
>> Text rule . choice _1 |-->OclRandom.randomElement_1 LHS tokens = [., choice, _1]
>> Text rule . choice _1 |-->OclRandom.randomElement_1 RHS = OclRandom.randomElement_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . choices _1 |-->OclRandom.randomElements_1 LHS variables = [_1]
>> Text rule . choices _1 |-->OclRandom.randomElements_1 LHS tokens = [., choices, _1]
>> Text rule . choices _1 |-->OclRandom.randomElements_1 RHS = OclRandom.randomElements_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gauss _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) LHS variables = [_1]
>> Text rule . gauss _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) LHS tokens = [., gauss, _1]
>> Text rule . gauss _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) RHS = (OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr())
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . normalvariate _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) LHS variables = [_1]
>> Text rule . normalvariate _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) LHS tokens = [., normalvariate, _1]
>> Text rule . normalvariate _1 |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr()) RHS = (OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr())
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . random _1 |-->(OclRandom.defaultInstanceOclRandom()).nextDouble() LHS variables = [_1]
>> Text rule . random _1 |-->(OclRandom.defaultInstanceOclRandom()).nextDouble() LHS tokens = [., random, _1]
>> Text rule . random _1 |-->(OclRandom.defaultInstanceOclRandom()).nextDouble() RHS = (OclRandom.defaultInstanceOclRandom()).nextDouble()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.defaultInstanceOclRandom()).nextInt(_1`lastArg - _1`firstArg)) LHS variables = [_1]
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.defaultInstanceOclRandom()).nextInt(_1`lastArg - _1`firstArg)) LHS tokens = [., randint, _1]
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.defaultInstanceOclRandom()).nextInt(_1`lastArg - _1`firstArg)) RHS = (_1`firstArg + (OclRandom.defaultInstanceOclRandom()).nextInt(_1`lastArg - _1`firstArg))
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . randrange _1 |-->(OclRandom.defaultInstanceOclRandom()).nextInt_1 LHS variables = [_1]
>> Text rule . randrange _1 |-->(OclRandom.defaultInstanceOclRandom()).nextInt_1 LHS tokens = [., randrange, _1]
>> Text rule . randrange _1 |-->(OclRandom.defaultInstanceOclRandom()).nextInt_1 RHS = (OclRandom.defaultInstanceOclRandom()).nextInt_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sample _1 |-->OclRandom.randomUniqueElements_1 LHS variables = [_1]
>> Text rule . sample _1 |-->OclRandom.randomUniqueElements_1 LHS tokens = [., sample, _1]
>> Text rule . sample _1 |-->OclRandom.randomUniqueElements_1 RHS = OclRandom.randomUniqueElements_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . seed _1 |-->(OclRandom.defaultInstanceOclRandom()).setSeed_1 LHS variables = [_1]
>> Text rule . seed _1 |-->(OclRandom.defaultInstanceOclRandom()).setSeed_1 LHS tokens = [., seed, _1]
>> Text rule . seed _1 |-->(OclRandom.defaultInstanceOclRandom()).setSeed_1 RHS = (OclRandom.defaultInstanceOclRandom()).setSeed_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . shuffle _1 |-->OclRandom.randomiseSequence_1 LHS variables = [_1]
>> Text rule . shuffle _1 |-->OclRandom.randomiseSequence_1 LHS tokens = [., shuffle, _1]
>> Text rule . shuffle _1 |-->OclRandom.randomiseSequence_1 RHS = OclRandom.randomiseSequence_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . uniform _1 |-->(OclRandom.defaultInstanceOclRandom()).nextUniform_1 LHS variables = [_1]
>> Text rule . uniform _1 |-->(OclRandom.defaultInstanceOclRandom()).nextUniform_1 LHS tokens = [., uniform, _1]
>> Text rule . uniform _1 |-->(OclRandom.defaultInstanceOclRandom()).nextUniform_1 RHS = (OclRandom.defaultInstanceOclRandom()).nextUniform_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read_csv _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() LHS variables = [_1]
>> Text rule . read_csv _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() LHS tokens = [., read_csv, _1]
>> Text rule . read_csv _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() RHS = OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read_json _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() LHS variables = [_1]
>> Text rule . read_json _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() LHS tokens = [., read_json, _1]
>> Text rule . read_json _1 |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap() RHS = OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . DataFrame _1 |-->_1 LHS variables = [_1]
>> Text rule . DataFrame _1 |-->_1 LHS tokens = [., DataFrame, _1]
>> Text rule . DataFrame _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . Series _1 |-->_1`first LHS variables = [_1]
>> Text rule . Series _1 |-->_1`first LHS tokens = [., Series, _1]
>> Text rule . Series _1 |-->_1`first RHS = _1`first
>>> found metafeature _1`first for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`first]
>> Text rule . inf |-->Math_PINFINITY LHS variables = []
>> Text rule . inf |-->Math_PINFINITY LHS tokens = [., inf]
>> Text rule . inf |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . Inf |-->Math_PINFINITY LHS variables = []
>> Text rule . Inf |-->Math_PINFINITY LHS tokens = [., Inf]
>> Text rule . Inf |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . Infinity |-->Math_PINFINITY LHS variables = []
>> Text rule . Infinity |-->Math_PINFINITY LHS tokens = [., Infinity]
>> Text rule . Infinity |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . infty |-->Math_PINFINITY LHS variables = []
>> Text rule . infty |-->Math_PINFINITY LHS tokens = [., infty]
>> Text rule . infty |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . PINF |-->Math_PINFINITY LHS variables = []
>> Text rule . PINF |-->Math_PINFINITY LHS tokens = [., PINF]
>> Text rule . PINF |-->Math_PINFINITY RHS = Math_PINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NINF |-->Math_NINFINITY LHS variables = []
>> Text rule . NINF |-->Math_NINFINITY LHS tokens = [., NINF]
>> Text rule . NINF |-->Math_NINFINITY RHS = Math_NINFINITY
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . nan |-->Math_NaN LHS variables = []
>> Text rule . nan |-->Math_NaN LHS tokens = [., nan]
>> Text rule . nan |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NaN |-->Math_NaN LHS variables = []
>> Text rule . NaN |-->Math_NaN LHS tokens = [., NaN]
>> Text rule . NaN |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NAN |-->Math_NaN LHS variables = []
>> Text rule . NAN |-->Math_NaN LHS tokens = [., NAN]
>> Text rule . NAN |-->Math_NaN RHS = Math_NaN
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NZERO |-->-0.0 LHS variables = []
>> Text rule . NZERO |-->-0.0 LHS tokens = [., NZERO]
>> Text rule . NZERO |-->-0.0 RHS = -0.0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . PZERO |-->0.0 LHS variables = []
>> Text rule . PZERO |-->0.0 LHS tokens = [., PZERO]
>> Text rule . PZERO |-->0.0 RHS = 0.0
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . newaxis |-->null LHS variables = []
>> Text rule . newaxis |-->null LHS tokens = [., newaxis]
>> Text rule . newaxis |-->null RHS = null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . pi |-->MathLib.piValue() LHS variables = []
>> Text rule . pi |-->MathLib.piValue() LHS tokens = [., pi]
>> Text rule . pi |-->MathLib.piValue() RHS = MathLib.piValue()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . e |-->MathLib.eValue() LHS variables = []
>> Text rule . e |-->MathLib.eValue() LHS tokens = [., e]
>> Text rule . e |-->MathLib.eValue() RHS = MathLib.eValue()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . euler_gamma |-->MathLib.gammaValue() LHS variables = []
>> Text rule . euler_gamma |-->MathLib.gammaValue() LHS tokens = [., euler_gamma]
>> Text rule . euler_gamma |-->MathLib.gammaValue() RHS = MathLib.gammaValue()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . int32 |-->OclType["int"] LHS variables = []
>> Text rule . int32 |-->OclType["int"] LHS tokens = [., int32]
>> Text rule . int32 |-->OclType["int"] RHS = OclType["int"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . int64 |-->OclType["long"] LHS variables = []
>> Text rule . int64 |-->OclType["long"] LHS tokens = [., int64]
>> Text rule . int64 |-->OclType["long"] RHS = OclType["long"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . float32 |-->OclType["double"] LHS variables = []
>> Text rule . float32 |-->OclType["double"] LHS tokens = [., float32]
>> Text rule . float32 |-->OclType["double"] RHS = OclType["double"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . float64 |-->OclType["double"] LHS variables = []
>> Text rule . float64 |-->OclType["double"] LHS tokens = [., float64]
>> Text rule . float64 |-->OclType["double"] RHS = OclType["double"]
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . arange _1 |-->MathLib.numericRange(0, _1, 1)<when> _1`argCount 1 LHS variables = [_1]
>> Text rule . arange _1 |-->MathLib.numericRange(0, _1, 1)<when> _1`argCount 1 LHS tokens = [., arange, _1]
>> Text rule . arange _1 |-->MathLib.numericRange(0, _1, 1)<when> _1`argCount 1 RHS = MathLib.numericRange(0, _1, 1)<when> _1`argCount 1
+++ Condition lexicals:: [_1, `, argCount, 1]
>***> Rule with condition: [_1`argCount 1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, 1)<when> _1`argCount 3 LHS variables = [_1]
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, 1)<when> _1`argCount 3 LHS tokens = [., arange, _1]
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, 1)<when> _1`argCount 3 RHS = MathLib.numericRange(_1`firstArg, _1`secondArg, 1)<when> _1`argCount 3
+++ Condition lexicals:: [_1, `, argCount, 3]
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule with condition: [_1`argCount 3]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, _1`thirdArg)<when> _1`argCount 5 LHS variables = [_1]
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, _1`thirdArg)<when> _1`argCount 5 LHS tokens = [., arange, _1]
>> Text rule . arange _1 |-->MathLib.numericRange(_1`firstArg, _1`secondArg, _1`thirdArg)<when> _1`argCount 5 RHS = MathLib.numericRange(_1`firstArg, _1`secondArg, _1`thirdArg)<when> _1`argCount 5
+++ Condition lexicals:: [_1, `, argCount, 5]
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`thirdArg for _1`
>***> Rule with condition: [_1`argCount 5]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg, _1`thirdArg]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, 50)<when> _1`argCount 3 LHS variables = [_1]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, 50)<when> _1`argCount 3 LHS tokens = [., linspace, _1]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, 50)<when> _1`argCount 3 RHS = MathLib.numericSeries(_1`firstArg, _1`secondArg, 50)<when> _1`argCount 3
+++ Condition lexicals:: [_1, `, argCount, 3]
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule with condition: [_1`argCount 3]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, _1`thirdArg->oclAsType(int))<when> _1`argCount 5 LHS variables = [_1]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, _1`thirdArg->oclAsType(int))<when> _1`argCount 5 LHS tokens = [., linspace, _1]
>> Text rule . linspace _1 |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, _1`thirdArg->oclAsType(int))<when> _1`argCount 5 RHS = MathLib.numericSeries(_1`firstArg, _1`secondArg, _1`thirdArg->oclAsType(int))<when> _1`argCount 5
+++ Condition lexicals:: [_1, `, argCount, 5]
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`thirdArg for _1`
>***> Rule with condition: [_1`argCount 5]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg, _1`thirdArg]
>> Text rule . matmul _1 |-->MatrixLib.matrixMultiplication(_1`firstArg,_1`secondArg) LHS variables = [_1]
>> Text rule . matmul _1 |-->MatrixLib.matrixMultiplication(_1`firstArg,_1`secondArg) LHS tokens = [., matmul, _1]
>> Text rule . matmul _1 |-->MatrixLib.matrixMultiplication(_1`firstArg,_1`secondArg) RHS = MatrixLib.matrixMultiplication(_1`firstArg,_1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . prod _1 |-->MatrixLib.prdMatrix(_1`firstArg) LHS variables = [_1]
>> Text rule . prod _1 |-->MatrixLib.prdMatrix(_1`firstArg) LHS tokens = [., prod, _1]
>> Text rule . prod _1 |-->MatrixLib.prdMatrix(_1`firstArg) RHS = MatrixLib.prdMatrix(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . sum _1 |-->MatrixLib.sumMatrix(_1`firstArg) LHS variables = [_1]
>> Text rule . sum _1 |-->MatrixLib.sumMatrix(_1`firstArg) LHS tokens = [., sum, _1]
>> Text rule . sum _1 |-->MatrixLib.sumMatrix(_1`firstArg) RHS = MatrixLib.sumMatrix(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . sort _1 |-->_1->sort() LHS variables = [_1]
>> Text rule . sort _1 |-->_1->sort() LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->_1->sort() RHS = _1->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . shape _1 |-->MatrixLib.shape_1 LHS variables = [_1]
>> Text rule . shape _1 |-->MatrixLib.shape_1 LHS tokens = [., shape, _1]
>> Text rule . shape _1 |-->MatrixLib.shape_1 RHS = MatrixLib.shape_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . array _1 |-->_1 LHS variables = [_1]
>> Text rule . array _1 |-->_1 LHS tokens = [., array, _1]
>> Text rule . array _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . concatenate _1 |-->_1->concatenateAll() LHS variables = [_1]
>> Text rule . concatenate _1 |-->_1->concatenateAll() LHS tokens = [., concatenate, _1]
>> Text rule . concatenate _1 |-->_1->concatenateAll() RHS = _1->concatenateAll()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copyto _1 |-->_1`firstArg := (_1`secondArg)->copy() LHS variables = [_1]
>> Text rule . copyto _1 |-->_1`firstArg := (_1`secondArg)->copy() LHS tokens = [., copyto, _1]
>> Text rule . copyto _1 |-->_1`firstArg := (_1`secondArg)->copy() RHS = _1`firstArg := (_1`secondArg)->copy()
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . empty _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) LHS variables = [_1]
>> Text rule . empty _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) LHS tokens = [., empty, _1]
>> Text rule . empty _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) RHS = MatrixLib.singleValueMatrix(_1`firstArg, 0.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . empty_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) LHS variables = [_1]
>> Text rule . empty_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) LHS tokens = [., empty_like, _1]
>> Text rule . empty_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) RHS = MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . eye _1 |-->MatrixLib.identityMatrix(_1`firstArg) LHS variables = [_1]
>> Text rule . eye _1 |-->MatrixLib.identityMatrix(_1`firstArg) LHS tokens = [., eye, _1]
>> Text rule . eye _1 |-->MatrixLib.identityMatrix(_1`firstArg) RHS = MatrixLib.identityMatrix(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . identity _1 |-->MatrixLib.identityMatrix(_1`firstArg) LHS variables = [_1]
>> Text rule . identity _1 |-->MatrixLib.identityMatrix(_1`firstArg) LHS tokens = [., identity, _1]
>> Text rule . identity _1 |-->MatrixLib.identityMatrix(_1`firstArg) RHS = MatrixLib.identityMatrix(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . ones _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 1.0) LHS variables = [_1]
>> Text rule . ones _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 1.0) LHS tokens = [., ones, _1]
>> Text rule . ones _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 1.0) RHS = MatrixLib.singleValueMatrix(_1`firstArg, 1.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . ones_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 1.0) LHS variables = [_1]
>> Text rule . ones_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 1.0) LHS tokens = [., ones_like, _1]
>> Text rule . ones_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 1.0) RHS = MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 1.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . zeros _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) LHS variables = [_1]
>> Text rule . zeros _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) LHS tokens = [., zeros, _1]
>> Text rule . zeros _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0) RHS = MatrixLib.singleValueMatrix(_1`firstArg, 0.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . zeros_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) LHS variables = [_1]
>> Text rule . zeros_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) LHS tokens = [., zeros_like, _1]
>> Text rule . zeros_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0) RHS = MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . full _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . full _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, _1`secondArg) LHS tokens = [., full, _1]
>> Text rule . full _1 |-->MatrixLib.singleValueMatrix(_1`firstArg, _1`secondArg) RHS = MatrixLib.singleValueMatrix(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . full_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), _1`secondArg) LHS variables = [_1]
>> Text rule . full_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), _1`secondArg) LHS tokens = [., full_like, _1]
>> Text rule . full_like _1 |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), _1`secondArg) RHS = MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . ravel _1 |-->MatrixLib.flattenMatrix(_1`firstArg) LHS variables = [_1]
>> Text rule . ravel _1 |-->MatrixLib.flattenMatrix(_1`firstArg) LHS tokens = [., ravel, _1]
>> Text rule . ravel _1 |-->MatrixLib.flattenMatrix(_1`firstArg) RHS = MatrixLib.flattenMatrix(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . reshape _1 |-->MatrixLib.fillMatrixFrom(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . reshape _1 |-->MatrixLib.fillMatrixFrom(_1`firstArg, _1`secondArg) LHS tokens = [., reshape, _1]
>> Text rule . reshape _1 |-->MatrixLib.fillMatrixFrom(_1`firstArg, _1`secondArg) RHS = MatrixLib.fillMatrixFrom(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . sin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sin())) LHS variables = [_1]
>> Text rule . sin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sin())) LHS tokens = [., sin, _1]
>> Text rule . sin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sin())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sin()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . cos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cos())) LHS variables = [_1]
>> Text rule . cos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cos())) LHS tokens = [., cos, _1]
>> Text rule . cos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cos())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cos()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . tan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tan())) LHS variables = [_1]
>> Text rule . tan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tan())) LHS tokens = [., tan, _1]
>> Text rule . tan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tan())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tan()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arcsin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->asin())) LHS variables = [_1]
>> Text rule . arcsin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->asin())) LHS tokens = [., arcsin, _1]
>> Text rule . arcsin _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->asin())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->asin()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arccos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->acos())) LHS variables = [_1]
>> Text rule . arccos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->acos())) LHS tokens = [., arccos, _1]
>> Text rule . arccos _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->acos())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->acos()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arctan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->atan())) LHS variables = [_1]
>> Text rule . arctan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->atan())) LHS tokens = [., arctan, _1]
>> Text rule . arctan _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->atan())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->atan()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . sqrt _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sqrt())) LHS variables = [_1]
>> Text rule . sqrt _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sqrt())) LHS tokens = [., sqrt, _1]
>> Text rule . sqrt _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sqrt())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sqrt()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . round _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) LHS variables = [_1]
>> Text rule . round _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) LHS tokens = [., round, _1]
>> Text rule . round _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . floor _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->floor())) LHS variables = [_1]
>> Text rule . floor _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->floor())) LHS tokens = [., floor, _1]
>> Text rule . floor _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->floor())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->floor()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . ceil _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->ceil())) LHS variables = [_1]
>> Text rule . ceil _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->ceil())) LHS tokens = [., ceil, _1]
>> Text rule . ceil _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->ceil())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->ceil()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . sinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sinh())) LHS variables = [_1]
>> Text rule . sinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sinh())) LHS tokens = [., sinh, _1]
>> Text rule . sinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sinh())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sinh()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . cosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cosh())) LHS variables = [_1]
>> Text rule . cosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cosh())) LHS tokens = [., cosh, _1]
>> Text rule . cosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cosh())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cosh()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . tanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tanh())) LHS variables = [_1]
>> Text rule . tanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tanh())) LHS tokens = [., tanh, _1]
>> Text rule . tanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tanh())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tanh()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arcsinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.asinh(x))) LHS variables = [_1]
>> Text rule . arcsinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.asinh(x))) LHS tokens = [., arcsinh, _1]
>> Text rule . arcsinh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.asinh(x))) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.asinh(x)))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arccosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.acosh(x))) LHS variables = [_1]
>> Text rule . arccosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.acosh(x))) LHS tokens = [., arccosh, _1]
>> Text rule . arccosh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.acosh(x))) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.acosh(x)))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . arctanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.atanh(x))) LHS variables = [_1]
>> Text rule . arctanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.atanh(x))) LHS tokens = [., arctanh, _1]
>> Text rule . arctanh _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.atanh(x))) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.atanh(x)))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . rint _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) LHS variables = [_1]
>> Text rule . rint _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) LHS tokens = [., rint, _1]
>> Text rule . rint _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . trunc _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->oclAsType(int))) LHS variables = [_1]
>> Text rule . trunc _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->oclAsType(int))) LHS tokens = [., trunc, _1]
>> Text rule . trunc _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->oclAsType(int))) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->oclAsType(int)))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . exp _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->exp())) LHS variables = [_1]
>> Text rule . exp _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->exp())) LHS tokens = [., exp, _1]
>> Text rule . exp _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->exp())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->exp()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . log _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log())) LHS variables = [_1]
>> Text rule . log _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log())) LHS tokens = [., log, _1]
>> Text rule . log _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . log10 _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log10())) LHS variables = [_1]
>> Text rule . log10 _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log10())) LHS tokens = [., log10, _1]
>> Text rule . log10 _1 |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log10())) RHS = MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log10()))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . transpose _1 |-->MatrixLib.transpose(_1`firstArg) LHS variables = [_1]
>> Text rule . transpose _1 |-->MatrixLib.transpose(_1`firstArg) LHS tokens = [., transpose, _1]
>> Text rule . transpose _1 |-->MatrixLib.transpose(_1`firstArg) RHS = MatrixLib.transpose(_1`firstArg)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . add _1 |-->MatrixLib.matrixAddition(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . add _1 |-->MatrixLib.matrixAddition(_1`firstArg, _1`secondArg) LHS tokens = [., add, _1]
>> Text rule . add _1 |-->MatrixLib.matrixAddition(_1`firstArg, _1`secondArg) RHS = MatrixLib.matrixAddition(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . multiply _1 |-->MatrixLib.dotProduct(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . multiply _1 |-->MatrixLib.dotProduct(_1`firstArg, _1`secondArg) LHS tokens = [., multiply, _1]
>> Text rule . multiply _1 |-->MatrixLib.dotProduct(_1`firstArg, _1`secondArg) RHS = MatrixLib.dotProduct(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . subtract _1 |-->MatrixLib.matrixSubtraction(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . subtract _1 |-->MatrixLib.matrixSubtraction(_1`firstArg, _1`secondArg) LHS tokens = [., subtract, _1]
>> Text rule . subtract _1 |-->MatrixLib.matrixSubtraction(_1`firstArg, _1`secondArg) RHS = MatrixLib.matrixSubtraction(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . divide _1 |-->MatrixLib.dotDivide(_1`firstArg, _1`secondArg) LHS variables = [_1]
>> Text rule . divide _1 |-->MatrixLib.dotDivide(_1`firstArg, _1`secondArg) LHS tokens = [., divide, _1]
>> Text rule . divide _1 |-->MatrixLib.dotDivide(_1`firstArg, _1`secondArg) RHS = MatrixLib.dotDivide(_1`firstArg, _1`secondArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`secondArg]
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . default_rng _1 |-->OclRandom.newOclRandom_PCG_1 LHS variables = [_1]
>> Text rule . default_rng _1 |-->OclRandom.newOclRandom_PCG_1 LHS tokens = [., default_rng, _1]
>> Text rule . default_rng _1 |-->OclRandom.newOclRandom_PCG_1 RHS = OclRandom.newOclRandom_PCG_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . rand _1 |-->OclRandom.randomValuesMatrix_1 LHS variables = [_1]
>> Text rule . rand _1 |-->OclRandom.randomValuesMatrix_1 LHS tokens = [., rand, _1]
>> Text rule . rand _1 |-->OclRandom.randomValuesMatrix_1 RHS = OclRandom.randomValuesMatrix_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.newOclRandom_PCG()).nextInt(_1`lastArg - _1`firstArg)) LHS variables = [_1]
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.newOclRandom_PCG()).nextInt(_1`lastArg - _1`firstArg)) LHS tokens = [., randint, _1]
>> Text rule . randint _1 |-->(_1`firstArg + (OclRandom.newOclRandom_PCG()).nextInt(_1`lastArg - _1`firstArg)) RHS = (_1`firstArg + (OclRandom.newOclRandom_PCG()).nextInt(_1`lastArg - _1`firstArg))
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . random _1 |-->OclRandom.newOclRandom_PCG().nextDouble()<when> _1 matches \(\) LHS variables = [_1]
>> Text rule . random _1 |-->OclRandom.newOclRandom_PCG().nextDouble()<when> _1 matches \(\) LHS tokens = [., random, _1]
>> Text rule . random _1 |-->OclRandom.newOclRandom_PCG().nextDouble()<when> _1 matches \(\) RHS = OclRandom.newOclRandom_PCG().nextDouble()<when> _1 matches \(\)
+++ Condition lexicals:: [_1, matches, \, (, \, )]
>***> Rule with condition: [_1 matches \(\)]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . random _1 |-->OclRandom.randomValuesMatrix_1 LHS variables = [_1]
>> Text rule . random _1 |-->OclRandom.randomValuesMatrix_1 LHS tokens = [., random, _1]
>> Text rule . random _1 |-->OclRandom.randomValuesMatrix_1 RHS = OclRandom.randomValuesMatrix_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosin _1 |-->_1->cos() LHS variables = [_1]
>> Text rule . cosin _1 |-->_1->cos() LHS tokens = [., cosin, _1]
>> Text rule . cosin _1 |-->_1->cos() RHS = _1->cos()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sin _1 |-->_1->sin() LHS variables = [_1]
>> Text rule . sin _1 |-->_1->sin() LHS tokens = [., sin, _1]
>> Text rule . sin _1 |-->_1->sin() RHS = _1->sin()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tan _1 |-->_1->tan() LHS variables = [_1]
>> Text rule . tan _1 |-->_1->tan() LHS tokens = [., tan, _1]
>> Text rule . tan _1 |-->_1->tan() RHS = _1->tan()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ceil _1 |-->_1->ceil() LHS variables = [_1]
>> Text rule . ceil _1 |-->_1->ceil() LHS tokens = [., ceil, _1]
>> Text rule . ceil _1 |-->_1->ceil() RHS = _1->ceil()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . floor _1 |-->_1->floor() LHS variables = [_1]
>> Text rule . floor _1 |-->_1->floor() LHS tokens = [., floor, _1]
>> Text rule . floor _1 |-->_1->floor() RHS = _1->floor()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . trunc _1 |-->_1->oclAsType(int) LHS variables = [_1]
>> Text rule . trunc _1 |-->_1->oclAsType(int) LHS tokens = [., trunc, _1]
>> Text rule . trunc _1 |-->_1->oclAsType(int) RHS = _1->oclAsType(int)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sqrt _1 |-->_1->sqrt() LHS variables = [_1]
>> Text rule . sqrt _1 |-->_1->sqrt() LHS tokens = [., sqrt, _1]
>> Text rule . sqrt _1 |-->_1->sqrt() RHS = _1->sqrt()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cbrt _1 |-->_1->cbrt() LHS variables = [_1]
>> Text rule . cbrt _1 |-->_1->cbrt() LHS tokens = [., cbrt, _1]
>> Text rule . cbrt _1 |-->_1->cbrt() RHS = _1->cbrt()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . exp _1 |-->_1->exp() LHS variables = [_1]
>> Text rule . exp _1 |-->_1->exp() LHS tokens = [., exp, _1]
>> Text rule . exp _1 |-->_1->exp() RHS = _1->exp()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log _1 |-->_1->log() LHS variables = [_1]
>> Text rule . log _1 |-->_1->log() LHS tokens = [., log, _1]
>> Text rule . log _1 |-->_1->log() RHS = _1->log()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log10 _1 |-->_1->log10() LHS variables = [_1]
>> Text rule . log10 _1 |-->_1->log10() LHS tokens = [., log10, _1]
>> Text rule . log10 _1 |-->_1->log10() RHS = _1->log10()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acos _1 |-->_1->acos() LHS variables = [_1]
>> Text rule . acos _1 |-->_1->acos() LHS tokens = [., acos, _1]
>> Text rule . acos _1 |-->_1->acos() RHS = _1->acos()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asin _1 |-->_1->asin() LHS variables = [_1]
>> Text rule . asin _1 |-->_1->asin() LHS tokens = [., asin, _1]
>> Text rule . asin _1 |-->_1->asin() RHS = _1->asin()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atan _1 |-->_1->atan() LHS variables = [_1]
>> Text rule . atan _1 |-->_1->atan() LHS tokens = [., atan, _1]
>> Text rule . atan _1 |-->_1->atan() RHS = _1->atan()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acosh _1 |-->MathLib.acosh_1 LHS variables = [_1]
>> Text rule . acosh _1 |-->MathLib.acosh_1 LHS tokens = [., acosh, _1]
>> Text rule . acosh _1 |-->MathLib.acosh_1 RHS = MathLib.acosh_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asinh _1 |-->MathLib.asinh_1 LHS variables = [_1]
>> Text rule . asinh _1 |-->MathLib.asinh_1 LHS tokens = [., asinh, _1]
>> Text rule . asinh _1 |-->MathLib.asinh_1 RHS = MathLib.asinh_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atanh _1 |-->MathLib.atanh_1 LHS variables = [_1]
>> Text rule . atanh _1 |-->MathLib.atanh_1 LHS tokens = [., atanh, _1]
>> Text rule . atanh _1 |-->MathLib.atanh_1 RHS = MathLib.atanh_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosh _1 |-->_1->cosh() LHS variables = [_1]
>> Text rule . cosh _1 |-->_1->cosh() LHS tokens = [., cosh, _1]
>> Text rule . cosh _1 |-->_1->cosh() RHS = _1->cosh()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sinh _1 |-->_1->sinh() LHS variables = [_1]
>> Text rule . sinh _1 |-->_1->sinh() LHS tokens = [., sinh, _1]
>> Text rule . sinh _1 |-->_1->sinh() RHS = _1->sinh()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tanh _1 |-->_1->tanh() LHS variables = [_1]
>> Text rule . tanh _1 |-->_1->tanh() LHS tokens = [., tanh, _1]
>> Text rule . tanh _1 |-->_1->tanh() RHS = _1->tanh()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pow _1 |-->(_1`firstArg)->pow(_1`lastArg) LHS variables = [_1]
>> Text rule . pow _1 |-->(_1`firstArg)->pow(_1`lastArg) LHS tokens = [., pow, _1]
>> Text rule . pow _1 |-->(_1`firstArg)->pow(_1`lastArg) RHS = (_1`firstArg)->pow(_1`lastArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . comb _1 |-->MathLib.combinatorial(_1`firstArg, _1`lastArg) LHS variables = [_1]
>> Text rule . comb _1 |-->MathLib.combinatorial(_1`firstArg, _1`lastArg) LHS tokens = [., comb, _1]
>> Text rule . comb _1 |-->MathLib.combinatorial(_1`firstArg, _1`lastArg) RHS = MathLib.combinatorial(_1`firstArg, _1`lastArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . fabs _1 |-->_1->abs() LHS variables = [_1]
>> Text rule . fabs _1 |-->_1->abs() LHS tokens = [., fabs, _1]
>> Text rule . fabs _1 |-->_1->abs() RHS = _1->abs()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . factorial _1 |-->MathLib.factorial_1 LHS variables = [_1]
>> Text rule . factorial _1 |-->MathLib.factorial_1 LHS tokens = [., factorial, _1]
>> Text rule . factorial _1 |-->MathLib.factorial_1 RHS = MathLib.factorial_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fsum _1 |-->_1->sum() LHS variables = [_1]
>> Text rule . fsum _1 |-->_1->sum() LHS tokens = [., fsum, _1]
>> Text rule . fsum _1 |-->_1->sum() RHS = _1->sum()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . prod _1 |-->_1->prd() LHS variables = [_1]
>> Text rule . prod _1 |-->_1->prd() LHS tokens = [., prod, _1]
>> Text rule . prod _1 |-->_1->prd() RHS = _1->prd()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gcd _1 |-->(_1`firstArg)->gcd(_1`lastArg) LHS variables = [_1]
>> Text rule . gcd _1 |-->(_1`firstArg)->gcd(_1`lastArg) LHS tokens = [., gcd, _1]
>> Text rule . gcd _1 |-->(_1`firstArg)->gcd(_1`lastArg) RHS = (_1`firstArg)->gcd(_1`lastArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . lcm _1 |-->MathLib.lcm(_1`firstArg, _1`lastArg) LHS variables = [_1]
>> Text rule . lcm _1 |-->MathLib.lcm(_1`firstArg, _1`lastArg) LHS tokens = [., lcm, _1]
>> Text rule . lcm _1 |-->MathLib.lcm(_1`firstArg, _1`lastArg) RHS = MathLib.lcm(_1`firstArg, _1`lastArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosin _1 |-->double LHS variables = [_1]
>> Text rule . cosin _1 |-->double LHS tokens = [., cosin, _1]
>> Text rule . cosin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sin _1 |-->double LHS variables = [_1]
>> Text rule . sin _1 |-->double LHS tokens = [., sin, _1]
>> Text rule . sin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tan _1 |-->double LHS variables = [_1]
>> Text rule . tan _1 |-->double LHS tokens = [., tan, _1]
>> Text rule . tan _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ceil _1 |-->double LHS variables = [_1]
>> Text rule . ceil _1 |-->double LHS tokens = [., ceil, _1]
>> Text rule . ceil _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . floor _1 |-->double LHS variables = [_1]
>> Text rule . floor _1 |-->double LHS tokens = [., floor, _1]
>> Text rule . floor _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . trunc _1 |-->int LHS variables = [_1]
>> Text rule . trunc _1 |-->int LHS tokens = [., trunc, _1]
>> Text rule . trunc _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sqrt _1 |-->double LHS variables = [_1]
>> Text rule . sqrt _1 |-->double LHS tokens = [., sqrt, _1]
>> Text rule . sqrt _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cbrt _1 |-->double LHS variables = [_1]
>> Text rule . cbrt _1 |-->double LHS tokens = [., cbrt, _1]
>> Text rule . cbrt _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . exp _1 |-->double LHS variables = [_1]
>> Text rule . exp _1 |-->double LHS tokens = [., exp, _1]
>> Text rule . exp _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log _1 |-->double LHS variables = [_1]
>> Text rule . log _1 |-->double LHS tokens = [., log, _1]
>> Text rule . log _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log10 _1 |-->double LHS variables = [_1]
>> Text rule . log10 _1 |-->double LHS tokens = [., log10, _1]
>> Text rule . log10 _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acos _1 |-->double LHS variables = [_1]
>> Text rule . acos _1 |-->double LHS tokens = [., acos, _1]
>> Text rule . acos _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asin _1 |-->double LHS variables = [_1]
>> Text rule . asin _1 |-->double LHS tokens = [., asin, _1]
>> Text rule . asin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atan _1 |-->double LHS variables = [_1]
>> Text rule . atan _1 |-->double LHS tokens = [., atan, _1]
>> Text rule . atan _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acosh _1 |-->double LHS variables = [_1]
>> Text rule . acosh _1 |-->double LHS tokens = [., acosh, _1]
>> Text rule . acosh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asinh _1 |-->double LHS variables = [_1]
>> Text rule . asinh _1 |-->double LHS tokens = [., asinh, _1]
>> Text rule . asinh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atanh _1 |-->double LHS variables = [_1]
>> Text rule . atanh _1 |-->double LHS tokens = [., atanh, _1]
>> Text rule . atanh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosh _1 |-->double LHS variables = [_1]
>> Text rule . cosh _1 |-->double LHS tokens = [., cosh, _1]
>> Text rule . cosh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sinh _1 |-->double LHS variables = [_1]
>> Text rule . sinh _1 |-->double LHS tokens = [., sinh, _1]
>> Text rule . sinh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tanh _1 |-->double LHS variables = [_1]
>> Text rule . tanh _1 |-->double LHS tokens = [., tanh, _1]
>> Text rule . tanh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pow _1 |-->double LHS variables = [_1]
>> Text rule . pow _1 |-->double LHS tokens = [., pow, _1]
>> Text rule . pow _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . comb _1 |-->long LHS variables = [_1]
>> Text rule . comb _1 |-->long LHS tokens = [., comb, _1]
>> Text rule . comb _1 |-->long RHS = long
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fabs _1 |-->double LHS variables = [_1]
>> Text rule . fabs _1 |-->double LHS tokens = [., fabs, _1]
>> Text rule . fabs _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . factorial _1 |-->long LHS variables = [_1]
>> Text rule . factorial _1 |-->long LHS tokens = [., factorial, _1]
>> Text rule . factorial _1 |-->long RHS = long
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fsum _1 |-->double LHS variables = [_1]
>> Text rule . fsum _1 |-->double LHS tokens = [., fsum, _1]
>> Text rule . fsum _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . prod _1 |-->double LHS variables = [_1]
>> Text rule . prod _1 |-->double LHS tokens = [., prod, _1]
>> Text rule . prod _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gcd _1 |-->long LHS variables = [_1]
>> Text rule . gcd _1 |-->long LHS tokens = [., gcd, _1]
>> Text rule . gcd _1 |-->long RHS = long
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . lcm _1 |-->int LHS variables = [_1]
>> Text rule . lcm _1 |-->int LHS tokens = [., lcm, _1]
>> Text rule . lcm _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->OclAny LHS variables = [_1, _*]
>> Text rule . _1 _* |-->OclAny LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . deque _1 |-->Sequence LHS variables = [_1]
>> Text rule . deque _1 |-->Sequence LHS tokens = [., deque, _1]
>> Text rule . deque _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . OrderedDict _1 |-->Map LHS variables = [_1]
>> Text rule . OrderedDict _1 |-->Map LHS tokens = [., OrderedDict, _1]
>> Text rule . OrderedDict _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->OclAny LHS variables = [_1, _*]
>> Text rule . _1 _* |-->OclAny LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read_csv _1 |-->OclDataTable LHS variables = [_1]
>> Text rule . read_csv _1 |-->OclDataTable LHS tokens = [., read_csv, _1]
>> Text rule . read_csv _1 |-->OclDataTable RHS = OclDataTable
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read_json _1 |-->OclDataTable LHS variables = [_1]
>> Text rule . read_json _1 |-->OclDataTable LHS tokens = [., read_json, _1]
>> Text rule . read_json _1 |-->OclDataTable RHS = OclDataTable
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . DataFrame _1 |-->OclDataTable LHS variables = [_1]
>> Text rule . DataFrame _1 |-->OclDataTable LHS tokens = [., DataFrame, _1]
>> Text rule . DataFrame _1 |-->OclDataTable RHS = OclDataTable
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . Series _1 |-->Sequence LHS variables = [_1]
>> Text rule . Series _1 |-->Sequence LHS tokens = [., Series, _1]
>> Text rule . Series _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->OclAny LHS variables = [_*]
>> Text rule _* |-->OclAny LHS tokens = [_*]
>> Text rule _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule . inf |-->double LHS variables = []
>> Text rule . inf |-->double LHS tokens = [., inf]
>> Text rule . inf |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . Inf |-->double LHS variables = []
>> Text rule . Inf |-->double LHS tokens = [., Inf]
>> Text rule . Inf |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . Infinity |-->double LHS variables = []
>> Text rule . Infinity |-->double LHS tokens = [., Infinity]
>> Text rule . Infinity |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . infty |-->double LHS variables = []
>> Text rule . infty |-->double LHS tokens = [., infty]
>> Text rule . infty |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . PINF |-->double LHS variables = []
>> Text rule . PINF |-->double LHS tokens = [., PINF]
>> Text rule . PINF |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NINF |-->double LHS variables = []
>> Text rule . NINF |-->double LHS tokens = [., NINF]
>> Text rule . NINF |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . nan |-->double LHS variables = []
>> Text rule . nan |-->double LHS tokens = [., nan]
>> Text rule . nan |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NaN |-->double LHS variables = []
>> Text rule . NaN |-->double LHS tokens = [., NaN]
>> Text rule . NaN |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NAN |-->double LHS variables = []
>> Text rule . NAN |-->double LHS tokens = [., NAN]
>> Text rule . NAN |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . NZERO |-->double LHS variables = []
>> Text rule . NZERO |-->double LHS tokens = [., NZERO]
>> Text rule . NZERO |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . PZERO |-->double LHS variables = []
>> Text rule . PZERO |-->double LHS tokens = [., PZERO]
>> Text rule . PZERO |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . newaxis |-->OclAny LHS variables = []
>> Text rule . newaxis |-->OclAny LHS tokens = [., newaxis]
>> Text rule . newaxis |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . pi |-->double LHS variables = []
>> Text rule . pi |-->double LHS tokens = [., pi]
>> Text rule . pi |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . e |-->double LHS variables = []
>> Text rule . e |-->double LHS tokens = [., e]
>> Text rule . e |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . euler_gamma |-->double LHS variables = []
>> Text rule . euler_gamma |-->double LHS tokens = [., euler_gamma]
>> Text rule . euler_gamma |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . int32 |-->OclType LHS variables = []
>> Text rule . int32 |-->OclType LHS tokens = [., int32]
>> Text rule . int32 |-->OclType RHS = OclType
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . int64 |-->OclType LHS variables = []
>> Text rule . int64 |-->OclType LHS tokens = [., int64]
>> Text rule . int64 |-->OclType RHS = OclType
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . float32 |-->OclType LHS variables = []
>> Text rule . float32 |-->OclType LHS tokens = [., float32]
>> Text rule . float32 |-->OclType RHS = OclType
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . float64 |-->OclType LHS variables = []
>> Text rule . float64 |-->OclType LHS tokens = [., float64]
>> Text rule . float64 |-->OclType RHS = OclType
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . array _1 |-->Sequence LHS variables = [_1]
>> Text rule . array _1 |-->Sequence LHS tokens = [., array, _1]
>> Text rule . array _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arange _1 |-->Sequence LHS variables = [_1]
>> Text rule . arange _1 |-->Sequence LHS tokens = [., arange, _1]
>> Text rule . arange _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . concatenate _1 |-->Sequence LHS variables = [_1]
>> Text rule . concatenate _1 |-->Sequence LHS tokens = [., concatenate, _1]
>> Text rule . concatenate _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . shape _1 |-->Sequence LHS variables = [_1]
>> Text rule . shape _1 |-->Sequence LHS tokens = [., shape, _1]
>> Text rule . shape _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . empty _1 |-->Sequence LHS variables = [_1]
>> Text rule . empty _1 |-->Sequence LHS tokens = [., empty, _1]
>> Text rule . empty _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . empty_like _1 |-->Sequence LHS variables = [_1]
>> Text rule . empty_like _1 |-->Sequence LHS tokens = [., empty_like, _1]
>> Text rule . empty_like _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . eye _1 |-->Sequence LHS variables = [_1]
>> Text rule . eye _1 |-->Sequence LHS tokens = [., eye, _1]
>> Text rule . eye _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . identity _1 |-->Sequence LHS variables = [_1]
>> Text rule . identity _1 |-->Sequence LHS tokens = [., identity, _1]
>> Text rule . identity _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ones _1 |-->Sequence LHS variables = [_1]
>> Text rule . ones _1 |-->Sequence LHS tokens = [., ones, _1]
>> Text rule . ones _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ones_like _1 |-->Sequence LHS variables = [_1]
>> Text rule . ones_like _1 |-->Sequence LHS tokens = [., ones_like, _1]
>> Text rule . ones_like _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . zeros _1 |-->Sequence LHS variables = [_1]
>> Text rule . zeros _1 |-->Sequence LHS tokens = [., zeros, _1]
>> Text rule . zeros _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . zeros_like _1 |-->Sequence LHS variables = [_1]
>> Text rule . zeros_like _1 |-->Sequence LHS tokens = [., zeros_like, _1]
>> Text rule . zeros_like _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . full _1 |-->Sequence LHS variables = [_1]
>> Text rule . full _1 |-->Sequence LHS tokens = [., full, _1]
>> Text rule . full _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . full_like _1 |-->Sequence LHS variables = [_1]
>> Text rule . full_like _1 |-->Sequence LHS tokens = [., full_like, _1]
>> Text rule . full_like _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . array _1 |-->Sequence LHS variables = [_1]
>> Text rule . array _1 |-->Sequence LHS tokens = [., array, _1]
>> Text rule . array _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asarray _1 |-->Sequence LHS variables = [_1]
>> Text rule . asarray _1 |-->Sequence LHS tokens = [., asarray, _1]
>> Text rule . asarray _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asanyarray _1 |-->Sequence LHS variables = [_1]
>> Text rule . asanyarray _1 |-->Sequence LHS tokens = [., asanyarray, _1]
>> Text rule . asanyarray _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ascontiguousarray _1 |-->Sequence LHS variables = [_1]
>> Text rule . ascontiguousarray _1 |-->Sequence LHS tokens = [., ascontiguousarray, _1]
>> Text rule . ascontiguousarray _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asmatrix _1 |-->Sequence LHS variables = [_1]
>> Text rule . asmatrix _1 |-->Sequence LHS tokens = [., asmatrix, _1]
>> Text rule . asmatrix _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . copy _1 |-->Sequence LHS variables = [_1]
>> Text rule . copy _1 |-->Sequence LHS tokens = [., copy, _1]
>> Text rule . copy _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fromstring _1 |-->Sequence LHS variables = [_1]
>> Text rule . fromstring _1 |-->Sequence LHS tokens = [., fromstring, _1]
>> Text rule . fromstring _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . linspace _1 |-->Sequence LHS variables = [_1]
>> Text rule . linspace _1 |-->Sequence LHS tokens = [., linspace, _1]
>> Text rule . linspace _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . transpose _1 |-->Sequence LHS variables = [_1]
>> Text rule . transpose _1 |-->Sequence LHS tokens = [., transpose, _1]
>> Text rule . transpose _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sin _1 |-->Sequence LHS variables = [_1]
>> Text rule . sin _1 |-->Sequence LHS tokens = [., sin, _1]
>> Text rule . sin _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cos _1 |-->Sequence LHS variables = [_1]
>> Text rule . cos _1 |-->Sequence LHS tokens = [., cos, _1]
>> Text rule . cos _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tan _1 |-->Sequence LHS variables = [_1]
>> Text rule . tan _1 |-->Sequence LHS tokens = [., tan, _1]
>> Text rule . tan _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arcsin _1 |-->Sequence LHS variables = [_1]
>> Text rule . arcsin _1 |-->Sequence LHS tokens = [., arcsin, _1]
>> Text rule . arcsin _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arccos _1 |-->Sequence LHS variables = [_1]
>> Text rule . arccos _1 |-->Sequence LHS tokens = [., arccos, _1]
>> Text rule . arccos _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arctan _1 |-->Sequence LHS variables = [_1]
>> Text rule . arctan _1 |-->Sequence LHS tokens = [., arctan, _1]
>> Text rule . arctan _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sqrt _1 |-->Sequence LHS variables = [_1]
>> Text rule . sqrt _1 |-->Sequence LHS tokens = [., sqrt, _1]
>> Text rule . sqrt _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . round _1 |-->Sequence LHS variables = [_1]
>> Text rule . round _1 |-->Sequence LHS tokens = [., round, _1]
>> Text rule . round _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . floor _1 |-->Sequence LHS variables = [_1]
>> Text rule . floor _1 |-->Sequence LHS tokens = [., floor, _1]
>> Text rule . floor _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ceil _1 |-->Sequence LHS variables = [_1]
>> Text rule . ceil _1 |-->Sequence LHS tokens = [., ceil, _1]
>> Text rule . ceil _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sinh _1 |-->Sequence LHS variables = [_1]
>> Text rule . sinh _1 |-->Sequence LHS tokens = [., sinh, _1]
>> Text rule . sinh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosh _1 |-->Sequence LHS variables = [_1]
>> Text rule . cosh _1 |-->Sequence LHS tokens = [., cosh, _1]
>> Text rule . cosh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tanh _1 |-->Sequence LHS variables = [_1]
>> Text rule . tanh _1 |-->Sequence LHS tokens = [., tanh, _1]
>> Text rule . tanh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arcsinh _1 |-->Sequence LHS variables = [_1]
>> Text rule . arcsinh _1 |-->Sequence LHS tokens = [., arcsinh, _1]
>> Text rule . arcsinh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arccosh _1 |-->Sequence LHS variables = [_1]
>> Text rule . arccosh _1 |-->Sequence LHS tokens = [., arccosh, _1]
>> Text rule . arccosh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . arctanh _1 |-->Sequence LHS variables = [_1]
>> Text rule . arctanh _1 |-->Sequence LHS tokens = [., arctanh, _1]
>> Text rule . arctanh _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . rint _1 |-->Sequence LHS variables = [_1]
>> Text rule . rint _1 |-->Sequence LHS tokens = [., rint, _1]
>> Text rule . rint _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . trunc _1 |-->Sequence LHS variables = [_1]
>> Text rule . trunc _1 |-->Sequence LHS tokens = [., trunc, _1]
>> Text rule . trunc _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . exp _1 |-->Sequence LHS variables = [_1]
>> Text rule . exp _1 |-->Sequence LHS tokens = [., exp, _1]
>> Text rule . exp _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log _1 |-->Sequence LHS variables = [_1]
>> Text rule . log _1 |-->Sequence LHS tokens = [., log, _1]
>> Text rule . log _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log10 _1 |-->Sequence LHS variables = [_1]
>> Text rule . log10 _1 |-->Sequence LHS tokens = [., log10, _1]
>> Text rule . log10 _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . add _1 |-->Sequence LHS variables = [_1]
>> Text rule . add _1 |-->Sequence LHS tokens = [., add, _1]
>> Text rule . add _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . subtract _1 |-->Sequence LHS variables = [_1]
>> Text rule . subtract _1 |-->Sequence LHS tokens = [., subtract, _1]
>> Text rule . subtract _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . multiply _1 |-->Sequence LHS variables = [_1]
>> Text rule . multiply _1 |-->Sequence LHS tokens = [., multiply, _1]
>> Text rule . multiply _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . divide _1 |-->Sequence LHS variables = [_1]
>> Text rule . divide _1 |-->Sequence LHS tokens = [., divide, _1]
>> Text rule . divide _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . matmul _1 |-->Sequence LHS variables = [_1]
>> Text rule . matmul _1 |-->Sequence LHS tokens = [., matmul, _1]
>> Text rule . matmul _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->Sequence LHS variables = [_1]
>> Text rule . sort _1 |-->Sequence LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sum _1 |-->double LHS variables = [_1]
>> Text rule . sum _1 |-->double LHS tokens = [., sum, _1]
>> Text rule . sum _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . prod _1 |-->double LHS variables = [_1]
>> Text rule . prod _1 |-->double LHS tokens = [., prod, _1]
>> Text rule . prod _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . default_rng _1 |-->OclRandom LHS variables = [_1]
>> Text rule . default_rng _1 |-->OclRandom LHS tokens = [., default_rng, _1]
>> Text rule . default_rng _1 |-->OclRandom RHS = OclRandom
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . rand _1 |-->Sequence LHS variables = [_1]
>> Text rule . rand _1 |-->Sequence LHS tokens = [., rand, _1]
>> Text rule . rand _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randint _1 |-->int LHS variables = [_1]
>> Text rule . randint _1 |-->int LHS tokens = [., randint, _1]
>> Text rule . randint _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . random _1 |-->double<when> _1 matches \(\) LHS variables = [_1]
>> Text rule . random _1 |-->double<when> _1 matches \(\) LHS tokens = [., random, _1]
>> Text rule . random _1 |-->double<when> _1 matches \(\) RHS = double<when> _1 matches \(\)
+++ Condition lexicals:: [_1, matches, \, (, \, )]
>***> Rule with condition: [_1 matches \(\)]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . random _1 |-->Sequence LHS variables = [_1]
>> Text rule . random _1 |-->Sequence LHS tokens = [., random, _1]
>> Text rule . random _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . dump _1 |-->_1`secondArg.writeObject(_1`firstArg) LHS variables = [_1]
>> Text rule . dump _1 |-->_1`secondArg.writeObject(_1`firstArg) LHS tokens = [., dump, _1]
>> Text rule . dump _1 |-->_1`secondArg.writeObject(_1`firstArg) RHS = _1`secondArg.writeObject(_1`firstArg)
>>> found metafeature _1`secondArg for _1`
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg, _1`firstArg]
>> Text rule . load _1 |-->_1.readObject() LHS variables = [_1]
>> Text rule . load _1 |-->_1.readObject() LHS tokens = [., load, _1]
>> Text rule . load _1 |-->_1.readObject() RHS = _1.readObject()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . MINYEAR |-->1 LHS variables = []
>> Text rule . MINYEAR |-->1 LHS tokens = [., MINYEAR]
>> Text rule . MINYEAR |-->1 RHS = 1
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . MAXYEAR |-->9999 LHS variables = []
>> Text rule . MAXYEAR |-->9999 LHS tokens = [., MAXYEAR]
>> Text rule . MAXYEAR |-->9999 RHS = 9999
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . date |-->OclDate LHS variables = []
>> Text rule . date |-->OclDate LHS tokens = [., date]
>> Text rule . date |-->OclDate RHS = OclDate
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . datetime |-->OclDate LHS variables = []
>> Text rule . datetime |-->OclDate LHS tokens = [., datetime]
>> Text rule . datetime |-->OclDate RHS = OclDate
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . now _1 |-->OclDate.newOclDate() LHS variables = [_1]
>> Text rule . now _1 |-->OclDate.newOclDate() LHS tokens = [., now, _1]
>> Text rule . now _1 |-->OclDate.newOclDate() RHS = OclDate.newOclDate()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . today _1 |-->OclDate.newOclDate() LHS variables = [_1]
>> Text rule . today _1 |-->OclDate.newOclDate() LHS tokens = [., today, _1]
>> Text rule . today _1 |-->OclDate.newOclDate() RHS = OclDate.newOclDate()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fromtimestamp _1 |-->OclDate.newOclDate_Time((_1`firstArg)->oclAsType(long)) LHS variables = [_1]
>> Text rule . fromtimestamp _1 |-->OclDate.newOclDate_Time((_1`firstArg)->oclAsType(long)) LHS tokens = [., fromtimestamp, _1]
>> Text rule . fromtimestamp _1 |-->OclDate.newOclDate_Time((_1`firstArg)->oclAsType(long)) RHS = OclDate.newOclDate_Time((_1`firstArg)->oclAsType(long))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . fromisoformat _1 |-->OclDate.newOclDate_String((_1`firstArg)->oclAsType(long)) LHS variables = [_1]
>> Text rule . fromisoformat _1 |-->OclDate.newOclDate_String((_1`firstArg)->oclAsType(long)) LHS tokens = [., fromisoformat, _1]
>> Text rule . fromisoformat _1 |-->OclDate.newOclDate_String((_1`firstArg)->oclAsType(long)) RHS = OclDate.newOclDate_String((_1`firstArg)->oclAsType(long))
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop ( ) |-->true LHS variables = []
>> Text rule . pop ( ) |-->true LHS tokens = [., pop, (, )]
>> Text rule . pop ( ) |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->true LHS variables = [_1]
>> Text rule . pop _1 |-->true LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . popleft ( ) |-->true LHS variables = []
>> Text rule . popleft ( ) |-->true LHS tokens = [., popleft, (, )]
>> Text rule . popleft ( ) |-->true RHS = true
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . popleft _1 |-->true LHS variables = [_1]
>> Text rule . popleft _1 |-->true LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |--> LHS variables = [_1]
>> Text rule . _1 |--> LHS tokens = [., _1]
>> Text rule . _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |--> LHS variables = [_1, _*]
>> Text rule . _1 _* |--> LHS tokens = [., _1, _*]
>> Text rule . _1 _* |--> RHS = 
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . append _1 |-->->append_1 LHS variables = [_1]
>> Text rule . append _1 |-->->append_1 LHS tokens = [., append, _1]
>> Text rule . append _1 |-->->append_1 RHS = ->append_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . extend _1 |-->->union(_1->characters())<when> _1 String LHS variables = [_1]
>> Text rule . extend _1 |-->->union(_1->characters())<when> _1 String LHS tokens = [., extend, _1]
>> Text rule . extend _1 |-->->union(_1->characters())<when> _1 String RHS = ->union(_1->characters())<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . extend _1 |-->->union_1 LHS variables = [_1]
>> Text rule . extend _1 |-->->union_1 LHS tokens = [., extend, _1]
>> Text rule . extend _1 |-->->union_1 RHS = ->union_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . insert _1 |-->.insertAt(_1`firstArg+1, _1`lastArg) LHS variables = [_1]
>> Text rule . insert _1 |-->.insertAt(_1`firstArg+1, _1`lastArg) LHS tokens = [., insert, _1]
>> Text rule . insert _1 |-->.insertAt(_1`firstArg+1, _1`lastArg) RHS = .insertAt(_1`firstArg+1, _1`lastArg)
>>> found metafeature _1`firstArg for _1`
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg, _1`lastArg]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS variables = [_1]
>> Text rule . remove _1 |-->->excludingFirst_1 LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->->excludingFirst_1 RHS = ->excludingFirst_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->->sort() LHS variables = [_1]
>> Text rule . sort _1 |-->->sort() LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->->sort() RHS = ->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->->reverse() LHS variables = [_1]
>> Text rule . reverse _1 |-->->reverse() LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->->reverse() RHS = ->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->_1`popUpdateArguments LHS variables = [_1]
>> Text rule . pop _1 |-->_1`popUpdateArguments LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->_1`popUpdateArguments RHS = _1`popUpdateArguments
>>> found metafeature _1`popUpdateArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popUpdateArguments]
>> Text rule . popleft _1 |-->_1`popleftUpdateArguments LHS variables = [_1]
>> Text rule . popleft _1 |-->_1`popleftUpdateArguments LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->_1`popleftUpdateArguments RHS = _1`popleftUpdateArguments
>>> found metafeature _1`popleftUpdateArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`popleftUpdateArguments]
>> Text rule . add _1 |-->->including_1 LHS variables = [_1]
>> Text rule . add _1 |-->->including_1 LHS tokens = [., add, _1]
>> Text rule . add _1 |-->->including_1 RHS = ->including_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection _1 |-->->intersection_1 LHS tokens = [., intersection, _1]
>> Text rule . intersection _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->->intersection_1 LHS variables = [_1]
>> Text rule . intersection_update _1 |-->->intersection_1 LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->->intersection_1 RHS = ->intersection_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference _1 |--> - _1 LHS tokens = [., difference, _1]
>> Text rule . difference _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |--> - _1 LHS variables = [_1]
>> Text rule . difference_update _1 |--> - _1 LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->->symmetricDifference_1 RHS = ->symmetricDifference_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->_1`allUnion LHS variables = [_1]
>> Text rule . update _1 |-->_1`allUnion LHS tokens = [., update, _1]
>> Text rule . update _1 |-->_1`allUnion RHS = _1`allUnion
>>> found metafeature _1`allUnion for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`allUnion]
>> Text rule . discard _1 |-->->excluding_1 LHS variables = [_1]
>> Text rule . discard _1 |-->->excluding_1 LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->->excluding_1 RHS = ->excluding_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->->intersection(Set{}) LHS variables = [_1]
>> Text rule . clear _1 |-->->intersection(Set{}) LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->->intersection(Set{}) RHS = ->intersection(Set{})
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . appendleft _1 |-->->prepend_1 LHS variables = [_1]
>> Text rule . appendleft _1 |-->->prepend_1 LHS tokens = [., appendleft, _1]
>> Text rule . appendleft _1 |-->->prepend_1 RHS = ->prepend_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . extendleft _1 |-->->reverse()->union_1->reverse() LHS variables = [_1]
>> Text rule . extendleft _1 |-->->reverse()->union_1->reverse() LHS tokens = [., extendleft, _1]
>> Text rule . extendleft _1 |-->->reverse()->union_1->reverse() RHS = ->reverse()->union_1->reverse()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->._1 LHS variables = [_1]
>> Text rule . _1 |-->._1 LHS tokens = [., _1]
>> Text rule . _1 |-->._1 RHS = ._1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->._1_* LHS variables = [_1, _*]
>> Text rule . _1 _* |-->._1_* LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->._1_* RHS = ._1_*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . append _1 |-->true LHS variables = [_1]
>> Text rule . append _1 |-->true LHS tokens = [., append, _1]
>> Text rule . append _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . extend _1 |-->true LHS variables = [_1]
>> Text rule . extend _1 |-->true LHS tokens = [., extend, _1]
>> Text rule . extend _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . insert _1 |-->true LHS variables = [_1]
>> Text rule . insert _1 |-->true LHS tokens = [., insert, _1]
>> Text rule . insert _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . remove _1 |-->true LHS variables = [_1]
>> Text rule . remove _1 |-->true LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sort _1 |-->true LHS variables = [_1]
>> Text rule . sort _1 |-->true LHS tokens = [., sort, _1]
>> Text rule . sort _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . reverse _1 |-->true LHS variables = [_1]
>> Text rule . reverse _1 |-->true LHS tokens = [., reverse, _1]
>> Text rule . reverse _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pop _1 |-->true LHS variables = [_1]
>> Text rule . pop _1 |-->true LHS tokens = [., pop, _1]
>> Text rule . pop _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . popleft _1 |-->true LHS variables = [_1]
>> Text rule . popleft _1 |-->true LHS tokens = [., popleft, _1]
>> Text rule . popleft _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . add _1 |-->true LHS variables = [_1]
>> Text rule . add _1 |-->true LHS tokens = [., add, _1]
>> Text rule . add _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . intersection_update _1 |-->true LHS variables = [_1]
>> Text rule . intersection_update _1 |-->true LHS tokens = [., intersection_update, _1]
>> Text rule . intersection_update _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . difference_update _1 |-->true LHS variables = [_1]
>> Text rule . difference_update _1 |-->true LHS tokens = [., difference_update, _1]
>> Text rule . difference_update _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . symmetric_difference _1 |-->true LHS variables = [_1]
>> Text rule . symmetric_difference _1 |-->true LHS tokens = [., symmetric_difference, _1]
>> Text rule . symmetric_difference _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . update _1 |-->true LHS variables = [_1]
>> Text rule . update _1 |-->true LHS tokens = [., update, _1]
>> Text rule . update _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . remove _1 |-->true LHS variables = [_1]
>> Text rule . remove _1 |-->true LHS tokens = [., remove, _1]
>> Text rule . remove _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . discard _1 |-->true LHS variables = [_1]
>> Text rule . discard _1 |-->true LHS tokens = [., discard, _1]
>> Text rule . discard _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->true LHS variables = [_1]
>> Text rule . clear _1 |-->true LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . appendleft _1 |-->true LHS variables = [_1]
>> Text rule . appendleft _1 |-->true LHS tokens = [., appendleft, _1]
>> Text rule . appendleft _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . extendleft _1 |-->true LHS variables = [_1]
>> Text rule . extendleft _1 |-->true LHS tokens = [., extendleft, _1]
>> Text rule . extendleft _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->false LHS variables = [_1]
>> Text rule . _1 |-->false LHS tokens = [., _1]
>> Text rule . _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _* |-->false LHS variables = [_1, _*]
>> Text rule . _1 _* |-->false LHS tokens = [., _1, _*]
>> Text rule . _1 _* |-->false RHS = false
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`rangeArguments LHS variables = [_1]
>> Text rule _1 |-->_1`rangeArguments LHS tokens = [_1]
>> Text rule _1 |-->_1`rangeArguments RHS = _1`rangeArguments
>>> found metafeature _1`rangeArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`rangeArguments]
>> Text rule _1 |-->_1`sortedArguments LHS variables = [_1]
>> Text rule _1 |-->_1`sortedArguments LHS tokens = [_1]
>> Text rule _1 |-->_1`sortedArguments RHS = _1`sortedArguments
>>> found metafeature _1`sortedArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sortedArguments]
>> Text rule . ljust _1 |-->_1`justificationArguments LHS variables = [_1]
>> Text rule . ljust _1 |-->_1`justificationArguments LHS tokens = [., ljust, _1]
>> Text rule . ljust _1 |-->_1`justificationArguments RHS = _1`justificationArguments
>>> found metafeature _1`justificationArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`justificationArguments]
>> Text rule . rjust _1 |-->_1`justificationArguments LHS variables = [_1]
>> Text rule . rjust _1 |-->_1`justificationArguments LHS tokens = [., rjust, _1]
>> Text rule . rjust _1 |-->_1`justificationArguments RHS = _1`justificationArguments
>>> found metafeature _1`justificationArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`justificationArguments]
>> Text rule ( _1 ) |--> _1`third, _1`first LHS variables = [_1]
>> Text rule ( _1 ) |--> _1`third, _1`first LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |--> _1`third, _1`first RHS =  _1`third, _1`first
>>> found metafeature _1`third for _1`
>>> found metafeature _1`first for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`third, _1`first]
>> Text rule . format _1 |-->_1`formatArguments LHS variables = [_1]
>> Text rule . format _1 |-->_1`formatArguments LHS tokens = [., format, _1]
>> Text rule . format _1 |-->_1`formatArguments RHS = _1`formatArguments
>>> found metafeature _1`formatArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`formatArguments]
>> Text rule ( _1 ) |-->Sequence{_1} LHS variables = [_1]
>> Text rule ( _1 ) |-->Sequence{_1} LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->Sequence{_1} RHS = Sequence{_1}
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1) RHS = (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->() LHS variables = []
>> Text rule [ ] |-->() LHS tokens = [[, ]]
>> Text rule [ ] |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->->selectRows(_1`literalSubscript)<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule [ _1 ] |-->->selectRows(_1`literalSubscript)<when> _1`ocltype boolean LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->selectRows(_1`literalSubscript)<when> _1`ocltype boolean RHS = ->selectRows(_1`literalSubscript)<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript)<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript)<when> _1`ocltype Sequence LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript)<when> _1`ocltype Sequence RHS = ->restrict(_1`literalSubscript)<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript) LHS variables = [_1]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript) LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript) RHS = ->at(_1`literalSubscript)
>>> found metafeature _1`literalSubscript for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule ( ) |-->OclAny LHS variables = []
>> Text rule ( ) |-->OclAny LHS tokens = [(, )]
>> Text rule ( ) |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`ocltype LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`ocltype LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule [ ] |-->OclAny LHS variables = []
>> Text rule [ ] |-->OclAny LHS tokens = [[, ]]
>> Text rule [ ] |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->Map<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule [ _1 ] |-->Map<when> _1`ocltype boolean LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->Map<when> _1`ocltype boolean RHS = Map<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->Map<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule [ _1 ] |-->Map<when> _1`ocltype Sequence LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->Map<when> _1`ocltype Sequence RHS = Map<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->OclAny LHS variables = [_1]
>> Text rule [ _1 ] |-->OclAny LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1) RHS = (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->() LHS variables = []
>> Text rule [ ] |-->() LHS tokens = [[, ]]
>> Text rule [ ] |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->->selectElements(_1`literalSubscript)<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule [ _1 ] |-->->selectElements(_1`literalSubscript)<when> _1`ocltype boolean LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->selectElements(_1`literalSubscript)<when> _1`ocltype boolean RHS = ->selectElements(_1`literalSubscript)<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript->collect(_ind | _ind+1))<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript->collect(_ind | _ind+1))<when> _1`ocltype Sequence LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->restrict(_1`literalSubscript->collect(_ind | _ind+1))<when> _1`ocltype Sequence RHS = ->restrict(_1`literalSubscript->collect(_ind | _ind+1))<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript+1) LHS variables = [_1]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript+1) LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->at(_1`literalSubscript+1) RHS = ->at(_1`literalSubscript+1)
>>> found metafeature _1`literalSubscript for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule ( ) |-->OclAny LHS variables = []
>> Text rule ( ) |-->OclAny LHS tokens = [(, )]
>> Text rule ( ) |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`ocltype LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`ocltype LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule [ ] |-->OclAny LHS variables = []
>> Text rule [ ] |-->OclAny LHS tokens = [[, ]]
>> Text rule [ ] |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype boolean LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype boolean RHS = Sequence<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype Sequence LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->Sequence<when> _1`ocltype Sequence RHS = Sequence<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->OclAny LHS variables = [_1]
>> Text rule [ _1 ] |-->OclAny LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->() LHS variables = []
>> Text rule ( ) |-->() LHS tokens = [(, )]
>> Text rule ( ) |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->(_1) LHS variables = [_1]
>> Text rule ( _1 ) |-->(_1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->(_1) RHS = (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->() LHS variables = []
>> Text rule [ ] |-->() LHS tokens = [[, ]]
>> Text rule [ ] |-->() RHS = ()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1 LHS variables = [_1]
>> Text rule [ _1 ] |-->_1 LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`first LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`first LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`first RHS = _1`first
>>> found metafeature _1`first for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`first]
>> Text rule [ ] |--> LHS variables = []
>> Text rule [ ] |--> LHS tokens = [[, ]]
>> Text rule [ ] |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`first LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`first LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`first RHS = _1`first
>>> found metafeature _1`first for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`first]
>> Text rule _1 |-->_1`firstArg LHS variables = [_1]
>> Text rule _1 |-->_1`firstArg LHS tokens = [_1]
>> Text rule _1 |-->_1`firstArg RHS = _1`firstArg
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`third LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`third LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`third RHS = _1`third
>>> found metafeature _1`third for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`third]
>> Text rule [ ] |--> LHS variables = []
>> Text rule [ ] |--> LHS tokens = [[, ]]
>> Text rule [ ] |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`third LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`third LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`third RHS = _1`third
>>> found metafeature _1`third for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`third]
>> Text rule _1 |-->_1`secondArg LHS variables = [_1]
>> Text rule _1 |-->_1`secondArg LHS tokens = [_1]
>> Text rule _1 |-->_1`secondArg RHS = _1`secondArg
>>> found metafeature _1`secondArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`secondArg]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`fifth LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`fifth LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`fifth RHS = _1`fifth
>>> found metafeature _1`fifth for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`fifth]
>> Text rule [ ] |--> LHS variables = []
>> Text rule [ ] |--> LHS tokens = [[, ]]
>> Text rule [ ] |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`fifth LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`fifth LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`fifth RHS = _1`fifth
>>> found metafeature _1`fifth for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`fifth]
>> Text rule _1 |-->_1`thirdArg LHS variables = [_1]
>> Text rule _1 |-->_1`thirdArg LHS tokens = [_1]
>> Text rule _1 |-->_1`thirdArg RHS = _1`thirdArg
>>> found metafeature _1`thirdArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`thirdArg]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`lastArg LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`lastArg LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`lastArg RHS = _1`lastArg
>>> found metafeature _1`lastArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`lastArg]
>> Text rule [ ] |--> LHS variables = []
>> Text rule [ ] |--> LHS tokens = [[, ]]
>> Text rule [ ] |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 , _2 |-->_2`argValue LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->_2`argValue LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->_2`argValue RHS = _2`argValue
>>> found metafeature _2`argValue for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`argValue]
>> Text rule _1 , _* |-->_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->_1`argValue LHS variables = [_1]
>> Text rule _1 |-->_1`argValue LHS tokens = [_1]
>> Text rule _1 |-->_1`argValue RHS = _1`argValue
>>> found metafeature _1`argValue for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argValue]
>> Text rule _1 = _2 |-->_2 LHS variables = [_1, _2]
>> Text rule _1 = _2 |-->_2 LHS tokens = [_1, =, _2]
>> Text rule _1 = _2 |-->_2 RHS = _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 _3 |-->_3`firstArg LHS variables = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_3`firstArg LHS tokens = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_3`firstArg RHS = _3`firstArg
>>> found metafeature _3`firstArg for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`firstArg]
>> Text rule _1 _2 _3 |-->_3`secondArg LHS variables = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_3`secondArg LHS tokens = [_1, _2, _3]
>> Text rule _1 _2 _3 |-->_3`secondArg RHS = _3`secondArg
>>> found metafeature _3`secondArg for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`secondArg]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->->union(Set{_1}->unionAll()) LHS variables = [_1]
>> Text rule ( _1 ) |-->->union(Set{_1}->unionAll()) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->->union(Set{_1}->unionAll()) RHS = ->union(Set{_1}->unionAll())
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->Set{} LHS variables = []
>> Text rule [ ] |-->Set{} LHS tokens = [[, ]]
>> Text rule [ ] |-->Set{} RHS = Set{}
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->->union(Set{_1}->unionAll()) LHS variables = [_1]
>> Text rule [ _1 ] |-->->union(Set{_1}->unionAll()) LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->union(Set{_1}->unionAll()) RHS = ->union(Set{_1}->unionAll())
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->->last() LHS variables = []
>> Text rule ( ) |-->->last() LHS tokens = [(, )]
>> Text rule ( ) |-->->last() RHS = ->last()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->->at(_1`firstArg+1) LHS variables = [_1]
>> Text rule ( _1 ) |-->->at(_1`firstArg+1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->->at(_1`firstArg+1) RHS = ->at(_1`firstArg+1)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule [ ] |-->->last() LHS variables = []
>> Text rule [ ] |-->->last() LHS tokens = [[, ]]
>> Text rule [ ] |-->->last() RHS = ->last()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->->at(_1`firstArg+1) LHS variables = [_1]
>> Text rule [ _1 ] |-->->at(_1`firstArg+1) LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->at(_1`firstArg+1) RHS = ->at(_1`firstArg+1)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule ( ) |-->->front() LHS variables = []
>> Text rule ( ) |-->->front() LHS tokens = [(, )]
>> Text rule ( ) |-->->front() RHS = ->front()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->->excludingAt(_1+1) LHS variables = [_1]
>> Text rule ( _1 ) |-->->excludingAt(_1+1) LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->->excludingAt(_1+1) RHS = ->excludingAt(_1+1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->->front() LHS variables = []
>> Text rule [ ] |-->->front() LHS tokens = [[, ]]
>> Text rule [ ] |-->->front() RHS = ->front()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->->excludingAt(_1`firstArg+1) LHS variables = [_1]
>> Text rule [ _1 ] |-->->excludingAt(_1`firstArg+1) LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->->excludingAt(_1`firstArg+1) RHS = ->excludingAt(_1`firstArg+1)
>>> found metafeature _1`firstArg for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`firstArg]
>> Text rule ( ) |-->->first() LHS variables = []
>> Text rule ( ) |-->->first() LHS tokens = [(, )]
>> Text rule ( ) |-->->first() RHS = ->first()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ ] |-->->first() LHS variables = []
>> Text rule [ ] |-->->first() LHS tokens = [[, ]]
>> Text rule [ ] |-->->first() RHS = ->first()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( ) |-->->tail() LHS variables = []
>> Text rule ( ) |-->->tail() LHS tokens = [(, )]
>> Text rule ( ) |-->->tail() RHS = ->tail()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ ] |-->->tail() LHS variables = []
>> Text rule [ ] |-->->tail() LHS tokens = [[, ]]
>> Text rule [ ] |-->->tail() RHS = ->tail()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`createTaskArglist LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`createTaskArglist LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`createTaskArglist RHS = _1`createTaskArglist
>>> found metafeature _1`createTaskArglist for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArglist]
>> Text rule [ ] |--> LHS variables = []
>> Text rule [ ] |--> LHS tokens = [[, ]]
>> Text rule [ ] |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1 LHS variables = [_1]
>> Text rule [ _1 ] |-->_1 LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`createTaskArgument LHS variables = [_1]
>> Text rule _1 |-->_1`createTaskArgument LHS tokens = [_1]
>> Text rule _1 |-->_1`createTaskArgument RHS = _1`createTaskArgument
>>> found metafeature _1`createTaskArgument for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArgument]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 test RHS = _1`createTaskArgument<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`createTaskArgument for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArgument]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 logical_test RHS = _1`createTaskArgument<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`createTaskArgument for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArgument]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 comparison RHS = _1`createTaskArgument<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`createTaskArgument for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArgument]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`createTaskArgument<when> _1 expr RHS = _1`createTaskArgument<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`createTaskArgument for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`createTaskArgument]
>> Text rule _1 _2 |-->Async$_1.newAsync$_1_2 LHS variables = [_1, _2]
>> Text rule _1 _2 |-->Async$_1.newAsync$_1_2 LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->Async$_1.newAsync$_1_2 RHS = Async$_1.newAsync$_1_2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->true<when> _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->true<when> _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->true<when> _2 trailer RHS = true<when> _2 trailer
+++ Condition lexicals:: [_2, trailer]
>***> Rule with condition: [_2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`hasTrailer<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 comparison RHS = _1`hasTrailer<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->_1`hasTrailer<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 logical_test RHS = _1`hasTrailer<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->_1`hasTrailer<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 test RHS = _1`hasTrailer<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist RHS = _1`hasTrailer<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist_star_expr LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist_star_expr LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 testlist_star_expr RHS = _1`hasTrailer<when> _1 testlist_star_expr
+++ Condition lexicals:: [_1, testlist_star_expr]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 testlist_star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->_1`hasTrailer<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`hasTrailer<when> _1 expr RHS = _1`hasTrailer<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`hasTrailer for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasTrailer]
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1, _*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1, _*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1, _*`recurse RHS = _1, _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule ( ) |--> LHS variables = []
>> Text rule ( ) |--> LHS tokens = [(, )]
>> Text rule ( ) |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`rangeArguments LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`rangeArguments LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`rangeArguments RHS = _1`rangeArguments
>>> found metafeature _1`rangeArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`rangeArguments]
>> Text rule _1 |-->Integer.subrange(0, _1-1) LHS variables = [_1]
>> Text rule _1 |-->Integer.subrange(0, _1-1) LHS tokens = [_1]
>> Text rule _1 |-->Integer.subrange(0, _1-1) RHS = Integer.subrange(0, _1-1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 |-->Integer.subrange(_1, _2-1) LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->Integer.subrange(_1, _2-1) LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->Integer.subrange(_1, _2-1) RHS = Integer.subrange(_1, _2-1)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , -1 |-->Integer.subrange(_2 + 1, _1)->reverse() LHS variables = [_1, _2]
>> Text rule _1 , _2 , -1 |-->Integer.subrange(_2 + 1, _1)->reverse() LHS tokens = [_1, ,, _2, ,, -1]
>> Text rule _1 , _2 , -1 |-->Integer.subrange(_2 + 1, _1)->reverse() RHS = Integer.subrange(_2 + 1, _1)->reverse()
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 , _3 |-->Integer.subrange(_1, _2-1)->select( $x | ($x - _1) mod _3 = 0 ) LHS variables = [_1, _2, _3]
>> Text rule _1 , _2 , _3 |-->Integer.subrange(_1, _2-1)->select( $x | ($x - _1) mod _3 = 0 ) LHS tokens = [_1, ,, _2, ,, _3]
>> Text rule _1 , _2 , _3 |-->Integer.subrange(_1, _2-1)->select( $x | ($x - _1) mod _3 = 0 ) RHS = Integer.subrange(_1, _2-1)->select( $x | ($x - _1) mod _3 = 0 )
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`sortedArguments LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`sortedArguments LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`sortedArguments RHS = _1`sortedArguments
>>> found metafeature _1`sortedArguments for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sortedArguments]
>> Text rule _1 |-->_1->keys()->sort()<when> _1 Map LHS variables = [_1]
>> Text rule _1 |-->_1->keys()->sort()<when> _1 Map LHS tokens = [_1]
>> Text rule _1 |-->_1->keys()->sort()<when> _1 Map RHS = _1->keys()->sort()<when> _1 Map
+++ Condition lexicals:: [_1, Map]
>***> Rule with condition: [_1 Map]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1->sort() LHS variables = [_1]
>> Text rule _1 |-->_1->sort() LHS tokens = [_1]
>> Text rule _1 |-->_1->sort() RHS = _1->sort()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _2 |-->_1->sortedBy($x | _2`sortedKeySpecification) LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->_1->sortedBy($x | _2`sortedKeySpecification) LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->_1->sortedBy($x | _2`sortedKeySpecification) RHS = _1->sortedBy($x | _2`sortedKeySpecification)
>>> found metafeature _2`sortedKeySpecification for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`sortedKeySpecification]
>> Text rule _1 , _2 , _3 |-->_1->sortedBy($x | _2`sortedKeySpecification) LHS variables = [_1, _2, _3]
>> Text rule _1 , _2 , _3 |-->_1->sortedBy($x | _2`sortedKeySpecification) LHS tokens = [_1, ,, _2, ,, _3]
>> Text rule _1 , _2 , _3 |-->_1->sortedBy($x | _2`sortedKeySpecification) RHS = _1->sortedBy($x | _2`sortedKeySpecification)
>>> found metafeature _2`sortedKeySpecification for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`sortedKeySpecification]
>> Text rule key = _1 |-->(_1)->apply($x) LHS variables = [_1]
>> Text rule key = _1 |-->(_1)->apply($x) LHS tokens = [key, =, _1]
>> Text rule key = _1 |-->(_1)->apply($x) RHS = (_1)->apply($x)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 test RHS = _1`sortedKeySpecification<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`sortedKeySpecification for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sortedKeySpecification]
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`sortedKeySpecification<when> _1 logical_test RHS = _1`sortedKeySpecification<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`sortedKeySpecification for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sortedKeySpecification]
>> Text rule _1 |-->$x LHS variables = [_1]
>> Text rule _1 |-->$x LHS tokens = [_1]
>> Text rule _1 |-->$x RHS = $x
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule 0 |-->->first() LHS variables = []
>> Text rule 0 |-->->first() LHS tokens = [0]
>> Text rule 0 |-->->first() RHS = ->first()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 , _2 |-->_2`reversedAccess_1`reversedAccess LHS variables = [_1, _2]
>> Text rule _1 , _2 |-->_2`reversedAccess_1`reversedAccess LHS tokens = [_1, ,, _2]
>> Text rule _1 , _2 |-->_2`reversedAccess_1`reversedAccess RHS = _2`reversedAccess_1`reversedAccess
>>> found metafeature _1`reversedAccess for _1`
>>> found metafeature _2`reversedAccess for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`reversedAccess, _2`reversedAccess]
>> Text rule [ _1 ] |-->_1`reversedAccess<when> _1 subscriptlist LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`reversedAccess<when> _1 subscriptlist LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`reversedAccess<when> _1 subscriptlist RHS = _1`reversedAccess<when> _1 subscriptlist
+++ Condition lexicals:: [_1, subscriptlist]
>>> found metafeature _1`reversedAccess for _1`
>***> Rule with condition: [_1 subscriptlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reversedAccess]
>> Text rule _1 |-->_1`reversedAccess<when> _1 subscriptlist LHS variables = [_1]
>> Text rule _1 |-->_1`reversedAccess<when> _1 subscriptlist LHS tokens = [_1]
>> Text rule _1 |-->_1`reversedAccess<when> _1 subscriptlist RHS = _1`reversedAccess<when> _1 subscriptlist
+++ Condition lexicals:: [_1, subscriptlist]
>>> found metafeature _1`reversedAccess for _1`
>***> Rule with condition: [_1 subscriptlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reversedAccess]
>> Text rule _1 |-->->at(_1)<when> _1 String LHS variables = [_1]
>> Text rule _1 |-->->at(_1)<when> _1 String LHS tokens = [_1]
>> Text rule _1 |-->->at(_1)<when> _1 String RHS = ->at(_1)<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->->at(_1 + 1) LHS variables = [_1]
>> Text rule _1 |-->->at(_1 + 1) LHS tokens = [_1]
>> Text rule _1 |-->->at(_1 + 1) RHS = ->at(_1 + 1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule : |--> LHS variables = []
>> Text rule : |--> LHS tokens = [:]
>> Text rule : |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule : , _1 |-->->collect( _r | _r_1 ) LHS variables = [_1]
>> Text rule : , _1 |-->->collect( _r | _r_1 ) LHS tokens = [:, ,, _1]
>> Text rule : , _1 |-->->collect( _r | _r_1 ) RHS = ->collect( _r | _r_1 )
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , : |-->_1 LHS variables = [_1]
>> Text rule _1 , : |-->_1 LHS tokens = [_1, ,, :]
>> Text rule _1 , : |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_1_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_1_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_1_*`recurse RHS = _1_*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule ... |--> LHS variables = []
>> Text rule ... |--> LHS tokens = [...]
>> Text rule ... |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule 0 |-->->first() LHS variables = []
>> Text rule 0 |-->->first() LHS tokens = [0]
>> Text rule 0 |-->->first() RHS = ->first()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule -1 |-->->last() LHS variables = []
>> Text rule -1 |-->->last() LHS tokens = [-1]
>> Text rule -1 |-->->last() RHS = ->last()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule -2 |-->->front()->last() LHS variables = []
>> Text rule -2 |-->->front()->last() LHS tokens = [-2]
>> Text rule -2 |-->->front()->last() RHS = ->front()->last()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule -3 |-->->front()->front()->last() LHS variables = []
>> Text rule -3 |-->->front()->front()->last() LHS tokens = [-3]
>> Text rule -3 |-->->front()->front()->last() RHS = ->front()->front()->last()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->->reverse()->at(-(_1))<when> _1 matches -.* LHS variables = [_1]
>> Text rule _1 |-->->reverse()->at(-(_1))<when> _1 matches -.* LHS tokens = [_1]
>> Text rule _1 |-->->reverse()->at(-(_1))<when> _1 matches -.* RHS = ->reverse()->at(-(_1))<when> _1 matches -.*
+++ Condition lexicals:: [_1, matches, -, ., *]
>***> Rule with condition: [_1 matches -.*]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->.subrange(_1+1, _2)<when> _2 test LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->.subrange(_1+1, _2)<when> _2 test LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->.subrange(_1+1, _2)<when> _2 test RHS = .subrange(_1+1, _2)<when> _2 test
+++ Condition lexicals:: [_2, test]
>***> Rule with condition: [_2 test]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule : -1 |-->->front() LHS variables = []
>> Text rule : -1 |-->->front() LHS tokens = [:, -1]
>> Text rule : -1 |-->->front() RHS = ->front()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule : -2 |-->->front()->front() LHS variables = []
>> Text rule : -2 |-->->front()->front() LHS tokens = [:, -2]
>> Text rule : -2 |-->->front()->front() RHS = ->front()->front()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule : -3 |-->->front()->front()->front() LHS variables = []
>> Text rule : -3 |-->->front()->front()->front() LHS tokens = [:, -3]
>> Text rule : -3 |-->->front()->front()->front() RHS = ->front()->front()->front()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule : _1 |-->.subrange(1,_1)<when> _1 test LHS variables = [_1]
>> Text rule : _1 |-->.subrange(1,_1)<when> _1 test LHS tokens = [:, _1]
>> Text rule : _1 |-->.subrange(1,_1)<when> _1 test RHS = .subrange(1,_1)<when> _1 test
+++ Condition lexicals:: [_1, test]
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule 1 : |-->->tail() LHS variables = []
>> Text rule 1 : |-->->tail() LHS tokens = [1, :]
>> Text rule 1 : |-->->tail() RHS = ->tail()
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 : |-->.subrange(_1+1)<when> _1 test LHS variables = [_1]
>> Text rule _1 : |-->.subrange(_1+1)<when> _1 test LHS tokens = [_1, :]
>> Text rule _1 : |-->.subrange(_1+1)<when> _1 test RHS = .subrange(_1+1)<when> _1 test
+++ Condition lexicals:: [_1, test]
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->->at(_1)<when> _1 String LHS variables = [_1]
>> Text rule _1 |-->->at(_1)<when> _1 String LHS tokens = [_1]
>> Text rule _1 |-->->at(_1)<when> _1 String RHS = ->at(_1)<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->->selectRows(_1)<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule _1 |-->->selectRows(_1)<when> _1`ocltype boolean LHS tokens = [_1]
>> Text rule _1 |-->->selectRows(_1)<when> _1`ocltype boolean RHS = ->selectRows(_1)<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->->restrict(_1)<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule _1 |-->->restrict(_1)<when> _1`ocltype Sequence LHS tokens = [_1]
>> Text rule _1 |-->->restrict(_1)<when> _1`ocltype Sequence RHS = ->restrict(_1)<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->[_1+1] LHS variables = [_1]
>> Text rule _1 |-->[_1+1] LHS tokens = [_1]
>> Text rule _1 |-->[_1+1] RHS = [_1+1]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ... |--> LHS variables = []
>> Text rule ... |--> LHS tokens = [...]
>> Text rule ... |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule 0 |-->1 LHS variables = []
>> Text rule 0 |-->1 LHS tokens = [0]
>> Text rule 0 |-->1 RHS = 1
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule -1 |-->-1 LHS variables = []
>> Text rule -1 |-->-1 LHS tokens = [-1]
>> Text rule -1 |-->-1 RHS = -1
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule -2 |-->-2 LHS variables = []
>> Text rule -2 |-->-2 LHS tokens = [-2]
>> Text rule -2 |-->-2 RHS = -2
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<when> _1 matches -.* LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 matches -.* LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 matches -.* RHS = _1<when> _1 matches -.*
+++ Condition lexicals:: [_1, matches, -, ., *]
>***> Rule with condition: [_1 matches -.*]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 : _2 |-->Integer.subrange(_1+1, _2)<when> _2 test LHS variables = [_1, _2]
>> Text rule _1 : _2 |-->Integer.subrange(_1+1, _2)<when> _2 test LHS tokens = [_1, :, _2]
>> Text rule _1 : _2 |-->Integer.subrange(_1+1, _2)<when> _2 test RHS = Integer.subrange(_1+1, _2)<when> _2 test
+++ Condition lexicals:: [_2, test]
>***> Rule with condition: [_2 test]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule : -1 |--> LHS variables = []
>> Text rule : -1 |--> LHS tokens = [:, -1]
>> Text rule : -1 |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule : -2 |--> LHS variables = []
>> Text rule : -2 |--> LHS tokens = [:, -2]
>> Text rule : -2 |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule : _1 |-->Integer.subrange(1,_1)<when> _1 test LHS variables = [_1]
>> Text rule : _1 |-->Integer.subrange(1,_1)<when> _1 test LHS tokens = [:, _1]
>> Text rule : _1 |-->Integer.subrange(1,_1)<when> _1 test RHS = Integer.subrange(1,_1)<when> _1 test
+++ Condition lexicals:: [_1, test]
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule 1 : |--> LHS variables = []
>> Text rule 1 : |--> LHS tokens = [1, :]
>> Text rule 1 : |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 : |--><when> _1 test LHS variables = [_1]
>> Text rule _1 : |--><when> _1 test LHS tokens = [_1, :]
>> Text rule _1 : |--><when> _1 test RHS = <when> _1 test
+++ Condition lexicals:: [_1, test]
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscriptlist LHS variables = [_1]
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscriptlist LHS tokens = [_1]
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscriptlist RHS = _1`literalSubscript<when> _1 subscriptlist
+++ Condition lexicals:: [_1, subscriptlist]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1 subscriptlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscript LHS variables = [_1]
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscript LHS tokens = [_1]
>> Text rule _1 |-->_1`literalSubscript<when> _1 subscript RHS = _1`literalSubscript<when> _1 subscript
+++ Condition lexicals:: [_1, subscript]
>>> found metafeature _1`literalSubscript for _1`
>***> Rule with condition: [_1 subscript]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`literalSubscript]
>> Text rule _1 |-->_1<when> _1 String LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 String LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 String RHS = _1<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<when> _1`ocltype boolean LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1`ocltype boolean LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1`ocltype boolean RHS = _1<when> _1`ocltype boolean
+++ Condition lexicals:: [_1, `, ocltype, boolean]
>***> Rule with condition: [_1`ocltype boolean]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<when> _1`ocltype Sequence LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1`ocltype Sequence LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1`ocltype Sequence RHS = _1<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1+1 LHS variables = [_1]
>> Text rule _1 |-->_1+1 LHS tokens = [_1]
>> Text rule _1 |-->_1+1 RHS = _1+1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule : _1 |--> LHS variables = [_1]
>> Text rule : _1 |--> LHS tokens = [:, _1]
>> Text rule : _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule yield |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return null LHS variables = []
>> Text rule yield |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return null LHS tokens = [yield]
>> Text rule yield |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return null RHS =     if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return null
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule yield _1 |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return _1 LHS variables = [_1]
>> Text rule yield _1 |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return _1 LHS tokens = [yield, _1]
>> Text rule yield _1 |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return _1 RHS =     if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule from _1 |-->_1 LHS variables = [_1]
>> Text rule from _1 |-->_1 LHS tokens = [from, _1]
>> Text rule from _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 |-->    if _1 then (\n  _2\n    ) else skip LHS variables = [_1, _2]
>> Text rule if _1 : _2 |-->    if _1 then (\n  _2\n    ) else skip LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |-->    if _1 then (\n  _2\n    ) else skip RHS =     if _1 then (\n  _2\n    ) else skip
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3<when> _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3<when> _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3<when> _3 else_clause RHS =     if _1 then  (\n  _2\n    )\n_3<when> _3 else_clause
+++ Condition lexicals:: [_3, else_clause]
>***> Rule with condition: [_3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3 else skip)<when> _3 elif_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3 else skip)<when> _3 elif_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->    if _1 then  (\n  _2\n    )\n_3 else skip)<when> _3 elif_clause RHS =     if _1 then  (\n  _2\n    )\n_3 else skip)<when> _3 elif_clause
+++ Condition lexicals:: [_3, elif_clause]
>***> Rule with condition: [_3 elif_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*    else skip_*`elifCloseBrackets<when> _* all elif_clause LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*    else skip_*`elifCloseBrackets<when> _* all elif_clause LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*    else skip_*`elifCloseBrackets<when> _* all elif_clause RHS =     if _1 then  (\n  _2\n    )\n_*    else skip_*`elifCloseBrackets<when> _* all elif_clause
+++ Condition lexicals:: [_, *, all, elif_clause]
>>> found metafeature _*`elifCloseBrackets for _*`
>***> Rule with condition: [_* all elif_clause]
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`elifCloseBrackets]
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*_*`elifCloseBrackets LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*_*`elifCloseBrackets LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->    if _1 then  (\n  _2\n    )\n_*_*`elifCloseBrackets RHS =     if _1 then  (\n  _2\n    )\n_*_*`elifCloseBrackets
>>> found metafeature _*`elifCloseBrackets for _*`
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`elifCloseBrackets]
>> Text rule while _1 : _2 |-->    while _1 do (_2) LHS variables = [_1, _2]
>> Text rule while _1 : _2 |-->    while _1 do (_2) LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |-->    while _1 do (_2) RHS =     while _1 do (_2)
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->characters() do (_3)<when> _2 String LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->characters() do (_3)<when> _2 String LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->characters() do (_3)<when> _2 String RHS =     for _1 : _2->characters() do (_3)<when> _2 String
+++ Condition lexicals:: [_2, String]
>***> Rule with condition: [_2 String]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->keys() do (_3)<when> _2 Map LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->keys() do (_3)<when> _2 Map LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2->keys() do (_3)<when> _2 Map RHS =     for _1 : _2->keys() do (_3)<when> _2 Map
+++ Condition lexicals:: [_2, Map]
>***> Rule with condition: [_2 Map]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 : _3 |-->    for _tuple : _2 do (var _indx : int := 1;\n_1`tupleDeclarations  _3)<when> _1 multiple LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->    for _tuple : _2 do (var _indx : int := 1;\n_1`tupleDeclarations  _3)<when> _1 multiple LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->    for _tuple : _2 do (var _indx : int := 1;\n_1`tupleDeclarations  _3)<when> _1 multiple RHS =     for _tuple : _2 do (var _indx : int := 1;\n_1`tupleDeclarations  _3)<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`tupleDeclarations for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_1`tupleDeclarations]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2 do (_3) LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2 do (_3) LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->    for _1 : _2 do (_3) RHS =     for _1 : _2 do (_3)
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule try : _1 |-->    try (_1) LHS variables = [_1]
>> Text rule try : _1 |-->    try (_1) LHS tokens = [try, :, _1]
>> Text rule try : _1 |-->    try (_1) RHS =     try (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule try : _1 _* |-->    try (_1)\n_* LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->    try (_1)\n_* LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->    try (_1)\n_* RHS =     try (_1)\n_*
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule with _1 : _2 |-->    try (_1_2)\n    catch (_e : OclException) do skip LHS variables = [_1, _2]
>> Text rule with _1 : _2 |-->    try (_1_2)\n    catch (_e : OclException) do skip LHS tokens = [with, _1, :, _2]
>> Text rule with _1 : _2 |-->    try (_1_2)\n    catch (_e : OclException) do skip RHS =     try (_1_2)\n    catch (_e : OclException) do skip
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule with _1 , _2 : _3 |-->    try (_1    _2_3)\n    catch (_e : OclException) do skip LHS variables = [_1, _2, _3]
>> Text rule with _1 , _2 : _3 |-->    try (_1    _2_3)\n    catch (_e : OclException) do skip LHS tokens = [with, _1, ,, _2, :, _3]
>> Text rule with _1 , _2 : _3 |-->    try (_1    _2_3)\n    catch (_e : OclException) do skip RHS =     try (_1    _2_3)\n    catch (_e : OclException) do skip
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _1 |-->    skip LHS variables = [_1]
>> Text rule _1 |-->    skip LHS tokens = [_1]
>> Text rule _1 |-->    skip RHS =     skip
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_1_*`followingStatement LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1_*`followingStatement LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1_*`followingStatement RHS = _1_*`followingStatement
>>> found metafeature _*`followingStatement for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`followingStatement]
>> Text rule _1 |--> ;\n_1 LHS variables = [_1]
>> Text rule _1 |--> ;\n_1 LHS tokens = [_1]
>> Text rule _1 |--> ;\n_1 RHS =  ;\n_1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule elif _1 : _2 |-->    else (if _1 then\n   (\n  _2    \n)\n LHS variables = [_1, _2]
>> Text rule elif _1 : _2 |-->    else (if _1 then\n   (\n  _2    \n)\n LHS tokens = [elif, _1, :, _2]
>> Text rule elif _1 : _2 |-->    else (if _1 then\n   (\n  _2    \n)\n RHS =     else (if _1 then\n   (\n  _2    \n)\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule else : _1 |-->    else (\n  _1\n      ) LHS variables = [_1]
>> Text rule else : _1 |-->    else (\n  _1\n      ) LHS tokens = [else, :, _1]
>> Text rule else : _1 |-->    else (\n  _1\n      ) RHS =     else (\n  _1\n      )
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule elif _1 : _2 |-->    )\n LHS variables = [_1, _2]
>> Text rule elif _1 : _2 |-->    )\n LHS tokens = [elif, _1, :, _2]
>> Text rule elif _1 : _2 |-->    )\n RHS =     )\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule else : _1 |--> LHS variables = [_1]
>> Text rule else : _1 |--> LHS tokens = [else, :, _1]
>> Text rule else : _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule except : _1 |-->     catch (_e : OclException) do (_1)\n LHS variables = [_1]
>> Text rule except : _1 |-->     catch (_e : OclException) do (_1)\n LHS tokens = [except, :, _1]
>> Text rule except : _1 |-->     catch (_e : OclException) do (_1)\n RHS =      catch (_e : OclException) do (_1)\n
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule except _1 as _2 : _3 |-->    catch (_2 : _1) do (_3)\n LHS variables = [_1, _2, _3]
>> Text rule except _1 as _2 : _3 |-->    catch (_2 : _1) do (_3)\n LHS tokens = [except, _1, as, _2, :, _3]
>> Text rule except _1 as _2 : _3 |-->    catch (_2 : _1) do (_3)\n RHS =     catch (_2 : _1) do (_3)\n
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule except _1 , _2 : _3 |-->    catch (_2 : _1) do (_3)\n LHS variables = [_1, _2, _3]
>> Text rule except _1 , _2 : _3 |-->    catch (_2 : _1) do (_3)\n LHS tokens = [except, _1, ,, _2, :, _3]
>> Text rule except _1 , _2 : _3 |-->    catch (_2 : _1) do (_3)\n RHS =     catch (_2 : _1) do (_3)\n
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule finally : _1 |-->    finally (_1) LHS variables = [_1]
>> Text rule finally : _1 |-->    finally (_1) LHS tokens = [finally, :, _1]
>> Text rule finally : _1 |-->    finally (_1) RHS =     finally (_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 as _2 |-->var _2 : _1`ocltype := _1;\n LHS variables = [_1, _2]
>> Text rule _1 as _2 |-->var _2 : _1`ocltype := _1;\n LHS tokens = [_1, as, _2]
>> Text rule _1 as _2 |-->var _2 : _1`ocltype := _1;\n RHS = var _2 : _1`ocltype := _1;\n
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule ( _* ) |-->_*`with_item LHS variables = [_*]
>> Text rule ( _* ) |-->_*`with_item LHS tokens = [(, _*, )]
>> Text rule ( _* ) |-->_*`with_item RHS = _*`with_item
>>> found metafeature _*`with for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`with]
>> Text rule _1 |-->_1 LHS variables = [_1]
>> Text rule _1 |-->_1 LHS tokens = [_1]
>> Text rule _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 <EOF> |-->_1 LHS variables = [_1]
>> Text rule _1 <EOF> |-->_1 LHS tokens = [_1, <EOF>]
>> Text rule _1 <EOF> |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->_* LHS variables = [_*]
>> Text rule _* |-->_* LHS tokens = [_*]
>> Text rule _* |-->_* RHS = _*
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |--><when> _1`defined true LHS variables = [_1]
>> Text rule _1 |--><when> _1`defined true LHS tokens = [_1]
>> Text rule _1 |--><when> _1`defined true RHS = <when> _1`defined true
+++ Condition lexicals:: [_1, `, defined, true]
>***> Rule with condition: [_1`defined true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->    var _1 : OclAny := null;\n LHS variables = [_1]
>> Text rule _1 |-->    var _1 : OclAny := null;\n LHS tokens = [_1]
>> Text rule _1 |-->    var _1 : OclAny := null;\n RHS =     var _1 : OclAny := null;\n
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_*`recurse<when> _1`defined true LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_*`recurse<when> _1`defined true LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_*`recurse<when> _1`defined true RHS = _*`recurse<when> _1`defined true
+++ Condition lexicals:: [_1, `, defined, true]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1`defined true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 , _* |-->    var _1 : OclAny := null;\n_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->    var _1 : OclAny := null;\n_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->    var _1 : OclAny := null;\n_*`recurse RHS =     var _1 : OclAny := null;\n_*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true RHS = _1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true
+++ Condition lexicals:: [_1, multiple, ,, _2, `, isMultipleAssignPart, true]
>>> found metafeature _1`declareIfNecessary for _1`
>>> found metafeature _2`second for _2`
>***> Rule with condition: [_1 multiple, _2`isMultipleAssignPart true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`declareIfNecessary, _2`second]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple RHS = _1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>>> found metafeature _1`declareIfNecessary for _1`
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`declareIfNecessary]
>> Text rule _1 _2 |-->    var _1 _2<when> _2`colonAssign true <action> _1`defined true LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    var _1 _2<when> _2`colonAssign true <action> _1`defined true LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    var _1 _2<when> _2`colonAssign true <action> _1`defined true RHS =     var _1 _2<when> _2`colonAssign true <action> _1`defined true
+++ Action lexicals:: [_1, `, defined, true]
>> Rule actions are:  _1`defined true [_1`defined true]
+++ Condition lexicals:: [_2, `, colonAssign, true]
>> Global variables: []
>***> Rule with condition: [_2`colonAssign true] and actions: [_1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`defined true LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`defined true LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`defined true RHS =     _1 _2<when> _2`equalAssign true, _1`defined true
+++ Condition lexicals:: [_2, `, equalAssign, true, ,, _1, `, defined, true]
>***> Rule with condition: [_2`equalAssign true, _1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* RHS =     _1 _2<when> _2`equalAssign true, _1 matches .*\..*
+++ Condition lexicals:: [_2, `, equalAssign, true, ,, _1, matches, ., *, \, .., *]
>***> Rule with condition: [_2`equalAssign true, _1 matches .*\..*]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* RHS =     _1 _2<when> _2`equalAssign true, _1 matches .*\[.*
+++ Condition lexicals:: [_2, `, equalAssign, true, ,, _1, matches, ., *, \, [, ., *]
>***> Rule with condition: [_2`equalAssign true, _1 matches .*\[.*]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true RHS =     _1 _2<when> _2`equalAssign true, _1`hasTrailer true
+++ Condition lexicals:: [_2, `, equalAssign, true, ,, _1, `, hasTrailer, true]
>***> Rule with condition: [_2`equalAssign true, _1`hasTrailer true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true <action> _1`defined true, _1 _2`ocltype LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true <action> _1`defined true, _1 _2`ocltype LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true <action> _1`defined true, _1 _2`ocltype RHS =     var _1 : _2`ocltype _2<when> _2`equalAssign true <action> _1`defined true, _1 _2`ocltype
+++ Action lexicals:: [_1, `, defined, true, ,, _1, _2, `, ocltype]
>> Rule actions are:  _1`defined true, _1 _2`ocltype [_1`defined true, _1 _2`ocltype]
+++ Condition lexicals:: [_2, `, equalAssign, true]
>>> found metafeature _2`ocltype for _2`
>> Global variables: []
>***> Rule with condition: [_2`equalAssign true] and actions: [_1`defined true, _1 _2`ocltype]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule _1 _2 |-->    _1 := _1_2<when> _2 assign_part LHS variables = [_1, _2]
>> Text rule _1 _2 |-->    _1 := _1_2<when> _2 assign_part LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->    _1 := _1_2<when> _2 assign_part RHS =     _1 := _1_2<when> _2 assign_part
+++ Condition lexicals:: [_2, assign_part]
>***> Rule with condition: [_2 assign_part]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->    execute (_1`printTrailer)->display() LHS variables = [_1]
>> Text rule print _1 |-->    execute (_1`printTrailer)->display() LHS tokens = [print, _1]
>> Text rule print _1 |-->    execute (_1`printTrailer)->display() RHS =     execute (_1`printTrailer)->display()
>>> found metafeature _1`printTrailer for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`printTrailer]
>> Text rule del _1 |-->    execute (_1)->isDeleted() LHS variables = [_1]
>> Text rule del _1 |-->    execute (_1)->isDeleted() LHS tokens = [del, _1]
>> Text rule del _1 |-->    execute (_1)->isDeleted() RHS =     execute (_1)->isDeleted()
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule pass |-->    skip LHS variables = []
>> Text rule pass |-->    skip LHS tokens = [pass]
>> Text rule pass |-->    skip RHS =     skip
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule break |-->    break LHS variables = []
>> Text rule break |-->    break LHS tokens = [break]
>> Text rule break |-->    break RHS =     break
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule continue |-->    continue LHS variables = []
>> Text rule continue |-->    continue LHS tokens = [continue]
>> Text rule continue |-->    continue RHS =     continue
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule return _1 |-->    return _1 LHS variables = [_1]
>> Text rule return _1 |-->    return _1 LHS tokens = [return, _1]
>> Text rule return _1 |-->    return _1 RHS =     return _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule return |-->    return LHS variables = []
>> Text rule return |-->    return LHS tokens = [return]
>> Text rule return |-->    return RHS =     return
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule raise _1 |-->    error _1`errorToUML LHS variables = [_1]
>> Text rule raise _1 |-->    error _1`errorToUML LHS tokens = [raise, _1]
>> Text rule raise _1 |-->    error _1`errorToUML RHS =     error _1`errorToUML
>>> found metafeature _1`errorToUML for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule raise _1 from _2 |-->    error _1`errorToUML LHS variables = [_1, _2]
>> Text rule raise _1 from _2 |-->    error _1`errorToUML LHS tokens = [raise, _1, from, _2]
>> Text rule raise _1 from _2 |-->    error _1`errorToUML RHS =     error _1`errorToUML
>>> found metafeature _1`errorToUML for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule raise _* |-->    _*`errorlist LHS variables = [_*]
>> Text rule raise _* |-->    _*`errorlist LHS tokens = [raise, _*]
>> Text rule raise _* |-->    _*`errorlist RHS =     _*`errorlist
>>> found metafeature _*`errorlist for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`errorlist]
>> Text rule import _1 |-->    skip LHS variables = [_1]
>> Text rule import _1 |-->    skip LHS tokens = [import, _1]
>> Text rule import _1 |-->    skip RHS =     skip
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule from _* |-->    skip LHS variables = [_*]
>> Text rule from _* |-->    skip LHS tokens = [from, _*]
>> Text rule from _* |-->    skip RHS =     skip
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule global _* |-->_*`assertDefined LHS variables = [_*]
>> Text rule global _* |-->_*`assertDefined LHS tokens = [global, _*]
>> Text rule global _* |-->_*`assertDefined RHS = _*`assertDefined
>>> found metafeature _*`assertDefined for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`assertDefined]
>> Text rule exec _1 |-->_0`pythonExec LHS variables = [_1]
>> Text rule exec _1 |-->_0`pythonExec LHS tokens = [exec, _1]
>> Text rule exec _1 |-->_0`pythonExec RHS = _0`pythonExec
>> These will be treated as global variables: [_0]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule exec _* |-->    execute _* LHS variables = [_*]
>> Text rule exec _* |-->    execute _* LHS tokens = [exec, _*]
>> Text rule exec _* |-->    execute _* RHS =     execute _*
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule assert _1 |-->    assert _1 do "assertion failed" LHS variables = [_1]
>> Text rule assert _1 |-->    assert _1 do "assertion failed" LHS tokens = [assert, _1]
>> Text rule assert _1 |-->    assert _1 do "assertion failed" RHS =     assert _1 do "assertion failed"
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule assert _1 , _2 |-->    assert _1 do _2 LHS variables = [_1, _2]
>> Text rule assert _1 , _2 |-->    assert _1 do _2 LHS tokens = [assert, _1, ,, _2]
>> Text rule assert _1 , _2 |-->    assert _1 do _2 RHS =     assert _1 do _2
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule nonlocal _* |-->_*`assertDefined LHS variables = [_*]
>> Text rule nonlocal _* |-->_*`assertDefined LHS tokens = [nonlocal, _*]
>> Text rule nonlocal _* |-->_*`assertDefined RHS = _*`assertDefined
>>> found metafeature _*`assertDefined for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`assertDefined]
>> Text rule _1 |-->_1<when> _1 yield_expr LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 yield_expr LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 yield_expr RHS = _1<when> _1 yield_expr
+++ Condition lexicals:: [_1, yield_expr]
>***> Rule with condition: [_1 yield_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expr LHS variables = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expr LHS tokens = [_1]
>> Text rule _1 |-->_1`updateForm<when> _1 testlist_star_expr RHS = _1`updateForm<when> _1 testlist_star_expr
+++ Condition lexicals:: [_1, testlist_star_expr]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1 testlist_star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule , |-->; LHS variables = []
>> Text rule , |-->; LHS tokens = [,]
>> Text rule , |-->; RHS = ;
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->    skip<action> _1`defined true LHS variables = [_1]
>> Text rule _1 |-->    skip<action> _1`defined true LHS tokens = [_1]
>> Text rule _1 |-->    skip<action> _1`defined true RHS =     skip<action> _1`defined true
+++ Action lexicals:: [_1, `, defined, true]
>> Rule actions are:  _1`defined true [_1`defined true]
>> Global variables: []
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->true<when> _1 multiple LHS variables = [_1]
>> Text rule = _1 |-->true<when> _1 multiple LHS tokens = [=, _1]
>> Text rule = _1 |-->true<when> _1 multiple RHS = true<when> _1 multiple
+++ Condition lexicals:: [_1, multiple]
>***> Rule with condition: [_1 multiple]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->false LHS variables = [_1]
>> Text rule = _1 |-->false LHS tokens = [=, _1]
>> Text rule = _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->false LHS variables = [_*]
>> Text rule _* |-->false LHS tokens = [_*]
>> Text rule _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->false LHS variables = [_1]
>> Text rule print _1 |-->false LHS tokens = [print, _1]
>> Text rule print _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule del _1 |-->false LHS variables = [_1]
>> Text rule del _1 |-->false LHS tokens = [del, _1]
>> Text rule del _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule pass |-->false LHS variables = []
>> Text rule pass |-->false LHS tokens = [pass]
>> Text rule pass |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule break |-->false LHS variables = []
>> Text rule break |-->false LHS tokens = [break]
>> Text rule break |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule continue |-->false LHS variables = []
>> Text rule continue |-->false LHS tokens = [continue]
>> Text rule continue |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule return _1 |-->true LHS variables = [_1]
>> Text rule return _1 |-->true LHS tokens = [return, _1]
>> Text rule return _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule return |-->false LHS variables = []
>> Text rule return |-->false LHS tokens = [return]
>> Text rule return |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule raise _1 |-->false LHS variables = [_1]
>> Text rule raise _1 |-->false LHS tokens = [raise, _1]
>> Text rule raise _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule raise _1 from _2 |-->false LHS variables = [_1, _2]
>> Text rule raise _1 from _2 |-->false LHS tokens = [raise, _1, from, _2]
>> Text rule raise _1 from _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule raise _* |-->false LHS variables = [_*]
>> Text rule raise _* |-->false LHS tokens = [raise, _*]
>> Text rule raise _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule import _1 |-->false LHS variables = [_1]
>> Text rule import _1 |-->false LHS tokens = [import, _1]
>> Text rule import _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule from _* |-->false LHS variables = [_*]
>> Text rule from _* |-->false LHS tokens = [from, _*]
>> Text rule from _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule global _* |-->false LHS variables = [_*]
>> Text rule global _* |-->false LHS tokens = [global, _*]
>> Text rule global _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule exec _1 |-->false LHS variables = [_1]
>> Text rule exec _1 |-->false LHS tokens = [exec, _1]
>> Text rule exec _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule exec _* |-->false LHS variables = [_*]
>> Text rule exec _* |-->false LHS tokens = [exec, _*]
>> Text rule exec _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule assert _1 |-->false LHS variables = [_1]
>> Text rule assert _1 |-->false LHS tokens = [assert, _1]
>> Text rule assert _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule assert _1 , _2 |-->false LHS variables = [_1, _2]
>> Text rule assert _1 , _2 |-->false LHS tokens = [assert, _1, ,, _2]
>> Text rule assert _1 , _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule nonlocal _* |-->false LHS variables = [_*]
>> Text rule nonlocal _* |-->false LHS tokens = [nonlocal, _*]
>> Text rule nonlocal _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 |-->_2`hasValueReturn LHS variables = [_1, _2]
>> Text rule if _1 : _2 |-->_2`hasValueReturn LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |-->_2`hasValueReturn RHS = _2`hasValueReturn
>>> found metafeature _2`hasValueReturn for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasValueReturn]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasValueReturn true, _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasValueReturn true, _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasValueReturn true, _3 else_clause RHS = true<when> _2`hasValueReturn true, _3 else_clause
+++ Condition lexicals:: [_2, `, hasValueReturn, true, ,, _3, else_clause]
>***> Rule with condition: [_2`hasValueReturn true, _3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasValueReturn true, _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasValueReturn true, _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasValueReturn true, _3 else_clause RHS = true<when> _3`hasValueReturn true, _3 else_clause
+++ Condition lexicals:: [_3, `, hasValueReturn, true, ,, _3, else_clause]
>***> Rule with condition: [_3`hasValueReturn true, _3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause RHS = false<when> _3 else_clause
+++ Condition lexicals:: [_3, else_clause]
>***> Rule with condition: [_3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |-->true<when> _2`hasValueReturn true LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->true<when> _2`hasValueReturn true LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->true<when> _2`hasValueReturn true RHS = true<when> _2`hasValueReturn true
+++ Condition lexicals:: [_2, `, hasValueReturn, true]
>***> Rule with condition: [_2`hasValueReturn true]
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |-->_*`recurse LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->_*`recurse LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule while _1 : _2 |-->_2`hasValueReturn LHS variables = [_1, _2]
>> Text rule while _1 : _2 |-->_2`hasValueReturn LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |-->_2`hasValueReturn RHS = _2`hasValueReturn
>>> found metafeature _2`hasValueReturn for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasValueReturn]
>> Text rule for _1 in _2 : _3 |-->_3`hasValueReturn LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->_3`hasValueReturn LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->_3`hasValueReturn RHS = _3`hasValueReturn
>>> found metafeature _3`hasValueReturn for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasValueReturn]
>> Text rule try : _1 |-->_1`hasValueReturn LHS variables = [_1]
>> Text rule try : _1 |-->_1`hasValueReturn LHS tokens = [try, :, _1]
>> Text rule try : _1 |-->_1`hasValueReturn RHS = _1`hasValueReturn
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule try : _1 _* |-->true<when> _1`hasValueReturn true LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->true<when> _1`hasValueReturn true LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->true<when> _1`hasValueReturn true RHS = true<when> _1`hasValueReturn true
+++ Condition lexicals:: [_1, `, hasValueReturn, true]
>***> Rule with condition: [_1`hasValueReturn true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule try : _1 _* |-->_*`recurse LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->_*`recurse LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule with _1 : _2 |-->_2`hasValueReturn LHS variables = [_1, _2]
>> Text rule with _1 : _2 |-->_2`hasValueReturn LHS tokens = [with, _1, :, _2]
>> Text rule with _1 : _2 |-->_2`hasValueReturn RHS = _2`hasValueReturn
>>> found metafeature _2`hasValueReturn for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasValueReturn]
>> Text rule elif _1 : _2 |-->_2`hasValueReturn LHS variables = [_1, _2]
>> Text rule elif _1 : _2 |-->_2`hasValueReturn LHS tokens = [elif, _1, :, _2]
>> Text rule elif _1 : _2 |-->_2`hasValueReturn RHS = _2`hasValueReturn
>>> found metafeature _2`hasValueReturn for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasValueReturn]
>> Text rule else : _1 |-->_1`hasValueReturn LHS variables = [_1]
>> Text rule else : _1 |-->_1`hasValueReturn LHS tokens = [else, :, _1]
>> Text rule else : _1 |-->_1`hasValueReturn RHS = _1`hasValueReturn
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule except : _1 |-->_1`hasValueReturn LHS variables = [_1]
>> Text rule except : _1 |-->_1`hasValueReturn LHS tokens = [except, :, _1]
>> Text rule except : _1 |-->_1`hasValueReturn RHS = _1`hasValueReturn
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule except _1 as _2 : _3 |-->_3`hasValueReturn LHS variables = [_1, _2, _3]
>> Text rule except _1 as _2 : _3 |-->_3`hasValueReturn LHS tokens = [except, _1, as, _2, :, _3]
>> Text rule except _1 as _2 : _3 |-->_3`hasValueReturn RHS = _3`hasValueReturn
>>> found metafeature _3`hasValueReturn for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasValueReturn]
>> Text rule except _1 , _2 : _3 |-->_3`hasValueReturn LHS variables = [_1, _2, _3]
>> Text rule except _1 , _2 : _3 |-->_3`hasValueReturn LHS tokens = [except, _1, ,, _2, :, _3]
>> Text rule except _1 , _2 : _3 |-->_3`hasValueReturn RHS = _3`hasValueReturn
>>> found metafeature _3`hasValueReturn for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasValueReturn]
>> Text rule finally : _1 |-->_1`hasValueReturn LHS variables = [_1]
>> Text rule finally : _1 |-->_1`hasValueReturn LHS tokens = [finally, :, _1]
>> Text rule finally : _1 |-->_1`hasValueReturn RHS = _1`hasValueReturn
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 _2 |-->false<when> _2 assign_part LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false<when> _2 assign_part LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false<when> _2 assign_part RHS = false<when> _2 assign_part
+++ Condition lexicals:: [_2, assign_part]
>***> Rule with condition: [_2 assign_part]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false<when> _1 testlist_star_expr LHS variables = [_1]
>> Text rule _1 |-->false<when> _1 testlist_star_expr LHS tokens = [_1]
>> Text rule _1 |-->false<when> _1 testlist_star_expr RHS = false<when> _1 testlist_star_expr
+++ Condition lexicals:: [_1, testlist_star_expr]
>***> Rule with condition: [_1 testlist_star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`hasValueReturn<when> _1 stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 stmt RHS = _1`hasValueReturn<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 small_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 small_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 small_stmt RHS = _1`hasValueReturn<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 simple_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 simple_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 simple_stmt RHS = _1`hasValueReturn<when> _1 simple_stmt
+++ Condition lexicals:: [_1, simple_stmt]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 simple_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 compound_stmt RHS = _1`hasValueReturn<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 elif_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 elif_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 elif_clause RHS = _1`hasValueReturn<when> _1 elif_clause
+++ Condition lexicals:: [_1, elif_clause]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 elif_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 else_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 else_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 else_clause RHS = _1`hasValueReturn<when> _1 else_clause
+++ Condition lexicals:: [_1, else_clause]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 else_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 finally_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 finally_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasValueReturn<when> _1 finally_clause RHS = _1`hasValueReturn<when> _1 finally_clause
+++ Condition lexicals:: [_1, finally_clause]
>>> found metafeature _1`hasValueReturn for _1`
>***> Rule with condition: [_1 finally_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasValueReturn]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasValueReturn true LHS variables = [_1, _*]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasValueReturn true LHS tokens = [_1, _*]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasValueReturn true RHS = true<when> _1 stmt, _1`hasValueReturn true
+++ Condition lexicals:: [_1, stmt, ,, _1, `, hasValueReturn, true]
>***> Rule with condition: [_1 stmt, _1`hasValueReturn true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt LHS variables = [_1, _*]
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt RHS = _*`recurse<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasValueReturn true LHS variables = [_1, _*]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasValueReturn true LHS tokens = [_1, ;, _*]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasValueReturn true RHS = true<when> _1 small_stmt, _1`hasValueReturn true
+++ Condition lexicals:: [_1, small_stmt, ,, _1, `, hasValueReturn, true]
>***> Rule with condition: [_1 small_stmt, _1`hasValueReturn true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt LHS variables = [_1, _*]
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt LHS tokens = [_1, ;, _*]
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt RHS = _*`recurse<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->false LHS variables = [_*]
>> Text rule _* |-->false LHS tokens = [_*]
>> Text rule _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->false LHS variables = [_1]
>> Text rule print _1 |-->false LHS tokens = [print, _1]
>> Text rule print _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule del _1 |-->false LHS variables = [_1]
>> Text rule del _1 |-->false LHS tokens = [del, _1]
>> Text rule del _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule pass |-->false LHS variables = []
>> Text rule pass |-->false LHS tokens = [pass]
>> Text rule pass |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule break |-->false LHS variables = []
>> Text rule break |-->false LHS tokens = [break]
>> Text rule break |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule continue |-->false LHS variables = []
>> Text rule continue |-->false LHS tokens = [continue]
>> Text rule continue |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule return _1 |-->false LHS variables = [_1]
>> Text rule return _1 |-->false LHS tokens = [return, _1]
>> Text rule return _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule return |-->false LHS variables = []
>> Text rule return |-->false LHS tokens = [return]
>> Text rule return |-->false RHS = false
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule raise _1 |-->false LHS variables = [_1]
>> Text rule raise _1 |-->false LHS tokens = [raise, _1]
>> Text rule raise _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule raise _1 from _2 |-->false LHS variables = [_1, _2]
>> Text rule raise _1 from _2 |-->false LHS tokens = [raise, _1, from, _2]
>> Text rule raise _1 from _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule raise _* |-->false LHS variables = [_*]
>> Text rule raise _* |-->false LHS tokens = [raise, _*]
>> Text rule raise _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule import _1 |-->false LHS variables = [_1]
>> Text rule import _1 |-->false LHS tokens = [import, _1]
>> Text rule import _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule from _* |-->false LHS variables = [_*]
>> Text rule from _* |-->false LHS tokens = [from, _*]
>> Text rule from _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule global _* |-->false LHS variables = [_*]
>> Text rule global _* |-->false LHS tokens = [global, _*]
>> Text rule global _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule exec _1 |-->false LHS variables = [_1]
>> Text rule exec _1 |-->false LHS tokens = [exec, _1]
>> Text rule exec _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule exec _* |-->false LHS variables = [_*]
>> Text rule exec _* |-->false LHS tokens = [exec, _*]
>> Text rule exec _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule assert _1 |-->false LHS variables = [_1]
>> Text rule assert _1 |-->false LHS tokens = [assert, _1]
>> Text rule assert _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule assert _1 , _2 |-->false LHS variables = [_1, _2]
>> Text rule assert _1 , _2 |-->false LHS tokens = [assert, _1, ,, _2]
>> Text rule assert _1 , _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule nonlocal _* |-->false LHS variables = [_*]
>> Text rule nonlocal _* |-->false LHS tokens = [nonlocal, _*]
>> Text rule nonlocal _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 |-->_2`hasYieldStatement LHS variables = [_1, _2]
>> Text rule if _1 : _2 |-->_2`hasYieldStatement LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |-->_2`hasYieldStatement RHS = _2`hasYieldStatement
>>> found metafeature _2`hasYieldStatement for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasYieldStatement]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasYieldStatement true, _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasYieldStatement true, _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _2`hasYieldStatement true, _3 else_clause RHS = true<when> _2`hasYieldStatement true, _3 else_clause
+++ Condition lexicals:: [_2, `, hasYieldStatement, true, ,, _3, else_clause]
>***> Rule with condition: [_2`hasYieldStatement true, _3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasYieldStatement true, _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasYieldStatement true, _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->true<when> _3`hasYieldStatement true, _3 else_clause RHS = true<when> _3`hasYieldStatement true, _3 else_clause
+++ Condition lexicals:: [_3, `, hasYieldStatement, true, ,, _3, else_clause]
>***> Rule with condition: [_3`hasYieldStatement true, _3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->false<when> _3 else_clause RHS = false<when> _3 else_clause
+++ Condition lexicals:: [_3, else_clause]
>***> Rule with condition: [_3 else_clause]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |-->true<when> _2`hasYieldStatement true LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->true<when> _2`hasYieldStatement true LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->true<when> _2`hasYieldStatement true RHS = true<when> _2`hasYieldStatement true
+++ Condition lexicals:: [_2, `, hasYieldStatement, true]
>***> Rule with condition: [_2`hasYieldStatement true]
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |-->_*`recurse LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->_*`recurse LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule while _1 : _2 |-->_2`hasYieldStatement LHS variables = [_1, _2]
>> Text rule while _1 : _2 |-->_2`hasYieldStatement LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |-->_2`hasYieldStatement RHS = _2`hasYieldStatement
>>> found metafeature _2`hasYieldStatement for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasYieldStatement]
>> Text rule for _1 in _2 : _3 |-->_3`hasYieldStatement LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->_3`hasYieldStatement LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->_3`hasYieldStatement RHS = _3`hasYieldStatement
>>> found metafeature _3`hasYieldStatement for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasYieldStatement]
>> Text rule try : _1 |-->_1`hasYieldStatement LHS variables = [_1]
>> Text rule try : _1 |-->_1`hasYieldStatement LHS tokens = [try, :, _1]
>> Text rule try : _1 |-->_1`hasYieldStatement RHS = _1`hasYieldStatement
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule try : _1 _* |-->true<when> _1`hasYieldStatement true LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->true<when> _1`hasYieldStatement true LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->true<when> _1`hasYieldStatement true RHS = true<when> _1`hasYieldStatement true
+++ Condition lexicals:: [_1, `, hasYieldStatement, true]
>***> Rule with condition: [_1`hasYieldStatement true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule try : _1 _* |-->_*`recurse LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->_*`recurse LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule with _1 : _2 |-->_2`hasYieldStatement LHS variables = [_1, _2]
>> Text rule with _1 : _2 |-->_2`hasYieldStatement LHS tokens = [with, _1, :, _2]
>> Text rule with _1 : _2 |-->_2`hasYieldStatement RHS = _2`hasYieldStatement
>>> found metafeature _2`hasYieldStatement for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasYieldStatement]
>> Text rule elif _1 : _2 |-->_2`hasYieldStatement LHS variables = [_1, _2]
>> Text rule elif _1 : _2 |-->_2`hasYieldStatement LHS tokens = [elif, _1, :, _2]
>> Text rule elif _1 : _2 |-->_2`hasYieldStatement RHS = _2`hasYieldStatement
>>> found metafeature _2`hasYieldStatement for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`hasYieldStatement]
>> Text rule else : _1 |-->_1`hasYieldStatement LHS variables = [_1]
>> Text rule else : _1 |-->_1`hasYieldStatement LHS tokens = [else, :, _1]
>> Text rule else : _1 |-->_1`hasYieldStatement RHS = _1`hasYieldStatement
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule except : _1 |-->_1`hasYieldStatement LHS variables = [_1]
>> Text rule except : _1 |-->_1`hasYieldStatement LHS tokens = [except, :, _1]
>> Text rule except : _1 |-->_1`hasYieldStatement RHS = _1`hasYieldStatement
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule except _1 as _2 : _3 |-->_3`hasYieldStatement LHS variables = [_1, _2, _3]
>> Text rule except _1 as _2 : _3 |-->_3`hasYieldStatement LHS tokens = [except, _1, as, _2, :, _3]
>> Text rule except _1 as _2 : _3 |-->_3`hasYieldStatement RHS = _3`hasYieldStatement
>>> found metafeature _3`hasYieldStatement for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasYieldStatement]
>> Text rule except _1 , _2 : _3 |-->_3`hasYieldStatement LHS variables = [_1, _2, _3]
>> Text rule except _1 , _2 : _3 |-->_3`hasYieldStatement LHS tokens = [except, _1, ,, _2, :, _3]
>> Text rule except _1 , _2 : _3 |-->_3`hasYieldStatement RHS = _3`hasYieldStatement
>>> found metafeature _3`hasYieldStatement for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`hasYieldStatement]
>> Text rule finally : _1 |-->_1`hasYieldStatement LHS variables = [_1]
>> Text rule finally : _1 |-->_1`hasYieldStatement LHS tokens = [finally, :, _1]
>> Text rule finally : _1 |-->_1`hasYieldStatement RHS = _1`hasYieldStatement
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->true<when> _1 yield_expr LHS variables = [_1]
>> Text rule _1 |-->true<when> _1 yield_expr LHS tokens = [_1]
>> Text rule _1 |-->true<when> _1 yield_expr RHS = true<when> _1 yield_expr
+++ Condition lexicals:: [_1, yield_expr]
>***> Rule with condition: [_1 yield_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->false<when> _2 assign_part LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false<when> _2 assign_part LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false<when> _2 assign_part RHS = false<when> _2 assign_part
+++ Condition lexicals:: [_2, assign_part]
>***> Rule with condition: [_2 assign_part]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->false<when> _1 testlist_star_expr LHS variables = [_1]
>> Text rule _1 |-->false<when> _1 testlist_star_expr LHS tokens = [_1]
>> Text rule _1 |-->false<when> _1 testlist_star_expr RHS = false<when> _1 testlist_star_expr
+++ Condition lexicals:: [_1, testlist_star_expr]
>***> Rule with condition: [_1 testlist_star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 stmt RHS = _1`hasYieldStatement<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 small_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 small_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 small_stmt RHS = _1`hasYieldStatement<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 simple_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 simple_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 simple_stmt RHS = _1`hasYieldStatement<when> _1 simple_stmt
+++ Condition lexicals:: [_1, simple_stmt]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 simple_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 compound_stmt RHS = _1`hasYieldStatement<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 elif_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 elif_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 elif_clause RHS = _1`hasYieldStatement<when> _1 elif_clause
+++ Condition lexicals:: [_1, elif_clause]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 elif_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 else_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 else_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 else_clause RHS = _1`hasYieldStatement<when> _1 else_clause
+++ Condition lexicals:: [_1, else_clause]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 else_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 finally_clause LHS variables = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 finally_clause LHS tokens = [_1]
>> Text rule _1 |-->_1`hasYieldStatement<when> _1 finally_clause RHS = _1`hasYieldStatement<when> _1 finally_clause
+++ Condition lexicals:: [_1, finally_clause]
>>> found metafeature _1`hasYieldStatement for _1`
>***> Rule with condition: [_1 finally_clause]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`hasYieldStatement]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasYieldStatement true LHS variables = [_1, _*]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasYieldStatement true LHS tokens = [_1, _*]
>> Text rule _1 _* |-->true<when> _1 stmt, _1`hasYieldStatement true RHS = true<when> _1 stmt, _1`hasYieldStatement true
+++ Condition lexicals:: [_1, stmt, ,, _1, `, hasYieldStatement, true]
>***> Rule with condition: [_1 stmt, _1`hasYieldStatement true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt LHS variables = [_1, _*]
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_*`recurse<when> _1 stmt RHS = _*`recurse<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasYieldStatement true LHS variables = [_1, _*]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasYieldStatement true LHS tokens = [_1, ;, _*]
>> Text rule _1 ; _* |-->true<when> _1 small_stmt, _1`hasYieldStatement true RHS = true<when> _1 small_stmt, _1`hasYieldStatement true
+++ Condition lexicals:: [_1, small_stmt, ,, _1, `, hasYieldStatement, true]
>***> Rule with condition: [_1 small_stmt, _1`hasYieldStatement true]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: []
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt LHS variables = [_1, _*]
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt LHS tokens = [_1, ;, _*]
>> Text rule _1 ; _* |-->_*`recurse<when> _1 small_stmt RHS = _*`recurse<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _*`recurse for _*`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->false LHS variables = [_1]
>> Text rule _1 |-->false LHS tokens = [_1]
>> Text rule _1 |-->false RHS = false
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->false LHS variables = [_*]
>> Text rule _* |-->false LHS tokens = [_*]
>> Text rule _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->      var _1 : OclAny := _tuple->at(_indx); _indx := _indx + 1;\n_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->      var _1 : OclAny := _tuple->at(_indx); _indx := _indx + 1;\n_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->      var _1 : OclAny := _tuple->at(_indx); _indx := _indx + 1;\n_*`recurse RHS =       var _1 : OclAny := _tuple->at(_indx); _indx := _indx + 1;\n_*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |-->      var _1 : OclAny := _tuple->at(_indx);\n LHS variables = [_1]
>> Text rule _1 |-->      var _1 : OclAny := _tuple->at(_indx);\n LHS tokens = [_1]
>> Text rule _1 |-->      var _1 : OclAny := _tuple->at(_indx);\n RHS =       var _1 : OclAny := _tuple->at(_indx);\n
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->    error _1`errorToUML LHS variables = [_1]
>> Text rule _1 |-->    error _1`errorToUML LHS tokens = [_1]
>> Text rule _1 |-->    error _1`errorToUML RHS =     error _1`errorToUML
>>> found metafeature _1`errorToUML for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`errorToUML]
>> Text rule _1 _* |-->    error _1`errorToUML;\n_*`recurse LHS variables = [_1, _*]
>> Text rule _1 _* |-->    error _1`errorToUML;\n_*`recurse LHS tokens = [_1, _*]
>> Text rule _1 _* |-->    error _1`errorToUML;\n_*`recurse RHS =     error _1`errorToUML;\n_*`recurse
>>> found metafeature _*`recurse for _*`
>>> found metafeature _1`errorToUML for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse, _1`errorToUML]
>> Text rule = _1 = _2 |-->true LHS variables = [_1, _2]
>> Text rule = _1 = _2 |-->true LHS tokens = [=, _1, =, _2]
>> Text rule = _1 = _2 |-->true RHS = true
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->true LHS variables = [_1]
>> Text rule = _1 |-->true LHS tokens = [=, _1]
>> Text rule = _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->false LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _* |-->false LHS variables = [_*]
>> Text rule _* |-->false LHS tokens = [_*]
>> Text rule _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule : _1 = _2 |-->true LHS variables = [_1, _2]
>> Text rule : _1 = _2 |-->true LHS tokens = [:, _1, =, _2]
>> Text rule : _1 = _2 |-->true RHS = true
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule : _1 |-->true LHS variables = [_1]
>> Text rule : _1 |-->true LHS tokens = [:, _1]
>> Text rule : _1 |-->true RHS = true
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->false LHS variables = [_1, _2]
>> Text rule _1 _2 |-->false LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->false RHS = false
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _* |-->false LHS variables = [_*]
>> Text rule _* |-->false LHS tokens = [_*]
>> Text rule _* |-->false RHS = false
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule : _1 = _2 |-->: _1`ocltype := _2 LHS variables = [_1, _2]
>> Text rule : _1 = _2 |-->: _1`ocltype := _2 LHS tokens = [:, _1, =, _2]
>> Text rule : _1 = _2 |-->: _1`ocltype := _2 RHS = : _1`ocltype := _2
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule : _1 |-->: _1`ocltype LHS variables = [_1]
>> Text rule : _1 |-->: _1`ocltype LHS tokens = [:, _1]
>> Text rule : _1 |-->: _1`ocltype RHS = : _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule = _1 = _2 |-->:= _2; _1 := _2<when> _1`defined true LHS variables = [_1, _2]
>> Text rule = _1 = _2 |-->:= _2; _1 := _2<when> _1`defined true LHS tokens = [=, _1, =, _2]
>> Text rule = _1 = _2 |-->:= _2; _1 := _2<when> _1`defined true RHS = := _2; _1 := _2<when> _1`defined true
+++ Condition lexicals:: [_1, `, defined, true]
>***> Rule with condition: [_1`defined true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule = _1 = _2 |-->:= _2; var _1 : _2`ocltype := _2<action> _1`defined true LHS variables = [_1, _2]
>> Text rule = _1 = _2 |-->:= _2; var _1 : _2`ocltype := _2<action> _1`defined true LHS tokens = [=, _1, =, _2]
>> Text rule = _1 = _2 |-->:= _2; var _1 : _2`ocltype := _2<action> _1`defined true RHS = := _2; var _1 : _2`ocltype := _2<action> _1`defined true
+++ Action lexicals:: [_1, `, defined, true]
>> Rule actions are:  _1`defined true [_1`defined true]
>>> found metafeature _2`ocltype for _2`
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule = _1 |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule = _1 |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [=, _1]
>> Text rule = _1 |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true RHS = := _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule = _1 |-->:= _1 LHS variables = [_1]
>> Text rule = _1 |-->:= _1 LHS tokens = [=, _1]
>> Text rule = _1 |-->:= _1 RHS = := _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule += _1 |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule += _1 |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [+=, _1]
>> Text rule += _1 |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  + _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule += _1 |--> + _1 LHS variables = [_1]
>> Text rule += _1 |--> + _1 LHS tokens = [+=, _1]
>> Text rule += _1 |--> + _1 RHS =  + _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule -= _1 |--> - _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule -= _1 |--> - _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [-=, _1]
>> Text rule -= _1 |--> - _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  - _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule -= _1 |--> - _1 LHS variables = [_1]
>> Text rule -= _1 |--> - _1 LHS tokens = [-=, _1]
>> Text rule -= _1 |--> - _1 RHS =  - _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule *= _1 |--> * _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule *= _1 |--> * _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [*=, _1]
>> Text rule *= _1 |--> * _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  * _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule *= _1 |--> * _1 LHS variables = [_1]
>> Text rule *= _1 |--> * _1 LHS tokens = [*=, _1]
>> Text rule *= _1 |--> * _1 RHS =  * _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule %= _1 |--> mod _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule %= _1 |--> mod _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [%=, _1]
>> Text rule %= _1 |--> mod _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  mod _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule %= _1 |--> mod _1 LHS variables = [_1]
>> Text rule %= _1 |--> mod _1 LHS tokens = [%=, _1]
>> Text rule %= _1 |--> mod _1 RHS =  mod _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule /= _1 |--> / _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule /= _1 |--> / _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [/=, _1]
>> Text rule /= _1 |--> / _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  / _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule /= _1 |--> / _1 LHS variables = [_1]
>> Text rule /= _1 |--> / _1 LHS tokens = [/=, _1]
>> Text rule /= _1 |--> / _1 RHS =  / _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule //= _1 |--> div _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule //= _1 |--> div _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [//=, _1]
>> Text rule //= _1 |--> div _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  div _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule //= _1 |--> div _1 LHS variables = [_1]
>> Text rule //= _1 |--> div _1 LHS tokens = [//=, _1]
>> Text rule //= _1 |--> div _1 RHS =  div _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule |= _1 |--> or _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule |= _1 |--> or _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [|=, _1]
>> Text rule |= _1 |--> or _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  or _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule |= _1 |--> or _1 LHS variables = [_1]
>> Text rule |= _1 |--> or _1 LHS tokens = [|=, _1]
>> Text rule |= _1 |--> or _1 RHS =  or _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule &= _1 |--> & _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule &= _1 |--> & _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [&=, _1]
>> Text rule &= _1 |--> & _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  & _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule &= _1 |--> & _1 LHS variables = [_1]
>> Text rule &= _1 |--> & _1 LHS tokens = [&=, _1]
>> Text rule &= _1 |--> & _1 RHS =  & _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ^= _1 |--> xor _1 ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule ^= _1 |--> xor _1 ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [^=, _1]
>> Text rule ^= _1 |--> xor _1 ; _1`updateForm<when> _1`hasSideEffect true RHS =  xor _1 ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule ^= _1 |--> xor _1 LHS variables = [_1]
>> Text rule ^= _1 |--> xor _1 LHS tokens = [^=, _1]
>> Text rule ^= _1 |--> xor _1 RHS =  xor _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule **= _1 |-->->pow(_1) ; _1`updateForm<when> _1`hasSideEffect true LHS variables = [_1]
>> Text rule **= _1 |-->->pow(_1) ; _1`updateForm<when> _1`hasSideEffect true LHS tokens = [**=, _1]
>> Text rule **= _1 |-->->pow(_1) ; _1`updateForm<when> _1`hasSideEffect true RHS = ->pow(_1) ; _1`updateForm<when> _1`hasSideEffect true
+++ Condition lexicals:: [_1, `, hasSideEffect, true]
>>> found metafeature _1`updateForm for _1`
>***> Rule with condition: [_1`hasSideEffect true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`updateForm]
>> Text rule **= _1 |-->->pow(_1) LHS variables = [_1]
>> Text rule **= _1 |-->->pow(_1) LHS tokens = [**=, _1]
>> Text rule **= _1 |-->->pow(_1) RHS = ->pow(_1)
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule <<= _1 |--> * (2->pow(_1)) LHS variables = [_1]
>> Text rule <<= _1 |--> * (2->pow(_1)) LHS tokens = [<<=, _1]
>> Text rule <<= _1 |--> * (2->pow(_1)) RHS =  * (2->pow(_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule >>= _1 |--> div (2->pow(_1)) LHS variables = [_1]
>> Text rule >>= _1 |--> div (2->pow(_1)) LHS tokens = [>>=, _1]
>> Text rule >>= _1 |--> div (2->pow(_1)) RHS =  div (2->pow(_1))
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->String<when> _1 String LHS variables = [_1]
>> Text rule = _1 |-->String<when> _1 String LHS tokens = [=, _1]
>> Text rule = _1 |-->String<when> _1 String RHS = String<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->int<when> _1 int LHS variables = [_1]
>> Text rule = _1 |-->int<when> _1 int LHS tokens = [=, _1]
>> Text rule = _1 |-->int<when> _1 int RHS = int<when> _1 int
+++ Condition lexicals:: [_1, int]
>***> Rule with condition: [_1 int]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->double<when> _1 real LHS variables = [_1]
>> Text rule = _1 |-->double<when> _1 real LHS tokens = [=, _1]
>> Text rule = _1 |-->double<when> _1 real RHS = double<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->Sequence<when> _1`isSequenceExpression true LHS variables = [_1]
>> Text rule = _1 |-->Sequence<when> _1`isSequenceExpression true LHS tokens = [=, _1]
>> Text rule = _1 |-->Sequence<when> _1`isSequenceExpression true RHS = Sequence<when> _1`isSequenceExpression true
+++ Condition lexicals:: [_1, `, isSequenceExpression, true]
>***> Rule with condition: [_1`isSequenceExpression true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->Map<when> _1`isMapExpression true LHS variables = [_1]
>> Text rule = _1 |-->Map<when> _1`isMapExpression true LHS tokens = [=, _1]
>> Text rule = _1 |-->Map<when> _1`isMapExpression true RHS = Map<when> _1`isMapExpression true
+++ Condition lexicals:: [_1, `, isMapExpression, true]
>***> Rule with condition: [_1`isMapExpression true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule = _1 |-->_1`ocltype LHS variables = [_1]
>> Text rule = _1 |-->_1`ocltype LHS tokens = [=, _1]
>> Text rule = _1 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule True |-->boolean LHS variables = []
>> Text rule True |-->boolean LHS tokens = [True]
>> Text rule True |-->boolean RHS = boolean
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule False |-->boolean LHS variables = []
>> Text rule False |-->boolean LHS tokens = [False]
>> Text rule False |-->boolean RHS = boolean
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule inf |-->double LHS variables = []
>> Text rule inf |-->double LHS tokens = [inf]
>> Text rule inf |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule Infinity |-->double LHS variables = []
>> Text rule Infinity |-->double LHS tokens = [Infinity]
>> Text rule Infinity |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule nan |-->double LHS variables = []
>> Text rule nan |-->double LHS tokens = [nan]
>> Text rule nan |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule int |-->int LHS variables = []
>> Text rule int |-->int LHS tokens = [int]
>> Text rule int |-->int RHS = int
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule float |-->double LHS variables = []
>> Text rule float |-->double LHS tokens = [float]
>> Text rule float |-->double RHS = double
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule str |-->String LHS variables = []
>> Text rule str |-->String LHS tokens = [str]
>> Text rule str |-->String RHS = String
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule dict |-->Map LHS variables = []
>> Text rule dict |-->Map LHS tokens = [dict]
>> Text rule dict |-->Map RHS = Map
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule list |-->Sequence LHS variables = []
>> Text rule list |-->Sequence LHS tokens = [list]
>> Text rule list |-->Sequence RHS = Sequence
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule deque |-->Sequence LHS variables = []
>> Text rule deque |-->Sequence LHS tokens = [deque]
>> Text rule deque |-->Sequence RHS = Sequence
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule set |-->Set LHS variables = []
>> Text rule set |-->Set LHS tokens = [set]
>> Text rule set |-->Set RHS = Set
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule tuple |-->Sequence LHS variables = []
>> Text rule tuple |-->Sequence LHS tokens = [tuple]
>> Text rule tuple |-->Sequence RHS = Sequence
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule bool |-->boolean LHS variables = []
>> Text rule bool |-->boolean LHS tokens = [bool]
>> Text rule bool |-->boolean RHS = boolean
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule callable _1 |-->boolean LHS variables = [_1]
>> Text rule callable _1 |-->boolean LHS tokens = [callable, _1]
>> Text rule callable _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule bool _1 |-->boolean LHS variables = [_1]
>> Text rule bool _1 |-->boolean LHS tokens = [bool, _1]
>> Text rule bool _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule abs _1 |-->double LHS variables = [_1]
>> Text rule abs _1 |-->double LHS tokens = [abs, _1]
>> Text rule abs _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule all _1 |-->boolean LHS variables = [_1]
>> Text rule all _1 |-->boolean LHS tokens = [all, _1]
>> Text rule all _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule dict _1 |-->Map LHS variables = [_1]
>> Text rule dict _1 |-->Map LHS tokens = [dict, _1]
>> Text rule dict _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule globals _1 |-->Map LHS variables = [_1]
>> Text rule globals _1 |-->Map LHS tokens = [globals, _1]
>> Text rule globals _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule hex _1 |-->String LHS variables = [_1]
>> Text rule hex _1 |-->String LHS tokens = [hex, _1]
>> Text rule hex _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule id _1 |-->int LHS variables = [_1]
>> Text rule id _1 |-->int LHS tokens = [id, _1]
>> Text rule id _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule any _1 |-->boolean LHS variables = [_1]
>> Text rule any _1 |-->boolean LHS tokens = [any, _1]
>> Text rule any _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ascii _1 |-->String LHS variables = [_1]
>> Text rule ascii _1 |-->String LHS tokens = [ascii, _1]
>> Text rule ascii _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule filter _1 |-->Sequence LHS variables = [_1]
>> Text rule filter _1 |-->Sequence LHS tokens = [filter, _1]
>> Text rule filter _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule frozenset _1 |-->Set LHS variables = [_1]
>> Text rule frozenset _1 |-->Set LHS tokens = [frozenset, _1]
>> Text rule frozenset _1 |-->Set RHS = Set
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule hash _1 |-->int LHS variables = [_1]
>> Text rule hash _1 |-->int LHS tokens = [hash, _1]
>> Text rule hash _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule input _1 |-->String LHS variables = [_1]
>> Text rule input _1 |-->String LHS tokens = [input, _1]
>> Text rule input _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule isinstance _1 |-->boolean LHS variables = [_1]
>> Text rule isinstance _1 |-->boolean LHS tokens = [isinstance, _1]
>> Text rule isinstance _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule issubclass _1 |-->boolean LHS variables = [_1]
>> Text rule issubclass _1 |-->boolean LHS tokens = [issubclass, _1]
>> Text rule issubclass _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule hasattr _1 |-->boolean LHS variables = [_1]
>> Text rule hasattr _1 |-->boolean LHS tokens = [hasattr, _1]
>> Text rule hasattr _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule len _1 |-->int LHS variables = [_1]
>> Text rule len _1 |-->int LHS tokens = [len, _1]
>> Text rule len _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule list _1 |-->Sequence LHS variables = [_1]
>> Text rule list _1 |-->Sequence LHS tokens = [list, _1]
>> Text rule list _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule deque _1 |-->Sequence LHS variables = [_1]
>> Text rule deque _1 |-->Sequence LHS tokens = [deque, _1]
>> Text rule deque _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule map _1 |-->Sequence LHS variables = [_1]
>> Text rule map _1 |-->Sequence LHS tokens = [map, _1]
>> Text rule map _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule set _1 |-->Set LHS variables = [_1]
>> Text rule set _1 |-->Set LHS tokens = [set, _1]
>> Text rule set _1 |-->Set RHS = Set
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule sorted _1 |-->Sequence LHS variables = [_1]
>> Text rule sorted _1 |-->Sequence LHS tokens = [sorted, _1]
>> Text rule sorted _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule tuple _1 |-->Sequence LHS variables = [_1]
>> Text rule tuple _1 |-->Sequence LHS tokens = [tuple, _1]
>> Text rule tuple _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule pow _1 |-->double LHS variables = [_1]
>> Text rule pow _1 |-->double LHS tokens = [pow, _1]
>> Text rule pow _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule repr _1 |-->String LHS variables = [_1]
>> Text rule repr _1 |-->String LHS tokens = [repr, _1]
>> Text rule repr _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule reversed _1 |-->Sequence LHS variables = [_1]
>> Text rule reversed _1 |-->Sequence LHS tokens = [reversed, _1]
>> Text rule reversed _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule round _1 |-->double LHS variables = [_1]
>> Text rule round _1 |-->double LHS tokens = [round, _1]
>> Text rule round _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule print _1 |-->void LHS variables = [_1]
>> Text rule print _1 |-->void LHS tokens = [print, _1]
>> Text rule print _1 |-->void RHS = void
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule int _1 |-->int LHS variables = [_1]
>> Text rule int _1 |-->int LHS tokens = [int, _1]
>> Text rule int _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule float _1 |-->double LHS variables = [_1]
>> Text rule float _1 |-->double LHS tokens = [float, _1]
>> Text rule float _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule str _1 |-->String LHS variables = [_1]
>> Text rule str _1 |-->String LHS tokens = [str, _1]
>> Text rule str _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule format _1 |-->String LHS variables = [_1]
>> Text rule format _1 |-->String LHS tokens = [format, _1]
>> Text rule format _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule chr _1 |-->String LHS variables = [_1]
>> Text rule chr _1 |-->String LHS tokens = [chr, _1]
>> Text rule chr _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule unichr _1 |-->String LHS variables = [_1]
>> Text rule unichr _1 |-->String LHS tokens = [unichr, _1]
>> Text rule unichr _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ord _1 |-->int LHS variables = [_1]
>> Text rule ord _1 |-->int LHS tokens = [ord, _1]
>> Text rule ord _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule type _1 |-->OclType LHS variables = [_1]
>> Text rule type _1 |-->OclType LHS tokens = [type, _1]
>> Text rule type _1 |-->OclType RHS = OclType
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule range _1 |-->Sequence LHS variables = [_1]
>> Text rule range _1 |-->Sequence LHS tokens = [range, _1]
>> Text rule range _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule enumerate _1 |-->Sequence LHS variables = [_1]
>> Text rule enumerate _1 |-->Sequence LHS tokens = [enumerate, _1]
>> Text rule enumerate _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule zip _1 |-->Sequence LHS variables = [_1]
>> Text rule zip _1 |-->Sequence LHS tokens = [zip, _1]
>> Text rule zip _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule slice _1 |-->Sequence LHS variables = [_1]
>> Text rule slice _1 |-->Sequence LHS tokens = [slice, _1]
>> Text rule slice _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule open _1 |-->OclFile LHS variables = [_1]
>> Text rule open _1 |-->OclFile LHS tokens = [open, _1]
>> Text rule open _1 |-->OclFile RHS = OclFile
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule asyncio _1 |-->OclProcess LHS variables = [_1]
>> Text rule asyncio _1 |-->OclProcess LHS tokens = [asyncio, _1]
>> Text rule asyncio _1 |-->OclProcess RHS = OclProcess
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule collections _1 |-->_1`collectionsType LHS variables = [_1]
>> Text rule collections _1 |-->_1`collectionsType LHS tokens = [collections, _1]
>> Text rule collections _1 |-->_1`collectionsType RHS = _1`collectionsType
>>> found metafeature _1`collectionsType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`collectionsType]
>> Text rule math _1 |-->_1`mathType LHS variables = [_1]
>> Text rule math _1 |-->_1`mathType LHS tokens = [math, _1]
>> Text rule math _1 |-->_1`mathType RHS = _1`mathType
>>> found metafeature _1`mathType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`mathType]
>> Text rule re _1 |-->_1`reType LHS variables = [_1]
>> Text rule re _1 |-->_1`reType LHS tokens = [re, _1]
>> Text rule re _1 |-->_1`reType RHS = _1`reType
>>> found metafeature _1`reType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`reType]
>> Text rule np _1 |-->_1`numpyType LHS variables = [_1]
>> Text rule np _1 |-->_1`numpyType LHS tokens = [np, _1]
>> Text rule np _1 |-->_1`numpyType RHS = _1`numpyType
>>> found metafeature _1`numpyType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numpyType]
>> Text rule np _1 _2 |-->_2`npRandomType<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule np _1 _2 |-->_2`npRandomType<when> _1 matches .random LHS tokens = [np, _1, _2]
>> Text rule np _1 _2 |-->_2`npRandomType<when> _1 matches .random RHS = _2`npRandomType<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomType for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomType]
>> Text rule numpy _1 |-->_1`numpyType LHS variables = [_1]
>> Text rule numpy _1 |-->_1`numpyType LHS tokens = [numpy, _1]
>> Text rule numpy _1 |-->_1`numpyType RHS = _1`numpyType
>>> found metafeature _1`numpyType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numpyType]
>> Text rule numpy _1 _2 |-->_2`npRandomType<when> _1 matches .random LHS variables = [_1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomType<when> _1 matches .random LHS tokens = [numpy, _1, _2]
>> Text rule numpy _1 _2 |-->_2`npRandomType<when> _1 matches .random RHS = _2`npRandomType<when> _1 matches .random
+++ Condition lexicals:: [_1, matches, .random]
>>> found metafeature _2`npRandomType for _2`
>***> Rule with condition: [_1 matches .random]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`npRandomType]
>> Text rule pd _1 |-->_1`pandasType LHS variables = [_1]
>> Text rule pd _1 |-->_1`pandasType LHS tokens = [pd, _1]
>> Text rule pd _1 |-->_1`pandasType RHS = _1`pandasType
>>> found metafeature _1`pandasType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`pandasType]
>> Text rule pandas _1 |-->_1`pandasType LHS variables = [_1]
>> Text rule pandas _1 |-->_1`pandasType LHS tokens = [pandas, _1]
>> Text rule pandas _1 |-->_1`pandasType RHS = _1`pandasType
>>> found metafeature _1`pandasType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`pandasType]
>> Text rule sys _1 |-->_1`sysType LHS variables = [_1]
>> Text rule sys _1 |-->_1`sysType LHS tokens = [sys, _1]
>> Text rule sys _1 |-->_1`sysType RHS = _1`sysType
>>> found metafeature _1`sysType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`sysType]
>> Text rule sys _1 _2 |-->_2`trailerOclType<when> _2 trailer LHS variables = [_1, _2]
>> Text rule sys _1 _2 |-->_2`trailerOclType<when> _2 trailer LHS tokens = [sys, _1, _2]
>> Text rule sys _1 _2 |-->_2`trailerOclType<when> _2 trailer RHS = _2`trailerOclType<when> _2 trailer
+++ Condition lexicals:: [_2, trailer]
>>> found metafeature _2`trailerOclType for _2`
>***> Rule with condition: [_2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`trailerOclType]
>> Text rule _1 if _2 else _3 |-->_1`ocltype LHS variables = [_1, _2, _3]
>> Text rule _1 if _2 else _3 |-->_1`ocltype LHS tokens = [_1, if, _2, else, _3]
>> Text rule _1 if _2 else _3 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule lambda _1 : _2 |-->Function LHS variables = [_1, _2]
>> Text rule lambda _1 : _2 |-->Function LHS tokens = [lambda, _1, :, _2]
>> Text rule lambda _1 : _2 |-->Function RHS = Function
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule lambda : _1 |-->Function LHS variables = [_1]
>> Text rule lambda : _1 |-->Function LHS tokens = [lambda, :, _1]
>> Text rule lambda : _1 |-->Function RHS = Function
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule * _1 |-->Sequence LHS variables = [_1]
>> Text rule * _1 |-->Sequence LHS tokens = [*, _1]
>> Text rule * _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ** _1 |-->Map LHS variables = [_1]
>> Text rule ** _1 |-->Map LHS tokens = [**, _1]
>> Text rule ** _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 ** _2 |-->double LHS variables = [_1, _2]
>> Text rule _1 ** _2 |-->double LHS tokens = [_1, **, _2]
>> Text rule _1 ** _2 |-->double RHS = double
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule + _1 |-->_1`ocltype LHS variables = [_1]
>> Text rule + _1 |-->_1`ocltype LHS tokens = [+, _1]
>> Text rule + _1 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule - _1 |-->_1`ocltype LHS variables = [_1]
>> Text rule - _1 |-->_1`ocltype LHS tokens = [-, _1]
>> Text rule - _1 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule ~ _1 |-->int LHS variables = [_1]
>> Text rule ~ _1 |-->int LHS tokens = [~, _1]
>> Text rule ~ _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->String<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->String<when> _1 String LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->String<when> _1 String RHS = String<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->Sequence<when> _1`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->Sequence<when> _1`ocltype Sequence LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->Sequence<when> _1`ocltype Sequence RHS = Sequence<when> _1`ocltype Sequence
+++ Condition lexicals:: [_1, `, ocltype, Sequence]
>***> Rule with condition: [_1`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->Sequence<when> _2`ocltype Sequence LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->Sequence<when> _2`ocltype Sequence LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->Sequence<when> _2`ocltype Sequence RHS = Sequence<when> _2`ocltype Sequence
+++ Condition lexicals:: [_2, `, ocltype, Sequence]
>***> Rule with condition: [_2`ocltype Sequence]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->int<when> _1`ocltype int, _2`ocltype int LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->int<when> _1`ocltype int, _2`ocltype int LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->int<when> _1`ocltype int, _2`ocltype int RHS = int<when> _1`ocltype int, _2`ocltype int
+++ Condition lexicals:: [_1, `, ocltype, int, ,, _2, `, ocltype, int]
>***> Rule with condition: [_1`ocltype int, _2`ocltype int]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 * _2 |-->double LHS variables = [_1, _2]
>> Text rule _1 * _2 |-->double LHS tokens = [_1, *, _2]
>> Text rule _1 * _2 |-->double RHS = double
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 / _2 |-->double LHS variables = [_1, _2]
>> Text rule _1 / _2 |-->double LHS tokens = [_1, /, _2]
>> Text rule _1 / _2 |-->double RHS = double
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 % _2 |-->String<when> _1 String LHS variables = [_1, _2]
>> Text rule _1 % _2 |-->String<when> _1 String LHS tokens = [_1, %, _2]
>> Text rule _1 % _2 |-->String<when> _1 String RHS = String<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 % _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 % _2 |-->int LHS tokens = [_1, %, _2]
>> Text rule _1 % _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 // _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 // _2 |-->int LHS tokens = [_1, //, _2]
>> Text rule _1 // _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 @ _2 |-->Sequence LHS variables = [_1, _2]
>> Text rule _1 @ _2 |-->Sequence LHS tokens = [_1, @, _2]
>> Text rule _1 @ _2 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 + _2 |-->_1`ocltype LHS variables = [_1, _2]
>> Text rule _1 + _2 |-->_1`ocltype LHS tokens = [_1, +, _2]
>> Text rule _1 + _2 |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 - _2 |-->double LHS variables = [_1, _2]
>> Text rule _1 - _2 |-->double LHS tokens = [_1, -, _2]
>> Text rule _1 - _2 |-->double RHS = double
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 << _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 << _2 |-->int LHS tokens = [_1, <<, _2]
>> Text rule _1 << _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >> _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 >> _2 |-->int LHS tokens = [_1, >>, _2]
>> Text rule _1 >> _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 & _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 & _2 |-->int LHS tokens = [_1, &, _2]
>> Text rule _1 & _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 ^ _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 ^ _2 |-->int LHS tokens = [_1, ^, _2]
>> Text rule _1 ^ _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 | _2 |-->Map<when> _1 Map LHS variables = [_1, _2]
>> Text rule _1 | _2 |-->Map<when> _1 Map LHS tokens = [_1, |, _2]
>> Text rule _1 | _2 |-->Map<when> _1 Map RHS = Map<when> _1 Map
+++ Condition lexicals:: [_1, Map]
>***> Rule with condition: [_1 Map]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 | _2 |-->int LHS variables = [_1, _2]
>> Text rule _1 | _2 |-->int LHS tokens = [_1, |, _2]
>> Text rule _1 | _2 |-->int RHS = int
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule not _1 |-->boolean LHS variables = [_1]
>> Text rule not _1 |-->boolean LHS tokens = [not, _1]
>> Text rule not _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 and _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 and _2 |-->boolean LHS tokens = [_1, and, _2]
>> Text rule _1 and _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 or _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 or _2 |-->boolean LHS tokens = [_1, or, _2]
>> Text rule _1 or _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 < _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 < _2 |-->boolean LHS tokens = [_1, <, _2]
>> Text rule _1 < _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 > _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 > _2 |-->boolean LHS tokens = [_1, >, _2]
>> Text rule _1 > _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 == _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 == _2 |-->boolean LHS tokens = [_1, ==, _2]
>> Text rule _1 == _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 >= _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 >= _2 |-->boolean LHS tokens = [_1, >=, _2]
>> Text rule _1 >= _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <= _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 <= _2 |-->boolean LHS tokens = [_1, <=, _2]
>> Text rule _1 <= _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 <> _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 <> _2 |-->boolean LHS tokens = [_1, <>, _2]
>> Text rule _1 <> _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 != _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 != _2 |-->boolean LHS tokens = [_1, !=, _2]
>> Text rule _1 != _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 not in _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 not in _2 |-->boolean LHS tokens = [_1, not, in, _2]
>> Text rule _1 not in _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 in _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 in _2 |-->boolean LHS tokens = [_1, in, _2]
>> Text rule _1 in _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 is not _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 is not _2 |-->boolean LHS tokens = [_1, is, not, _2]
>> Text rule _1 is not _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 is _2 |-->boolean LHS variables = [_1, _2]
>> Text rule _1 is _2 |-->boolean LHS tokens = [_1, is, _2]
>> Text rule _1 is _2 |-->boolean RHS = boolean
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->_1`ocltype LHS variables = [_1]
>> Text rule ( _1 ) |-->_1`ocltype LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->_1`ocltype RHS = _1`ocltype
>>> found metafeature _1`ocltype for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule { _1 } |-->Set<when> _1 dictorsetmaker LHS variables = [_1]
>> Text rule { _1 } |-->Set<when> _1 dictorsetmaker LHS tokens = [{, _1, }]
>> Text rule { _1 } |-->Set<when> _1 dictorsetmaker RHS = Set<when> _1 dictorsetmaker
+++ Condition lexicals:: [_1, dictorsetmaker]
>***> Rule with condition: [_1 dictorsetmaker]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule r _1 |-->String LHS variables = [_1]
>> Text rule r _1 |-->String LHS tokens = [r, _1]
>> Text rule r _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule R _1 |-->String LHS variables = [_1]
>> Text rule R _1 |-->String LHS tokens = [R, _1]
>> Text rule R _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule f _1 |-->String LHS variables = [_1]
>> Text rule f _1 |-->String LHS tokens = [f, _1]
>> Text rule f _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->Sequence<when> _2 matches .shape LHS variables = [_1, _2]
>> Text rule _1 _2 |-->Sequence<when> _2 matches .shape LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->Sequence<when> _2 matches .shape RHS = Sequence<when> _2 matches .shape
+++ Condition lexicals:: [_2, matches, .shape]
>***> Rule with condition: [_2 matches .shape]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->OclIterator<when> _1 generator, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->OclIterator<when> _1 generator, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->OclIterator<when> _1 generator, _2 trailer RHS = OclIterator<when> _1 generator, _2 trailer
+++ Condition lexicals:: [_1, generator, ,, _2, trailer]
>***> Rule with condition: [_1 generator, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->_1<when> _1 Class, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_1<when> _1 Class, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_1<when> _1 Class, _2 trailer RHS = _1<when> _1 Class, _2 trailer
+++ Condition lexicals:: [_1, Class, ,, _2, trailer]
>***> Rule with condition: [_1 Class, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->_2`mapTrailerType<when> _1 Map, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`mapTrailerType<when> _1 Map, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`mapTrailerType<when> _1 Map, _2 trailer RHS = _2`mapTrailerType<when> _1 Map, _2 trailer
+++ Condition lexicals:: [_1, Map, ,, _2, trailer]
>>> found metafeature _2`mapTrailerType for _2`
>***> Rule with condition: [_1 Map, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`mapTrailerType]
>> Text rule _1 _2 |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer RHS = _2`sequenceTrailerType<when> _1 Sequence, _2 trailer
+++ Condition lexicals:: [_1, Sequence, ,, _2, trailer]
>>> found metafeature _2`sequenceTrailerType for _2`
>***> Rule with condition: [_1 Sequence, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`sequenceTrailerType]
>> Text rule _1 _2 |-->_2`trailerOclType<when> _1 atom, _2 trailer LHS variables = [_1, _2]
>> Text rule _1 _2 |-->_2`trailerOclType<when> _1 atom, _2 trailer LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->_2`trailerOclType<when> _1 atom, _2 trailer RHS = _2`trailerOclType<when> _1 atom, _2 trailer
+++ Condition lexicals:: [_1, atom, ,, _2, trailer]
>>> found metafeature _2`trailerOclType for _2`
>***> Rule with condition: [_1 atom, _2 trailer]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`trailerOclType]
>> Text rule _1 |-->int<when> _1 int LHS variables = [_1]
>> Text rule _1 |-->int<when> _1 int LHS tokens = [_1]
>> Text rule _1 |-->int<when> _1 int RHS = int<when> _1 int
+++ Condition lexicals:: [_1, int]
>***> Rule with condition: [_1 int]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->double<when> _1 real LHS variables = [_1]
>> Text rule _1 |-->double<when> _1 real LHS tokens = [_1]
>> Text rule _1 |-->double<when> _1 real RHS = double<when> _1 real
+++ Condition lexicals:: [_1, real]
>***> Rule with condition: [_1 real]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->String<when> _1 String LHS variables = [_1]
>> Text rule _1 |-->String<when> _1 String LHS tokens = [_1]
>> Text rule _1 |-->String<when> _1 String RHS = String<when> _1 String
+++ Condition lexicals:: [_1, String]
>***> Rule with condition: [_1 String]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->Sequence<when> _1`isSequenceExpression true LHS variables = [_1]
>> Text rule _1 |-->Sequence<when> _1`isSequenceExpression true LHS tokens = [_1]
>> Text rule _1 |-->Sequence<when> _1`isSequenceExpression true RHS = Sequence<when> _1`isSequenceExpression true
+++ Condition lexicals:: [_1, `, isSequenceExpression, true]
>***> Rule with condition: [_1`isSequenceExpression true]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`ocltype<when> _1 testlist_star_expr LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 testlist_star_expr LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 testlist_star_expr RHS = _1`ocltype<when> _1 testlist_star_expr
+++ Condition lexicals:: [_1, testlist_star_expr]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 testlist_star_expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 testlist RHS = _1`ocltype<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 trailer LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 trailer LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 trailer RHS = _1`ocltype<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 arglist LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 arglist LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 arglist RHS = _1`ocltype<when> _1 arglist
+++ Condition lexicals:: [_1, arglist]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 arglist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 argument LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 argument LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 argument RHS = _1`ocltype<when> _1 argument
+++ Condition lexicals:: [_1, argument]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 argument]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 arguments RHS = _1`ocltype<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 test RHS = _1`ocltype<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 logical_test RHS = _1`ocltype<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 comparison RHS = _1`ocltype<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 expr RHS = _1`ocltype<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 atom LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 atom LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 atom RHS = _1`ocltype<when> _1 atom
+++ Condition lexicals:: [_1, atom]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 atom]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 name LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 name LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 name RHS = _1`ocltype<when> _1 name
+++ Condition lexicals:: [_1, name]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 name]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 subscriptlist LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 subscriptlist LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 subscriptlist RHS = _1`ocltype<when> _1 subscriptlist
+++ Condition lexicals:: [_1, subscriptlist]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 subscriptlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`ocltype<when> _1 subscript LHS variables = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 subscript LHS tokens = [_1]
>> Text rule _1 |-->_1`ocltype<when> _1 subscript RHS = _1`ocltype<when> _1 subscript
+++ Condition lexicals:: [_1, subscript]
>>> found metafeature _1`ocltype for _1`
>***> Rule with condition: [_1 subscript]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`ocltype]
>> Text rule _1 |-->_1`numberType<when> _1 number LHS variables = [_1]
>> Text rule _1 |-->_1`numberType<when> _1 number LHS tokens = [_1]
>> Text rule _1 |-->_1`numberType<when> _1 number RHS = _1`numberType<when> _1 number
+++ Condition lexicals:: [_1, number]
>>> found metafeature _1`numberType for _1`
>***> Rule with condition: [_1 number]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`numberType]
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |-->OclAny LHS variables = [_*]
>> Text rule _* |-->OclAny LHS tokens = [_*]
>> Text rule _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->int<when> _1 int LHS variables = [_1]
>> Text rule _1 |-->int<when> _1 int LHS tokens = [_1]
>> Text rule _1 |-->int<when> _1 int RHS = int<when> _1 int
+++ Condition lexicals:: [_1, int]
>***> Rule with condition: [_1 int]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->double LHS variables = [_1]
>> Text rule _1 |-->double LHS tokens = [_1]
>> Text rule _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosin _1 |-->double LHS variables = [_1]
>> Text rule . cosin _1 |-->double LHS tokens = [., cosin, _1]
>> Text rule . cosin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sin _1 |-->double LHS variables = [_1]
>> Text rule . sin _1 |-->double LHS tokens = [., sin, _1]
>> Text rule . sin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tan _1 |-->double LHS variables = [_1]
>> Text rule . tan _1 |-->double LHS tokens = [., tan, _1]
>> Text rule . tan _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ceil _1 |-->int LHS variables = [_1]
>> Text rule . ceil _1 |-->int LHS tokens = [., ceil, _1]
>> Text rule . ceil _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . floor _1 |-->int LHS variables = [_1]
>> Text rule . floor _1 |-->int LHS tokens = [., floor, _1]
>> Text rule . floor _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . trunc _1 |-->int LHS variables = [_1]
>> Text rule . trunc _1 |-->int LHS tokens = [., trunc, _1]
>> Text rule . trunc _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sqrt _1 |-->double LHS variables = [_1]
>> Text rule . sqrt _1 |-->double LHS tokens = [., sqrt, _1]
>> Text rule . sqrt _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cbrt _1 |-->double LHS variables = [_1]
>> Text rule . cbrt _1 |-->double LHS tokens = [., cbrt, _1]
>> Text rule . cbrt _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . exp _1 |-->double LHS variables = [_1]
>> Text rule . exp _1 |-->double LHS tokens = [., exp, _1]
>> Text rule . exp _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log _1 |-->double LHS variables = [_1]
>> Text rule . log _1 |-->double LHS tokens = [., log, _1]
>> Text rule . log _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . log10 _1 |-->double LHS variables = [_1]
>> Text rule . log10 _1 |-->double LHS tokens = [., log10, _1]
>> Text rule . log10 _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acos _1 |-->double LHS variables = [_1]
>> Text rule . acos _1 |-->double LHS tokens = [., acos, _1]
>> Text rule . acos _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asin _1 |-->double LHS variables = [_1]
>> Text rule . asin _1 |-->double LHS tokens = [., asin, _1]
>> Text rule . asin _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atan _1 |-->double LHS variables = [_1]
>> Text rule . atan _1 |-->double LHS tokens = [., atan, _1]
>> Text rule . atan _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . acosh _1 |-->double LHS variables = [_1]
>> Text rule . acosh _1 |-->double LHS tokens = [., acosh, _1]
>> Text rule . acosh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . asinh _1 |-->double LHS variables = [_1]
>> Text rule . asinh _1 |-->double LHS tokens = [., asinh, _1]
>> Text rule . asinh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . atanh _1 |-->double LHS variables = [_1]
>> Text rule . atanh _1 |-->double LHS tokens = [., atanh, _1]
>> Text rule . atanh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . cosh _1 |-->double LHS variables = [_1]
>> Text rule . cosh _1 |-->double LHS tokens = [., cosh, _1]
>> Text rule . cosh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sinh _1 |-->double LHS variables = [_1]
>> Text rule . sinh _1 |-->double LHS tokens = [., sinh, _1]
>> Text rule . sinh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tanh _1 |-->double LHS variables = [_1]
>> Text rule . tanh _1 |-->double LHS tokens = [., tanh, _1]
>> Text rule . tanh _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . pow _1 |-->double LHS variables = [_1]
>> Text rule . pow _1 |-->double LHS tokens = [., pow, _1]
>> Text rule . pow _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . comb _1 |-->int LHS variables = [_1]
>> Text rule . comb _1 |-->int LHS tokens = [., comb, _1]
>> Text rule . comb _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fabs _1 |-->double LHS variables = [_1]
>> Text rule . fabs _1 |-->double LHS tokens = [., fabs, _1]
>> Text rule . fabs _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . factorial _1 |-->int LHS variables = [_1]
>> Text rule . factorial _1 |-->int LHS tokens = [., factorial, _1]
>> Text rule . factorial _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fsum _1 |-->double LHS variables = [_1]
>> Text rule . fsum _1 |-->double LHS tokens = [., fsum, _1]
>> Text rule . fsum _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . prod _1 |-->double LHS variables = [_1]
>> Text rule . prod _1 |-->double LHS tokens = [., prod, _1]
>> Text rule . prod _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gcd _1 |-->int LHS variables = [_1]
>> Text rule . gcd _1 |-->int LHS tokens = [., gcd, _1]
>> Text rule . gcd _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . lcm _1 |-->int LHS variables = [_1]
>> Text rule . lcm _1 |-->int LHS tokens = [., lcm, _1]
>> Text rule . lcm _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . count _1 |-->int LHS variables = [_1]
>> Text rule . count _1 |-->int LHS tokens = [., count, _1]
>> Text rule . count _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . index _1 |-->int LHS variables = [_1]
>> Text rule . index _1 |-->int LHS tokens = [., index, _1]
>> Text rule . index _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdisjoint _1 |-->boolean LHS variables = [_1]
>> Text rule . isdisjoint _1 |-->boolean LHS tokens = [., isdisjoint, _1]
>> Text rule . isdisjoint _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issubset _1 |-->boolean LHS variables = [_1]
>> Text rule . issubset _1 |-->boolean LHS tokens = [., issubset, _1]
>> Text rule . issubset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . issuperset _1 |-->boolean LHS variables = [_1]
>> Text rule . issuperset _1 |-->boolean LHS tokens = [., issuperset, _1]
>> Text rule . issuperset _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . clear _1 |-->Set LHS variables = [_1]
>> Text rule . clear _1 |-->Set LHS tokens = [., clear, _1]
>> Text rule . clear _1 |-->Set RHS = Set
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . items _1 |-->Sequence LHS variables = [_1]
>> Text rule . items _1 |-->Sequence LHS tokens = [., items, _1]
>> Text rule . items _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . upper _1 |-->String LHS variables = [_1]
>> Text rule . upper _1 |-->String LHS tokens = [., upper, _1]
>> Text rule . upper _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . lower _1 |-->String LHS variables = [_1]
>> Text rule . lower _1 |-->String LHS tokens = [., lower, _1]
>> Text rule . lower _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . split _1 |-->Sequence LHS variables = [_1]
>> Text rule . split _1 |-->Sequence LHS tokens = [., split, _1]
>> Text rule . split _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . strip _1 |-->String LHS variables = [_1]
>> Text rule . strip _1 |-->String LHS tokens = [., strip, _1]
>> Text rule . strip _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . replace _1 |-->String LHS variables = [_1]
>> Text rule . replace _1 |-->String LHS tokens = [., replace, _1]
>> Text rule . replace _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . find _1 |-->int LHS variables = [_1]
>> Text rule . find _1 |-->int LHS tokens = [., find, _1]
>> Text rule . find _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . startswith _1 |-->boolean LHS variables = [_1]
>> Text rule . startswith _1 |-->boolean LHS tokens = [., startswith, _1]
>> Text rule . startswith _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . endswith _1 |-->boolean LHS variables = [_1]
>> Text rule . endswith _1 |-->boolean LHS tokens = [., endswith, _1]
>> Text rule . endswith _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isalpha _1 |-->boolean LHS variables = [_1]
>> Text rule . isalpha _1 |-->boolean LHS tokens = [., isalpha, _1]
>> Text rule . isalpha _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isnumeric _1 |-->boolean LHS variables = [_1]
>> Text rule . isnumeric _1 |-->boolean LHS tokens = [., isnumeric, _1]
>> Text rule . isnumeric _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isalnum _1 |-->boolean LHS variables = [_1]
>> Text rule . isalnum _1 |-->boolean LHS tokens = [., isalnum, _1]
>> Text rule . isalnum _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . islower _1 |-->boolean LHS variables = [_1]
>> Text rule . islower _1 |-->boolean LHS tokens = [., islower, _1]
>> Text rule . islower _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isupper _1 |-->boolean LHS variables = [_1]
>> Text rule . isupper _1 |-->boolean LHS tokens = [., isupper, _1]
>> Text rule . isupper _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isspace _1 |-->boolean LHS variables = [_1]
>> Text rule . isspace _1 |-->boolean LHS tokens = [., isspace, _1]
>> Text rule . isspace _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdigit _1 |-->boolean LHS variables = [_1]
>> Text rule . isdigit _1 |-->boolean LHS tokens = [., isdigit, _1]
>> Text rule . isdigit _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . isdecimal _1 |-->boolean LHS variables = [_1]
>> Text rule . isdecimal _1 |-->boolean LHS tokens = [., isdecimal, _1]
>> Text rule . isdecimal _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . readable _1 |-->boolean LHS variables = [_1]
>> Text rule . readable _1 |-->boolean LHS tokens = [., readable, _1]
>> Text rule . readable _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . writable _1 |-->boolean LHS variables = [_1]
>> Text rule . writable _1 |-->boolean LHS tokens = [., writable, _1]
>> Text rule . writable _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . read _1 |-->String LHS variables = [_1]
>> Text rule . read _1 |-->String LHS tokens = [., read, _1]
>> Text rule . read _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tell _1 |-->int LHS variables = [_1]
>> Text rule . tell _1 |-->int LHS tokens = [., tell, _1]
>> Text rule . tell _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . readline _1 |-->String LHS variables = [_1]
>> Text rule . readline _1 |-->String LHS tokens = [., readline, _1]
>> Text rule . readline _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . Random _1 |-->OclRandom LHS variables = [_1]
>> Text rule . Random _1 |-->OclRandom LHS tokens = [., Random, _1]
>> Text rule . Random _1 |-->OclRandom RHS = OclRandom
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . gauss _1 |-->double LHS variables = [_1]
>> Text rule . gauss _1 |-->double LHS tokens = [., gauss, _1]
>> Text rule . gauss _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . normalvariate _1 |-->double LHS variables = [_1]
>> Text rule . normalvariate _1 |-->double LHS tokens = [., normalvariate, _1]
>> Text rule . normalvariate _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . uniform _1 |-->double LHS variables = [_1]
>> Text rule . uniform _1 |-->double LHS tokens = [., uniform, _1]
>> Text rule . uniform _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randrange _1 |-->int LHS variables = [_1]
>> Text rule . randrange _1 |-->int LHS tokens = [., randrange, _1]
>> Text rule . randrange _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . random _1 |-->double LHS variables = [_1]
>> Text rule . random _1 |-->double LHS tokens = [., random, _1]
>> Text rule . random _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . randint _1 |-->int LHS variables = [_1]
>> Text rule . randint _1 |-->int LHS tokens = [., randint, _1]
>> Text rule . randint _1 |-->int RHS = int
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . choices _1 |-->Sequence LHS variables = [_1]
>> Text rule . choices _1 |-->Sequence LHS tokens = [., choices, _1]
>> Text rule . choices _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . sample _1 |-->Sequence LHS variables = [_1]
>> Text rule . sample _1 |-->Sequence LHS tokens = [., sample, _1]
>> Text rule . sample _1 |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . today _1 |-->OclDate LHS variables = [_1]
>> Text rule . today _1 |-->OclDate LHS tokens = [., today, _1]
>> Text rule . today _1 |-->OclDate RHS = OclDate
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . now _1 |-->OclDate LHS variables = [_1]
>> Text rule . now _1 |-->OclDate LHS tokens = [., now, _1]
>> Text rule . now _1 |-->OclDate RHS = OclDate
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fromtimestamp _1 |-->OclDate LHS variables = [_1]
>> Text rule . fromtimestamp _1 |-->OclDate LHS tokens = [., fromtimestamp, _1]
>> Text rule . fromtimestamp _1 |-->OclDate RHS = OclDate
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . fromisoformat _1 |-->OclDate LHS variables = [_1]
>> Text rule . fromisoformat _1 |-->OclDate LHS tokens = [., fromisoformat, _1]
>> Text rule . fromisoformat _1 |-->OclDate RHS = OclDate
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . max _1 |-->double LHS variables = [_1]
>> Text rule . max _1 |-->double LHS tokens = [., max, _1]
>> Text rule . max _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . min _1 |-->double LHS variables = [_1]
>> Text rule . min _1 |-->double LHS tokens = [., min, _1]
>> Text rule . min _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . mean _1 |-->double LHS variables = [_1]
>> Text rule . mean _1 |-->double LHS tokens = [., mean, _1]
>> Text rule . mean _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . median _1 |-->double LHS variables = [_1]
>> Text rule . median _1 |-->double LHS tokens = [., median, _1]
>> Text rule . median _1 |-->double RHS = double
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . head _1 |-->Map LHS variables = [_1]
>> Text rule . head _1 |-->Map LHS tokens = [., head, _1]
>> Text rule . head _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . tail _1 |-->Map LHS variables = [_1]
>> Text rule . tail _1 |-->Map LHS tokens = [., tail, _1]
>> Text rule . tail _1 |-->Map RHS = Map
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . at _1 |-->OclAny LHS variables = [_1]
>> Text rule . at _1 |-->OclAny LHS tokens = [., at, _1]
>> Text rule . at _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . capitalize _1 |-->String LHS variables = [_1]
>> Text rule . capitalize _1 |-->String LHS tokens = [., capitalize, _1]
>> Text rule . capitalize _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . join _1 |-->String LHS variables = [_1]
>> Text rule . join _1 |-->String LHS tokens = [., join, _1]
>> Text rule . join _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . title _1 |-->String LHS variables = [_1]
>> Text rule . title _1 |-->String LHS tokens = [., title, _1]
>> Text rule . title _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . swapcase _1 |-->String LHS variables = [_1]
>> Text rule . swapcase _1 |-->String LHS tokens = [., swapcase, _1]
>> Text rule . swapcase _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . lstrip_1 |-->String LHS variables = []
>> Text rule . lstrip_1 |-->String LHS tokens = [., lstrip_1]
>> Text rule . lstrip_1 |-->String RHS = String
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule . rstrip _1 |-->String LHS variables = [_1]
>> Text rule . rstrip _1 |-->String LHS tokens = [., rstrip, _1]
>> Text rule . rstrip _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . istitle _1 |-->boolean LHS variables = [_1]
>> Text rule . istitle _1 |-->boolean LHS tokens = [., istitle, _1]
>> Text rule . istitle _1 |-->boolean RHS = boolean
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . rjust _1 |-->String LHS variables = [_1]
>> Text rule . rjust _1 |-->String LHS tokens = [., rjust, _1]
>> Text rule . rjust _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . ljust _1 |-->String LHS variables = [_1]
>> Text rule . ljust _1 |-->String LHS tokens = [., ljust, _1]
>> Text rule . ljust _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . format _1 |-->String LHS variables = [_1]
>> Text rule . format _1 |-->String LHS tokens = [., format, _1]
>> Text rule . format _1 |-->String RHS = String
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 |-->OclAny LHS variables = [_1]
>> Text rule . _1 |-->OclAny LHS tokens = [., _1]
>> Text rule . _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule . _1 _2 |-->OclAny LHS variables = [_1, _2]
>> Text rule . _1 _2 |-->OclAny LHS tokens = [., _1, _2]
>> Text rule . _1 _2 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule . _* |-->OclAny LHS variables = [_*]
>> Text rule . _* |-->OclAny LHS tokens = [., _*]
>> Text rule . _* |-->OclAny RHS = OclAny
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`argsOclType<when> _1 arguments LHS variables = [_1]
>> Text rule _1 |-->_1`argsOclType<when> _1 arguments LHS tokens = [_1]
>> Text rule _1 |-->_1`argsOclType<when> _1 arguments RHS = _1`argsOclType<when> _1 arguments
+++ Condition lexicals:: [_1, arguments]
>>> found metafeature _1`argsOclType for _1`
>***> Rule with condition: [_1 arguments]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`argsOclType]
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule ( ) |-->OclAny LHS variables = []
>> Text rule ( ) |-->OclAny LHS tokens = [(, )]
>> Text rule ( ) |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule ( _1 ) |-->OclAny LHS variables = [_1]
>> Text rule ( _1 ) |-->OclAny LHS tokens = [(, _1, )]
>> Text rule ( _1 ) |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule [ ] |-->OclAny LHS variables = []
>> Text rule [ ] |-->OclAny LHS tokens = [[, ]]
>> Text rule [ ] |-->OclAny RHS = OclAny
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule [ _1 ] |-->_1`subslistOclType LHS variables = [_1]
>> Text rule [ _1 ] |-->_1`subslistOclType LHS tokens = [[, _1, ]]
>> Text rule [ _1 ] |-->_1`subslistOclType RHS = _1`subslistOclType
>>> found metafeature _1`subslistOclType for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`subslistOclType]
>> Text rule : |-->Sequence LHS variables = []
>> Text rule : |-->Sequence LHS tokens = [:]
>> Text rule : |-->Sequence RHS = Sequence
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->OclAny LHS variables = [_1]
>> Text rule _1 |-->OclAny LHS tokens = [_1]
>> Text rule _1 |-->OclAny RHS = OclAny
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule : _* |-->Sequence LHS variables = [_*]
>> Text rule : _* |-->Sequence LHS tokens = [:, _*]
>> Text rule : _* |-->Sequence RHS = Sequence
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 , : |-->Sequence LHS variables = [_1]
>> Text rule _1 , : |-->Sequence LHS tokens = [_1, ,, :]
>> Text rule _1 , : |-->Sequence RHS = Sequence
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 , _* |-->_*`recurse LHS variables = [_1, _*]
>> Text rule _1 , _* |-->_*`recurse LHS tokens = [_1, ,, _*]
>> Text rule _1 , _* |-->_*`recurse RHS = _*`recurse
>>> found metafeature _*`recurse for _*`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`recurse]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 as _2 |--> LHS variables = [_1, _2]
>> Text rule _1 as _2 |--> LHS tokens = [_1, as, _2]
>> Text rule _1 as _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<when> _1 funcdef LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 funcdef LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 funcdef RHS = _1<when> _1 funcdef
+++ Condition lexicals:: [_1, funcdef]
>***> Rule with condition: [_1 funcdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`functionDefinitions<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`functionDefinitions<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`functionDefinitions<when> _1 compound_stmt RHS = _1`functionDefinitions<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`functionDefinitions for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`functionDefinitions]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 |--> LHS variables = [_1, _2]
>> Text rule if _1 : _2 |--> LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |--> LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |--> LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |--> LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |--> LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |--> RHS = 
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: []
>> Text rule while _1 : _2 |--> LHS variables = [_1, _2]
>> Text rule while _1 : _2 |--> LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 : _3 |--> LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |--> LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n LHS variables = [_1, _2, _3, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n LHS tokens = [async, def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n RHS =   operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n
>>> found metafeature _2`defaultParamSettings for _2`
>>> found metafeature _3`ocltype for _3`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_2`defaultParamSettings, _3`ocltype]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n LHS variables = [_1, _2, _3, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n LHS tokens = [def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n RHS =   operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n
>>> found metafeature _2`defaultParamSettings for _2`
>>> found metafeature _3`ocltype for _3`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_2`defaultParamSettings, _3`ocltype]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true LHS tokens = [async, def, _1, (, _2, ), :, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true RHS =   operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true
+++ Condition lexicals:: [_3, `, hasValueReturn, true]
>>> found metafeature _2`defaultParamSettings for _2`
>***> Rule with condition: [_3`hasValueReturn true]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`defaultParamSettings]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n LHS tokens = [async, def, _1, (, _2, ), :, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n RHS =   operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n
>>> found metafeature _2`defaultParamSettings for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`defaultParamSettings]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true LHS variables = [_1, _2, _3]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true LHS tokens = [def, _1, (, _2, ), :, _3]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true RHS =   operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true
+++ Condition lexicals:: [_3, `, hasValueReturn, true]
>>> found metafeature _2`defaultParamSettings for _2`
>***> Rule with condition: [_3`hasValueReturn true]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`defaultParamSettings]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n LHS tokens = [def, _1, (, _2, ), :, _3]
>> Text rule def _1 ( _2 ) : _3 |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n RHS =   operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n
>>> found metafeature _2`defaultParamSettings for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`defaultParamSettings]
>> Text rule async def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS tokens = [async, def, _1, (, ), ->, _2, :, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n RHS =   operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
>>> found metafeature _2`ocltype for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS tokens = [def, _1, (, ), ->, _2, :, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n RHS =   operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
>>> found metafeature _2`ocltype for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule async def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS variables = [_1, _2]
>> Text rule async def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS tokens = [async, def, _1, (, ), :, _2]
>> Text rule async def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true RHS =   operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
+++ Condition lexicals:: [_2, `, hasValueReturn, true]
>***> Rule with condition: [_2`hasValueReturn true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule async def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS variables = [_1, _2]
>> Text rule async def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS tokens = [async, def, _1, (, ), :, _2]
>> Text rule async def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n RHS =   operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule def _1 ( ) : _2 |-->  operation _1(_position_ : int) : OclAny\n  pre: true post: true\n  activity:\n    var _yieldCount_ : int := 0;\n_2;\n\n<when> _2`hasYieldStatement true <action> _1 generator LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1(_position_ : int) : OclAny\n  pre: true post: true\n  activity:\n    var _yieldCount_ : int := 0;\n_2;\n\n<when> _2`hasYieldStatement true <action> _1 generator LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1(_position_ : int) : OclAny\n  pre: true post: true\n  activity:\n    var _yieldCount_ : int := 0;\n_2;\n\n<when> _2`hasYieldStatement true <action> _1 generator RHS =   operation _1(_position_ : int) : OclAny\n  pre: true post: true\n  activity:\n    var _yieldCount_ : int := 0;\n_2;\n\n<when> _2`hasYieldStatement true <action> _1 generator
+++ Action lexicals:: [_1, generator]
>> Rule actions are:  _1 generator [_1 generator]
+++ Condition lexicals:: [_2, `, hasYieldStatement, true]
>> Global variables: []
>***> Rule with condition: [_2`hasYieldStatement true] and actions: [_1 generator]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true RHS =   operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
+++ Condition lexicals:: [_2, `, hasValueReturn, true]
>***> Rule with condition: [_2`hasValueReturn true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n RHS =   operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule def __init__ ( _1 ) : _2 |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n LHS variables = [_1, _2]
>> Text rule def __init__ ( _1 ) : _2 |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n LHS tokens = [def, __init__, (, _1, ), :, _2]
>> Text rule def __init__ ( _1 ) : _2 |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n RHS = _2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n
>> These will be treated as global variables: [_$]
>>> found metafeature _1`parametersTail for _1`
>>> found metafeature _2`attributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`parametersTail, _2`attributeDefinitions]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->\n  operation _1(_2`parametersTail) : _3`ocltype\n  pre: true post: true\n  activity:\n_4;\n\n LHS variables = [_1, _2, _3, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->\n  operation _1(_2`parametersTail) : _3`ocltype\n  pre: true post: true\n  activity:\n_4;\n\n LHS tokens = [def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->\n  operation _1(_2`parametersTail) : _3`ocltype\n  pre: true post: true\n  activity:\n_4;\n\n RHS = \n  operation _1(_2`parametersTail) : _3`ocltype\n  pre: true post: true\n  activity:\n_4;\n\n
>>> found metafeature _2`parametersTail for _2`
>>> found metafeature _3`ocltype for _3`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_2`parametersTail, _3`ocltype]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true LHS variables = [_1, _2, _3]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true LHS tokens = [def, _1, (, _2, ), :, _3]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true RHS = \n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true
+++ Condition lexicals:: [_3, `, hasValueReturn, true]
>>> found metafeature _2`parametersTail for _2`
>***> Rule with condition: [_3`hasValueReturn true]
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`parametersTail]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n LHS tokens = [def, _1, (, _2, ), :, _3]
>> Text rule def _1 ( _2 ) : _3 |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n RHS = \n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n
>>> found metafeature _2`parametersTail for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`parametersTail]
>> Text rule def _1 ( ) -> _2 : _3 |-->\n  static operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS variables = [_1, _2, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->\n  static operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n LHS tokens = [def, _1, (, ), ->, _2, :, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->\n  static operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n RHS = \n  static operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
>>> found metafeature _2`ocltype for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true RHS = \n  static operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
+++ Condition lexicals:: [_2, `, hasValueReturn, true]
>***> Rule with condition: [_2`hasValueReturn true]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->\n  static operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n RHS = \n  static operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1<when> _1 classdef LHS variables = [_1]
>> Text rule _1 |-->_1<when> _1 classdef LHS tokens = [_1]
>> Text rule _1 |-->_1<when> _1 classdef RHS = _1<when> _1 classdef
+++ Condition lexicals:: [_1, classdef]
>***> Rule with condition: [_1 classdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`classDefinitions<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`classDefinitions<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`classDefinitions<when> _1 compound_stmt RHS = _1`classDefinitions<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`classDefinitions for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classDefinitions]
>> Text rule _1 |-->_1`classDefinitions<when> _1 funcdef LHS variables = [_1]
>> Text rule _1 |-->_1`classDefinitions<when> _1 funcdef LHS tokens = [_1]
>> Text rule _1 |-->_1`classDefinitions<when> _1 funcdef RHS = _1`classDefinitions<when> _1 funcdef
+++ Condition lexicals:: [_1, funcdef]
>>> found metafeature _1`classDefinitions for _1`
>***> Rule with condition: [_1 funcdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classDefinitions]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_4;\n\n}\n\n LHS variables = [_1, _2, _3, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_4;\n\n}\n\n LHS tokens = [async, def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_4;\n\n}\n\n RHS = class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_4;\n\n}\n\n
>>> found metafeature _2`typedargslistAttributes for _2`
>>> found metafeature _2`typedargslistSettings for _2`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_2`typedargslistAttributes, _2`typedargslistSettings]
>> Text rule async def _1 ( _2 ) : _3 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n LHS tokens = [async, def, _1, (, _2, ), :, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n RHS = class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n
>>> found metafeature _2`typedargslistAttributes for _2`
>>> found metafeature _2`typedargslistSettings for _2`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`typedargslistAttributes, _2`typedargslistSettings]
>> Text rule async def _1 ( ) -> _2 : _3 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n LHS tokens = [async, def, _1, (, ), ->, _2, :, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n RHS = class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule async def _1 ( ) : _2 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_2;\n\n}\n\n LHS variables = [_1, _2]
>> Text rule async def _1 ( ) : _2 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_2;\n\n}\n\n LHS tokens = [async, def, _1, (, ), :, _2]
>> Text rule async def _1 ( ) : _2 |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_2;\n\n}\n\n RHS = class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_2;\n\n}\n\n
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 |--> LHS variables = [_1, _2]
>> Text rule if _1 : _2 |--> LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _3 |--> LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |--> LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule if _1 : _2 _* |--> LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |--> LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |--> RHS = 
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: []
>> Text rule while _1 : _2 |--> LHS variables = [_1, _2]
>> Text rule while _1 : _2 |--> LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |--> RHS = 
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: []
>> Text rule for _1 in _2 : _3 |--> LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |--> LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |--> RHS = 
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule class _1 ( Enum ) : _3 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class LHS variables = [_1, _3]
>> Text rule class _1 ( Enum ) : _3 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class LHS tokens = [class, _1, (, Enum, ), :, _3]
>> Text rule class _1 ( Enum ) : _3 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class RHS = class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class
+++ Action lexicals:: [_1, Class]
>> Rule actions are:  _1 Class [_1 Class]
>>> found metafeature _3`classcontent for _3`
>> Global variables: []
>***> Rule variables are: [_1, _3]
>***> Rule metafeatures are: [_3`classcontent]
>> Text rule class _1 ( _2 ) : _3 |-->class _1 extends _2 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class LHS variables = [_1, _2, _3]
>> Text rule class _1 ( _2 ) : _3 |-->class _1 extends _2 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class LHS tokens = [class, _1, (, _2, ), :, _3]
>> Text rule class _1 ( _2 ) : _3 |-->class _1 extends _2 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class RHS = class _1 extends _2 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class
+++ Action lexicals:: [_1, Class]
>> Rule actions are:  _1 Class [_1 Class]
>>> found metafeature _3`classcontent for _3`
>> Global variables: []
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`classcontent]
>> Text rule class _1 ( ) : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class LHS variables = [_1, _2]
>> Text rule class _1 ( ) : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class LHS tokens = [class, _1, (, ), :, _2]
>> Text rule class _1 ( ) : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class RHS = class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class
+++ Action lexicals:: [_1, Class]
>> Rule actions are:  _1 Class [_1 Class]
>>> found metafeature _2`classcontent for _2`
>> Global variables: []
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`classcontent]
>> Text rule class _1 : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1 LHS variables = [_1, _2]
>> Text rule class _1 : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1 LHS tokens = [class, _1, :, _2]
>> Text rule class _1 : _2 |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1 RHS = class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1
+++ Action lexicals:: [_1, Class, ,, _$, _1]
>> Rule actions are:  _1 Class, _$ _1 [_1 Class, _$ _1]
>>> found metafeature _2`classcontent for _2`
>> Global variables: [_$]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`classcontent]
>> Text rule _1 _* |-->_1`classcontent_*`classcontent<when> _1 stmt LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1`classcontent_*`classcontent<when> _1 stmt LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1`classcontent_*`classcontent<when> _1 stmt RHS = _1`classcontent_*`classcontent<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _*`classcontent for _*`
>>> found metafeature _1`classcontent for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`classcontent, _1`classcontent]
>> Text rule _1 |-->_1`classcontent<when> _1 stmt LHS variables = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 stmt RHS = _1`classcontent<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _1`classcontent for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classcontent]
>> Text rule _1 |-->_1`classcontent<when> _1 simple_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 simple_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 simple_stmt RHS = _1`classcontent<when> _1 simple_stmt
+++ Condition lexicals:: [_1, simple_stmt]
>>> found metafeature _1`classcontent for _1`
>***> Rule with condition: [_1 simple_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classcontent]
>> Text rule _1 |-->_1`classcontent<when> _1 small_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 small_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 small_stmt RHS = _1`classcontent<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _1`classcontent for _1`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classcontent]
>> Text rule _1 |-->_1`classcontent<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`classcontent<when> _1 compound_stmt RHS = _1`classcontent<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`classcontent for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`classcontent]
>> Text rule _1 |-->_1`methodDefinition<when> _1 funcdef LHS variables = [_1]
>> Text rule _1 |-->_1`methodDefinition<when> _1 funcdef LHS tokens = [_1]
>> Text rule _1 |-->_1`methodDefinition<when> _1 funcdef RHS = _1`methodDefinition<when> _1 funcdef
+++ Condition lexicals:: [_1, funcdef]
>>> found metafeature _1`methodDefinition for _1`
>***> Rule with condition: [_1 funcdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`methodDefinition]
>> Text rule _1 _2 |-->  static attribute _1 : _2`ocltype _2;\n<when> _2 assign_part <action> _1 _2`ocltype LHS variables = [_1, _2]
>> Text rule _1 _2 |-->  static attribute _1 : _2`ocltype _2;\n<when> _2 assign_part <action> _1 _2`ocltype LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->  static attribute _1 : _2`ocltype _2;\n<when> _2 assign_part <action> _1 _2`ocltype RHS =   static attribute _1 : _2`ocltype _2;\n<when> _2 assign_part <action> _1 _2`ocltype
+++ Action lexicals:: [_1, _2, `, ocltype]
>> Rule actions are:  _1 _2`ocltype [_1 _2`ocltype]
+++ Condition lexicals:: [_2, assign_part]
>>> found metafeature _2`ocltype for _2`
>> Global variables: []
>***> Rule with condition: [_2 assign_part] and actions: [_1 _2`ocltype]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`ocltype]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt RHS = _1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _*`attributeDefinitions for _*`
>>> found metafeature _1`attributeDefinitions for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`attributeDefinitions, _1`attributeDefinitions]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 stmt LHS variables = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 stmt RHS = _1`attributeDefinitions<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _1`attributeDefinitions for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`attributeDefinitions]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 simple_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 simple_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 simple_stmt RHS = _1`attributeDefinitions<when> _1 simple_stmt
+++ Condition lexicals:: [_1, simple_stmt]
>>> found metafeature _1`attributeDefinitions for _1`
>***> Rule with condition: [_1 simple_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`attributeDefinitions]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 small_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 small_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 small_stmt RHS = _1`attributeDefinitions<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _1`attributeDefinitions for _1`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`attributeDefinitions]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`attributeDefinitions<when> _1 compound_stmt RHS = _1`attributeDefinitions<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`attributeDefinitions for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`attributeDefinitions]
>> Text rule _1 |--><when> _1 funcdef LHS variables = [_1]
>> Text rule _1 |--><when> _1 funcdef LHS tokens = [_1]
>> Text rule _1 |--><when> _1 funcdef RHS = <when> _1 funcdef
+++ Condition lexicals:: [_1, funcdef]
>***> Rule with condition: [_1 funcdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 _2 |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* LHS variables = [_1, _2]
>> Text rule _1 _2 |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* LHS tokens = [_1, _2]
>> Text rule _1 _2 |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* RHS =   attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.*
+++ Condition lexicals:: [_2, assign_part, ,, _1, matches, self., *]
>>> found metafeature _1`removeSelf for _1`
>>> found metafeature _2`ocltype for _2`
>***> Rule with condition: [_2 assign_part, _1 matches self.*]
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_1`removeSelf, _2`ocltype]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt LHS variables = [_1, _*]
>> Text rule _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt LHS tokens = [_1, _*]
>> Text rule _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt RHS = _1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _*`nestedAttributeDefinitions for _*`
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`nestedAttributeDefinitions, _1`nestedAttributeDefinitions]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 stmt LHS variables = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 stmt RHS = _1`nestedAttributeDefinitions<when> _1 stmt
+++ Condition lexicals:: [_1, stmt]
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt RHS = _1`nestedAttributeDefinitions<when> _1 simple_stmt
+++ Condition lexicals:: [_1, simple_stmt]
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 simple_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 small_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 small_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 small_stmt RHS = _1`nestedAttributeDefinitions<when> _1 small_stmt
+++ Condition lexicals:: [_1, small_stmt]
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 small_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt LHS variables = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt LHS tokens = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt RHS = _1`nestedAttributeDefinitions<when> _1 compound_stmt
+++ Condition lexicals:: [_1, compound_stmt]
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 compound_stmt]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 funcdef LHS variables = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 funcdef LHS tokens = [_1]
>> Text rule _1 |-->_1`nestedAttributeDefinitions<when> _1 funcdef RHS = _1`nestedAttributeDefinitions<when> _1 funcdef
+++ Condition lexicals:: [_1, funcdef]
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule with condition: [_1 funcdef]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions LHS variables = [_1, _2, _3, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions LHS tokens = [async, def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule async def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions RHS = _4`nestedAttributeDefinitions
>>> found metafeature _4`nestedAttributeDefinitions for _4`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_4`nestedAttributeDefinitions]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions LHS variables = [_1, _2, _3, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions LHS tokens = [def, _1, (, _2, ), ->, _3, :, _4]
>> Text rule def _1 ( _2 ) -> _3 : _4 |-->_4`nestedAttributeDefinitions RHS = _4`nestedAttributeDefinitions
>>> found metafeature _4`nestedAttributeDefinitions for _4`
>***> Rule variables are: [_1, _2, _3, _4]
>***> Rule metafeatures are: [_4`nestedAttributeDefinitions]
>> Text rule async def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [async, def, _1, (, _2, ), :, _3]
>> Text rule async def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [def, _1, (, _2, ), :, _3]
>> Text rule def _1 ( _2 ) : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule async def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [async, def, _1, (, ), ->, _2, :, _3]
>> Text rule async def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [def, _1, (, ), ->, _2, :, _3]
>> Text rule def _1 ( ) -> _2 : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule async def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule async def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [async, def, _1, (, ), :, _2]
>> Text rule async def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [def, _1, (, ), :, _2]
>> Text rule def _1 ( ) : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule if _1 : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule if _1 : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [if, _1, :, _2]
>> Text rule if _1 : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule if _1 : _2 _3 |-->_2`nestedAttributeDefinitions_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule if _1 : _2 _3 |-->_2`nestedAttributeDefinitions_3`nestedAttributeDefinitions LHS tokens = [if, _1, :, _2, _3]
>> Text rule if _1 : _2 _3 |-->_2`nestedAttributeDefinitions_3`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions_3`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions, _3`nestedAttributeDefinitions]
>> Text rule if _1 : _2 _* |-->_2`nestedAttributeDefinitions_*`nestedAttributeDefinitions LHS variables = [_1, _2, _*]
>> Text rule if _1 : _2 _* |-->_2`nestedAttributeDefinitions_*`nestedAttributeDefinitions LHS tokens = [if, _1, :, _2, _*]
>> Text rule if _1 : _2 _* |-->_2`nestedAttributeDefinitions_*`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions_*`nestedAttributeDefinitions
>>> found metafeature _*`nestedAttributeDefinitions for _*`
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2, _*]
>***> Rule metafeatures are: [_*`nestedAttributeDefinitions, _2`nestedAttributeDefinitions]
>> Text rule while _1 : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule while _1 : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [while, _1, :, _2]
>> Text rule while _1 : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule for _1 in _2 : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule for _1 in _2 : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [for, _1, in, _2, :, _3]
>> Text rule for _1 in _2 : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule try : _1 |-->_1`nestedAttributeDefinitions LHS variables = [_1]
>> Text rule try : _1 |-->_1`nestedAttributeDefinitions LHS tokens = [try, :, _1]
>> Text rule try : _1 |-->_1`nestedAttributeDefinitions RHS = _1`nestedAttributeDefinitions
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule try : _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions LHS variables = [_1, _*]
>> Text rule try : _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions LHS tokens = [try, :, _1, _*]
>> Text rule try : _1 _* |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions RHS = _1`nestedAttributeDefinitions_*`nestedAttributeDefinitions
>>> found metafeature _*`nestedAttributeDefinitions for _*`
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule variables are: [_1, _*]
>***> Rule metafeatures are: [_*`nestedAttributeDefinitions, _1`nestedAttributeDefinitions]
>> Text rule elif _1 : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule elif _1 : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [elif, _1, :, _2]
>> Text rule elif _1 : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule else : _1 |-->_1`nestedAttributeDefinitions LHS variables = [_1]
>> Text rule else : _1 |-->_1`nestedAttributeDefinitions LHS tokens = [else, :, _1]
>> Text rule else : _1 |-->_1`nestedAttributeDefinitions RHS = _1`nestedAttributeDefinitions
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule except : _1 |-->_1`nestedAttributeDefinitions LHS variables = [_1]
>> Text rule except : _1 |-->_1`nestedAttributeDefinitions LHS tokens = [except, :, _1]
>> Text rule except : _1 |-->_1`nestedAttributeDefinitions RHS = _1`nestedAttributeDefinitions
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule except _1 as _2 : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule except _1 as _2 : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [except, _1, as, _2, :, _3]
>> Text rule except _1 as _2 : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule except _1 , _2 : _3 |-->_3`nestedAttributeDefinitions LHS variables = [_1, _2, _3]
>> Text rule except _1 , _2 : _3 |-->_3`nestedAttributeDefinitions LHS tokens = [except, _1, ,, _2, :, _3]
>> Text rule except _1 , _2 : _3 |-->_3`nestedAttributeDefinitions RHS = _3`nestedAttributeDefinitions
>>> found metafeature _3`nestedAttributeDefinitions for _3`
>***> Rule variables are: [_1, _2, _3]
>***> Rule metafeatures are: [_3`nestedAttributeDefinitions]
>> Text rule finally : _1 |-->_1`nestedAttributeDefinitions LHS variables = [_1]
>> Text rule finally : _1 |-->_1`nestedAttributeDefinitions LHS tokens = [finally, :, _1]
>> Text rule finally : _1 |-->_1`nestedAttributeDefinitions RHS = _1`nestedAttributeDefinitions
>>> found metafeature _1`nestedAttributeDefinitions for _1`
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`nestedAttributeDefinitions]
>> Text rule with _1 : _2 |-->_2`nestedAttributeDefinitions LHS variables = [_1, _2]
>> Text rule with _1 : _2 |-->_2`nestedAttributeDefinitions LHS tokens = [with, _1, :, _2]
>> Text rule with _1 : _2 |-->_2`nestedAttributeDefinitions RHS = _2`nestedAttributeDefinitions
>>> found metafeature _2`nestedAttributeDefinitions for _2`
>***> Rule variables are: [_1, _2]
>***> Rule metafeatures are: [_2`nestedAttributeDefinitions]
>> Text rule global _* |-->_*`attributeDecln LHS variables = [_*]
>> Text rule global _* |-->_*`attributeDecln LHS tokens = [global, _*]
>> Text rule global _* |-->_*`attributeDecln RHS = _*`attributeDecln
>>> found metafeature _*`attributeDecln for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`attributeDecln]
>> Text rule nonlocal _* |-->_*`attributeDecln LHS variables = [_*]
>> Text rule nonlocal _* |-->_*`attributeDecln LHS tokens = [nonlocal, _*]
>> Text rule nonlocal _* |-->_*`attributeDecln RHS = _*`attributeDecln
>>> found metafeature _*`attributeDecln for _*`
>***> Rule variables are: [_*]
>***> Rule metafeatures are: [_*`attributeDecln]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _* |--> LHS variables = [_*]
>> Text rule _* |--> LHS tokens = [_*]
>> Text rule _* |--> RHS = 
>***> Rule variables are: [_*]
>***> Rule metafeatures are: []
>> Text rule , |--> LHS variables = []
>> Text rule , |--> LHS tokens = [,]
>> Text rule , |--> RHS = 
>***> Rule variables are: []
>***> Rule metafeatures are: []
>> Text rule _1 |-->  attribute _1 : OclAny;\n LHS variables = [_1]
>> Text rule _1 |-->  attribute _1 : OclAny;\n LHS tokens = [_1]
>> Text rule _1 |-->  attribute _1 : OclAny;\n RHS =   attribute _1 : OclAny;\n
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule self _1 |-->_1`removeSelf<when> _1 trailer LHS variables = [_1]
>> Text rule self _1 |-->_1`removeSelf<when> _1 trailer LHS tokens = [self, _1]
>> Text rule self _1 |-->_1`removeSelf<when> _1 trailer RHS = _1`removeSelf<when> _1 trailer
+++ Condition lexicals:: [_1, trailer]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 trailer]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule . _1 |-->_1 LHS variables = [_1]
>> Text rule . _1 |-->_1 LHS tokens = [., _1]
>> Text rule . _1 |-->_1 RHS = _1
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>> Text rule _1 |-->_1`removeSelf<when> _1 testlist LHS variables = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 testlist LHS tokens = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 testlist RHS = _1`removeSelf<when> _1 testlist
+++ Condition lexicals:: [_1, testlist]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 testlist]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule _1 |-->_1`removeSelf<when> _1 test LHS variables = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 test LHS tokens = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 test RHS = _1`removeSelf<when> _1 test
+++ Condition lexicals:: [_1, test]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule _1 |-->_1`removeSelf<when> _1 logical_test LHS variables = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 logical_test LHS tokens = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 logical_test RHS = _1`removeSelf<when> _1 logical_test
+++ Condition lexicals:: [_1, logical_test]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 logical_test]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule _1 |-->_1`removeSelf<when> _1 comparison LHS variables = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 comparison LHS tokens = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 comparison RHS = _1`removeSelf<when> _1 comparison
+++ Condition lexicals:: [_1, comparison]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 comparison]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule _1 |-->_1`removeSelf<when> _1 expr LHS variables = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 expr LHS tokens = [_1]
>> Text rule _1 |-->_1`removeSelf<when> _1 expr RHS = _1`removeSelf<when> _1 expr
+++ Condition lexicals:: [_1, expr]
>>> found metafeature _1`removeSelf for _1`
>***> Rule with condition: [_1 expr]
>***> Rule variables are: [_1]
>***> Rule metafeatures are: [_1`removeSelf]
>> Text rule _1 |--> LHS variables = [_1]
>> Text rule _1 |--> LHS tokens = [_1]
>> Text rule _1 |--> RHS = 
>***> Rule variables are: [_1]
>***> Rule metafeatures are: []
>>> Parsed: 
















allUnion::
( )  |-->
( _1 )  |-->->union(Set{_1}->unionAll())
[ ]  |-->Set{}
[ _1 ]  |-->->union(Set{_1}->unionAll())

argCount::
_1  |-->_1`argCount<when> _1 trailer
_1  |-->_1`argCount<when> _1 arguments
( )  |-->0
( _1 )  |-->_1`argsCount<when> _1 arglist
( _1 )  |-->1

argList::
_1  |-->_1`argList<when> _1 trailer
_1  |-->_1`argList<when> _1 arguments
( )  |-->
( _1 )  |-->_1

argValue::
_1 = _2  |-->_2
_1  |-->_1

arglist::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

args::
* _1  |-->_1 : Sequence(OclAny)<action> _1 Sequence

argsCount::
_1 , _2 , _3 , _4 , _5  |-->9
_1 , _2 , _3 , _4  |-->7
_1 , _2 , _3  |-->5
_1 , _2  |-->3
_1  |-->1

argsOclType::
( )  |-->OclAny
( _1 )  |-->OclAny
[ ]  |-->OclAny
[ _1 ]  |-->_1`subslistOclType

argument::
_1  |-->_1

arguments::
( )  |-->()
( _1 )  |-->(_1)
[ ]  |-->()
[ _1 ]  |-->_1

asAttribute::
_1 = _2  |-->  attribute _1`parameterName : String;\n<when> _2 String, _1 1ary<action> _1`parameterName String
_1 = _2  |-->  attribute _1`parameterName : int;\n<when> _2 int, _1 1ary<action> _1`parameterName int
_1 = _2  |-->  attribute _1`parameterName : double;\n<when> _2 real, _1 1ary<action> _1`parameterName real
_1 = _2  |-->_1
*  |-->
_1  |-->_1`asAttribute<when> _1 named_parameter
_1  |-->  attribute _1 : OclAny;\n
_1 : int  |-->  attribute _1 : int;\n<action> _1 int
_1 : bool  |-->  attribute _1 : boolean;\n<action> _1 boolean
_1 : float  |-->  attribute _1 : double;\n<action> _1 real
_1 : dict  |-->  attribute _1 : Map(String,OclAny);\n<action> _1 Map
_1 : str  |-->  attribute _1 : String;\n<action> _1 String
_1 : list  |-->  attribute _1 : Sequence(OclAny);\n<action> _1 Sequence
_1 : set  |-->  attribute _1 : Set(OclAny);\n<action> _1 Set
_1 : _2  |-->  attribute _1 : _2;\n<action> _1 _2

asAttributes::
_1  |-->_1`asAttribute
_1 , _*  |-->_1`asAttribute_*`recurse

asSetting::
_1 = _2  |-->resx._1`parameterName = _1`parameterName &
*  |-->
_1  |-->_1`asSetting<when> _1 named_parameter
_1  |-->resx._1 = _1 &
_1 : int  |-->resx._1 = _1 & <action> _1 int
_1 : bool  |-->resx._1 = _1 & <action> _1 boolean
_1 : float  |-->resx._1 = _1 & <action> _1 real
_1 : dict  |-->resx._1 = _1 & <action> _1 Map
_1 : str  |-->resx._1 = _1 & <action> _1 String
_1 : list  |-->resx._1 = _1 & <action> _1 Sequence
_1 : set  |-->resx._1 = _1 & <action> _1 Set
_1 : _2  |-->resx._1 = _1 & <action> _1 _2

asSettings::
_1  |-->_1`asSetting
_1 , _*  |-->_1`asSetting_*`recurse

assertDefined::
,  |-->;
_1  |-->    skip<action> _1`defined true

assign_part::
: _1 = _2  |-->: _1`ocltype := _2
: _1  |-->: _1`ocltype
= _1 = _2  |-->:= _2; _1 := _2<when> _1`defined true
= _1 = _2  |-->:= _2; var _1 : _2`ocltype := _2<action> _1`defined true
= _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true
= _1  |-->:= _1
+= _1  |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true
+= _1  |--> + _1
-= _1  |--> - _1 ; _1`updateForm<when> _1`hasSideEffect true
-= _1  |--> - _1
*= _1  |--> * _1 ; _1`updateForm<when> _1`hasSideEffect true
*= _1  |--> * _1
%= _1  |--> mod _1 ; _1`updateForm<when> _1`hasSideEffect true
%= _1  |--> mod _1
/= _1  |--> / _1 ; _1`updateForm<when> _1`hasSideEffect true
/= _1  |--> / _1
//= _1  |--> div _1 ; _1`updateForm<when> _1`hasSideEffect true
//= _1  |--> div _1
|= _1  |--> or _1 ; _1`updateForm<when> _1`hasSideEffect true
|= _1  |--> or _1
&= _1  |--> & _1 ; _1`updateForm<when> _1`hasSideEffect true
&= _1  |--> & _1
^= _1  |--> xor _1 ; _1`updateForm<when> _1`hasSideEffect true
^= _1  |--> xor _1
**= _1  |-->->pow(_1) ; _1`updateForm<when> _1`hasSideEffect true
**= _1  |-->->pow(_1)
<<= _1  |--> * (2->pow(_1))
>>= _1  |--> div (2->pow(_1))

asyncioTrailer::
. sleep _1  |-->OclProcess.sleepSeconds_1
. create_task _1  |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess()
. run _1  |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start()

atom::
( )  |-->()
( _1 )  |-->Sequence{_1}<when> _1 multiple
( _1 )  |-->(_1)
[ ]  |-->Sequence{}
{ }  |-->Set{}
[ _1 ]  |-->_1`sequenceFormation
{ _1 }  |-->_1
` _1 `  |-->"_1"
"" _1 ""  |-->_1
- _1  |-->-_1
None  |-->null
True  |-->true
False  |-->false
inf  |-->Math_PINFINITY
Infinity  |-->Math_PINFINITY
nan  |-->Math_NaN
...  |-->...
print  |-->print
exec  |-->exec
int  |-->OclType["int"]
float  |-->OclType["double"]
str  |-->OclType["String"]
bool  |-->OclType["boolean"]
dict  |-->OclType["Map"]
list  |-->OclType["Sequence"]
set  |-->OclType["Set"]
R _1  |-->StringLib.rawString(_1)
r _1  |-->StringLib.rawString(_1)
f _1  |-->StringLib.formattedString(_1)
_1  |-->_1

attributeDecln::
,  |-->
_1  |-->  attribute _1 : OclAny;\n

attributeDefinitions::
_1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt
_1  |-->_1`attributeDefinitions<when> _1 stmt
_1  |-->_1`attributeDefinitions<when> _1 simple_stmt
_1  |-->_1`attributeDefinitions<when> _1 small_stmt
_1  |-->_1`attributeDefinitions<when> _1 compound_stmt
_1  |--><when> _1 funcdef
_1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.*
_1  |-->
_*  |-->

classDefinitions::
_1  |-->_1<when> _1 classdef
_1  |-->_1`classDefinitions<when> _1 compound_stmt
_1  |-->_1`classDefinitions<when> _1 funcdef
_1  |-->
async def _1 ( _2 ) -> _3 : _4  |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_4;\n\n}\n\n
async def _1 ( _2 ) : _3  |-->class Async$_1 {\n  stereotype active;\n\n_2`typedargslistAttributes\n  static operation newAsync$_1(_2) : Async$_1\n  pre: true\n  post: Async$_1->exists( resx | _2`typedargslistSettings result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n
async def _1 ( ) -> _2 : _3  |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_3;\n\n}\n\n
async def _1 ( ) : _2  |-->class Async$_1 {\n  stereotype active;\n\n  static operation newAsync$_1() : Async$_1\n  pre: true post: Async$_1->exists( resx | result = resx );\n\n  operation run()\n  pre: true post: true\n  activity:\n_2;\n\n}\n\n
if _1 : _2  |-->
if _1 : _2 _3  |-->
if _1 : _2 _*  |-->
while _1 : _2  |-->
for _1 in _2 : _3  |-->
_*  |-->

classcontent::
_1 _*  |-->_1`classcontent_*`classcontent<when> _1 stmt
_1  |-->_1`classcontent<when> _1 stmt
_1  |-->_1`classcontent<when> _1 simple_stmt
_1  |-->_1`classcontent<when> _1 small_stmt
_1  |-->_1`classcontent<when> _1 compound_stmt
_1  |-->_1`methodDefinition<when> _1 funcdef
_1 _2  |-->  static attribute _1 : _2`ocltype _2;\n<when> _2 assign_part<action> _1 _2`ocltype
_1  |-->
_*  |-->

classdef::
class _1 ( Enum ) : _3  |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class
class _1 ( _2 ) : _3  |-->class _1 extends _2 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_3`classcontent}\n\n<action> _1 Class
class _1 ( ) : _2  |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class
class _1 : _2  |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1

collectPart::
for _1 in _2  |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple
for _1 in _2 _3  |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in <when> _1 multiple
for _1 in _2  |-->
for _1 in _2 _3  |-->

collectionsType::
. deque _1  |-->Sequence
. OrderedDict _1  |-->Map
. _1  |-->OclAny
. _1 _*  |-->OclAny
_1  |-->OclAny

colonAssign::
: _1 = _2  |-->true
: _1  |-->true
_1 _2  |-->false
_*  |-->false

comp_for::
for _1 in _2  |-->
for _1 in _2 _3  |-->

comp_iter::
_1  |-->_1
if _1  |-->
if _1 _2  |-->

comparison::
_1 < _2  |-->_1 & (_1`last < _2)<when> _1 comparison, _1 multiple
_1 < _2  |-->MatrixLib.matrixLess(_1,_2)<when> _1 Sequence, _2 Sequence
_1 < _2  |-->MatrixLib.elementwiseLess(_1,_2)<when> _1 Sequence, _2 real
_1 < _2  |-->_1 < _2<when> _1 String
_1 < _2  |-->_1 < _2<when> _1 real
_1 < _2  |-->_1 < _2<when> _2 String
_1 < _2  |-->_1 < _2<when> _2 real
_1 < _2  |-->(_1->compareTo(_2)) < 0
_1 > _2  |-->_1 & (_1`last > _2)<when> _1 comparison, _1 multiple
_1 > _2  |-->_1 > _2<when> _1 String
_1 > _2  |-->_1 > _2<when> _1 real
_1 > _2  |-->_1 > _2<when> _2 String
_1 > _2  |-->_1 > _2<when> _2 real
_1 > _2  |-->(_1->compareTo(_2)) > 0
_1 >= _2  |-->_1 & (_1`last >= _2)<when> _1 comparison, _1 multiple
_1 >= _2  |-->_1 >= _2<when> _1 String
_1 >= _2  |-->_1 >= _2<when> _1 real
_1 >= _2  |-->_1 >= _2<when> _2 String
_1 >= _2  |-->_1 >= _2<when> _2 real
_1 >= _2  |-->(_1->compareTo(_2)) >= 0
_1 <= _2  |-->_1 & (_1`last <= _2)<when> _1 comparison, _1 multiple
_1 <= _2  |-->_1 <= _2<when> _1 String
_1 <= _2  |-->_1 <= _2<when> _1 real
_1 <= _2  |-->_1 <= _2<when> _2 String
_1 <= _2  |-->_1 <= _2<when> _2 real
_1 <= _2  |-->(_1->compareTo(_2)) <= 0
_1 == _2  |-->_1 & (_1`last == _2)<when> _1 comparison, _1 multiple
_1 == _2  |-->_1 = _2
_1 <> _2  |-->_1 & (_1`last <> _2)<when> _1 comparison, _1 multiple
_1 <> _2  |-->_1 /= _2
_1 != _2  |-->_1 & (_1`last != _2)<when> _1 comparison, _1 multiple
_1 != _2  |-->_1 /= _2
_1 in _2  |-->_1 & (_2->includes(_1`last))<when> _1 comparison, _1 multiple
_1 not in _2  |-->(_2)->characters()->excludes(_1)<when> _2 String
_1 in _2  |-->(_2)->characters()->includes(_1)<when> _2 String
_1 not in _2  |-->(_2)->excludes(_1)
_1 in _2  |-->(_2)->includes(_1)
_1 is not _2  |-->not(_1 <>= _2)
_1 is _2  |-->_1 <>= _2
_1  |-->_1

compound_stmt::
if _1 : _2  |-->    if _1 then (\n  _2\n    ) else skip
if _1 : _2 _3  |-->    if _1 then  (\n  _2\n    )\n_3<when> _3 else_clause
if _1 : _2 _3  |-->    if _1 then  (\n  _2\n    )\n_3 else skip)<when> _3 elif_clause
if _1 : _2 _*  |-->    if _1 then  (\n  _2\n    )\n_*    else skip_*`elifCloseBrackets<when> _* all elif_clause
if _1 : _2 _*  |-->    if _1 then  (\n  _2\n    )\n_*_*`elifCloseBrackets
while _1 : _2  |-->    while _1 do (_2)
for _1 in _2 : _3  |-->    for _1 : _2->characters() do (_3)<when> _2 String
for _1 in _2 : _3  |-->    for _1 : _2->keys() do (_3)<when> _2 Map
for _1 in _2 : _3  |-->    for _tuple : _2 do (var _indx : int := 1;\n_1`tupleDeclarations  _3)<when> _1 multiple
for _1 in _2 : _3  |-->    for _1 : _2 do (_3)
try : _1  |-->    try (_1)
try : _1 _*  |-->    try (_1)\n_*
with _1 : _2  |-->    try (_1_2)\n    catch (_e : OclException) do skip
with _1 , _2 : _3  |-->    try (_1    _2_3)\n    catch (_e : OclException) do skip
_1  |-->    skip

createTaskArglist::
_1  |-->_1`createTaskArgument

createTaskArgument::
_1  |-->_1`createTaskArgument<when> _1 test
_1  |-->_1`createTaskArgument<when> _1 logical_test
_1  |-->_1`createTaskArgument<when> _1 comparison
_1  |-->_1`createTaskArgument<when> _1 expr
_1 _2  |-->Async$_1.newAsync$_1_2

createTaskArguments::
( )  |-->
( _1 )  |-->_1`createTaskArglist
[ ]  |-->
[ _1 ]  |-->_1

datetimeTrailer::
. MINYEAR  |-->1
. MAXYEAR  |-->9999
. date  |-->OclDate
. datetime  |-->OclDate
. now _1  |-->OclDate.newOclDate()
. today _1  |-->OclDate.newOclDate()
. fromtimestamp _1  |-->OclDate.newOclDate_Time((_1`firstArg)->oclAsType(long))
. fromisoformat _1  |-->OclDate.newOclDate_String((_1`firstArg)->oclAsType(long))
. _1  |-->
. _1 _*  |-->
_1  |-->

declareIfNecessary::
_1  |--><when> _1`defined true
_1  |-->    var _1 : OclAny := null;\n
_1 , _*  |-->_*`recurse<when> _1`defined true
_1 , _*  |-->    var _1 : OclAny := null;\n_*`recurse

def_parameter::
_1 = _2  |-->_1`parameterName : String<when> _2 String, _1 1ary<action> _1`parameterName String, _1`defined true
_1 = _2  |-->_1`parameterName : int<when> _2 int, _1 1ary<action> _1`parameterName int, _1`defined true
_1 = _2  |-->_1`parameterName : double<when> _2 real, _1 1ary<action> _1`parameterName real, _1`defined true
_1 = _2  |-->_1<action> _1`defined true
_1  |-->_1<action> _1`defined true
*  |-->

def_parameters::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

defaultParamCode::
_1  |-->_1`paramDefaultCode
_1 , _*  |-->_1`paramDefaultCode_*`recurse

defaultParamSettings::
_1  |-->_1`defaultParamCode
_1 ,  |-->_1`defaultParamCode
_1 , _*  |-->_1`defaultParamCode_*`recurse

dictarguments::
( _1 )  |-->(_1`dictarguments)
{ }  |-->Map{}
{ _1 }  |-->_1
_1  |-->_1`dictarguments<when> _1 arguments
_1  |-->_1`dictarguments<when> _1 arglist
_1  |-->_1`dictarguments<when> _1 argument
_1  |-->_1`dictarguments<when> _1 test
_1  |-->_1`dictarguments<when> _1 logical_test
_1  |-->_1`dictarguments<when> _1 comparison
_1  |-->_1`dictarguments<when> _1 expr
_1  |-->_1`dictarguments<when> _1 atom

dictorsetmaker::
_1 : _2  |-->Map{ _1 |-> _2 }
_1 : _2 _3  |-->_3`domainPart->select(_3`variablePart | _3`selectPart)->collect(_3`variablePart | Map{_1 |-> _2})->unionAll()<when> _3 comp_for
** _1  |-->_1
_1 : _2 , _*  |-->Map{ _1 |-> _2 }->union(_*`recurse)
** _1 , _*  |-->_1->union(_*`recurse)
_1  |-->_1`setFormation

domainPart::
for _1 in _2  |-->_2->characters()<when> _2 String
for _1 in _2 _3  |-->_2->characters()<when> _2 String
for _1 in _2  |-->_2->keys()<when> _2 Map
for _1 in _2 _3  |-->_2->keys()<when> _2 Map
for _1 in _2  |-->_2
for _1 in _2 _3  |-->_2

dotted_as_name::
_1  |-->
_1 as _2  |-->

dotted_as_names::
_1  |-->
_*  |-->

dotted_name::
_1 . _2  |-->_1._2
_1  |-->_1

elifCloseBrackets::
elif _1 : _2  |-->    )\n
else : _1  |-->
_1  |-->

elif_clause::
elif _1 : _2  |-->    else (if _1 then\n   (\n  _2    \n)\n

else_clause::
else : _1  |-->    else (\n  _1\n      )

equalAssign::
= _1 = _2  |-->true
= _1  |-->true
_1 _2  |-->false
_*  |-->false

errorToUML::
_1  |-->_1`errorToUML<when> _1 testlist
_1  |-->_1`errorToUML<when> _1 test
_1  |-->_1`errorToUML<when> _1 logical_test
_1  |-->_1`errorToUML<when> _1 comparison
_1  |-->_1`errorToUML<when> _1 expr
_1  |-->_1`errorToUML<when> _1 atom
_1 _2  |-->_1`errorToUML_2<when> _1 atom, _2 trailer
( )  |-->()
( _1 )  |-->Sequence{_1}<when> _1 multiple
( _1 )  |-->(_1`errorToUML)
[ ]  |-->Sequence{}
[ _1 ]  |-->_1`sequenceFormation
{ _1 }  |-->_1
` _1 `  |-->"_1"
- _1  |-->-_1
None  |-->null
...  |-->...
print  |-->print
exec  |-->exec
int  |-->int
float  |-->double
str  |-->String
_1 , _*  |-->_1.new_1<when> _1 name
_1  |-->_1.new_1<when> _1 name
_1 , _*  |-->
_1  |-->

errorlist::
_1  |-->    error _1`errorToUML
_1 _*  |-->    error _1`errorToUML;\n_*`recurse

eval_input::
_1  |-->_1
_1 _*  |-->_1

except_clause::
except : _1  |-->     catch (_e : OclException) do (_1)\n
except _1 as _2 : _3  |-->    catch (_2 : _1) do (_3)\n
except _1 , _2 : _3  |-->    catch (_2 : _1) do (_3)\n

expr::
abs _1  |-->_1->abs()
all _1  |-->_1->forAll( _x | _x = true )
any _1  |-->_1->exists( _x | _x = true )
ascii _1  |-->(_1 + "")
await asyncio _1  |-->_1`asyncioTrailer<when> _1 trailer
await _1  |-->_1.join()
bool _1  |-->_1->toBoolean()
dict _1  |-->_1`dictarguments
set _1  |-->Set{}->union(_1)
set _1 _2  |-->Set{}->union(_1)_2
divmod _1  |-->Sequence{(_1`firstArg div _1`secondArg), (_1`firstArg mod _1`secondArg)}
filter _1  |-->(_1`secondArg)->select( _x | (_1`firstArg)->apply(_x) = true )
format _1  |-->(_1`firstArg + "")
frozenset _1  |-->Set{}
map _1  |-->(_1`secondArg)->collect( _x | (_1`firstArg)->apply(_x) )
hex _1  |-->MathLib.decimal2hex_1
oct _1  |-->MathLib.decimal2octal_1
id _1  |-->?_1
input _1  |-->(OclFile["System.in"]).readLine_1
isinstance _1  |-->(_1`secondArg).isInstance(_1`firstArg)
issubclass _1  |-->(_1`firstArg).isAssignableFrom(_1`secondArg)
iter _1  |-->OclIterator.newOclIterator_Sequence_1
len _1  |-->_1->size()
list _1  |-->_1->characters()<when> _1`ocltype String
list _1  |-->_1->keys()->asSequence()<when> _1`ocltype Map
list _1  |-->_1
deque _1  |-->_1
OrderedDict _1  |-->_1
max _1  |-->_1->max()<when> _1`argCount 1
max _1  |-->Set{_1`argList}->max()
min _1  |-->_1->min()<when> _1`argCount 1
min _1  |-->Set{_1`argList}->min()
next _1  |-->_1.next()
round _1  |-->_1->round()<when> _1`numberOfArguments 1
round _1  |-->MathLib.roundN(_1`firstArg, _1`secondArg)
slice _1  |-->Integer.subrange(1,_1`firstArg)<when> _1`numberOfArguments 1
slice _1  |-->Integer.subrange(_1`firstArg+1,_1`secondArg)
sum _1  |-->_1->sum()
type _1  |-->_1->oclType()<when> _1`numberOfArguments 1
type _1  |-->OclType.newOclType(_1`firstArg)
print _1  |-->_1`printTrailer->display()
int _1  |-->("" + (_1))->toInteger()
float _1  |-->("" + (_1))->toReal()
str _1  |-->("" + (_1))
chr _1  |-->_1->byte2char()
unichr _1  |-->_1->byte2char()
ord _1  |-->_1->char2byte()
pow _1  |-->(_1`firstArg)->pow(_1`secondArg)
repr _1  |-->("" + (_1))
reversed _1  |-->_1->reverse()
sorted _1  |-->_1`sortedTrailer
tuple _1  |-->_1
range _1  |-->_1`rangeTrailer
enumerate _1  |-->Integer.subrange(1, _1->size())->collect( _indx | Sequence{_indx-1, _1->at(_indx)} )
zip _1  |-->Integer.subrange(1, _1`firstArg->size())->collect( _indx | Sequence{_1`firstArg->at(_indx), _1`secondArg->at(_indx)} )
open _1  |-->OclFile.newOclFile_Write(OclFile.newOclFile(_1`firstArg))<when> _1`lastArg matches .*[wWaA].*
open _1  |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1`firstArg))
setattr _1  |-->OclType.setAttributeValue_1
getattr _1  |-->OclType.getAttributeValue_1
hasattr _1  |-->OclType.hasAttribute_1
delattr _1  |-->OclType.removeAttribute_1
eval _1  |-->_0`pythonEval
collections _1  |-->_1
math _1  |-->_1`mathTrailer
re _1  |-->_1`reTrailer
random _1  |-->_1`randomTrailer
pickle _1  |-->_1`pickleTrailer
datetime _1  |-->_1`datetimeTrailer
asyncio _1  |-->_1`asyncioTrailer
sqlite3 _1  |-->_1`sqliteTrailer
np _1  |-->_1`numpyTrailer
np _1 _2  |-->_2`npRandomTrailer<when> _1 matches .random
numpy _1  |-->_1`numpyTrailer
numpy _1 _2  |-->_2`npRandomTrailer<when> _1 matches .random
pd _1  |-->_1`pandasTrailer
sys _1  |-->_1`sysTrailer
sys _1 _2  |-->(_1`sysTrailer)_2
_1 ** _2  |-->(_1)->pow(_2)
+ _1  |-->_1
- _1  |-->-_1
~ _1  |-->MathLib.bitwiseNot(_1)
_1 * _2  |-->StringLib.nCopies(_1, _2)<when> _1 String
_1 * _2  |-->MatrixLib.dotProduct(_1,_2)<when> _1`ocltype Sequence, _2`ocltype Sequence
_1 * _2  |-->MatrixLib.elementwiseMult(_1, _2)<when> _1`ocltype Sequence
_1 * _2  |-->MatrixLib.elementwiseMult(_2, _1)<when> _2`ocltype Sequence
_1 * _2  |-->_1 * _2
_1 / _2  |-->_1 / _2
_1 % _2  |-->StringLib.format(_1,_2)<when> _1 String
_1 % _2  |-->_1 mod _2
_1 // _2  |-->_1 div _2
_1 @ _2  |-->MatrixLib.matrixMultiplication(_1,_2)
_1 + _2  |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype int
_1 + _2  |-->MatrixLib.elementwiseAdd(_1, _2)<when> _1`ocltype Sequence, _2`ocltype double
_1 + _2  |-->_1->union(_2)<when> _1`ocltype Sequence
_1 + _2  |-->_1->union(_2)<when> _2`ocltype Sequence
_1 + _2  |-->_1 + _2
_1 - _2  |-->_1 - _2
_1 << _2  |-->_1 * (2->pow(_2))
_1 >> _2  |-->_1 /(2->pow(_2))
_1 & _2  |-->MathLib.bitwiseAnd(_1, _2)
_1 ^ _2  |-->MathLib.bitwiseXor(_1, _2)
_1 | _2  |-->_1->union(_2)<when> _1 Map
_1 | _2  |-->MathLib.bitwiseOr(_1, _2)
_1 _2 _3  |-->_1_2<when> _2`isBasicTypeTrailer true, _3 matches .value
_1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape
_1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim
_1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size
_1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype
_1 _2  |-->_1<when> _1 atom, _2 matches .head\(\)
_1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer
_1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer
_1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\)
_1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\)
_1 _2 _3  |-->MathLib.median(_1_2)<when> _1 atom, _3 matches .median\(\)
_1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\)
_1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join
_1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\)
_1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\)
_1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\)
_1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\)
_1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\)
_1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust
_1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust
_1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format
_1 _*  |-->_1->apply_*<when> _1 Function
_1 _2  |-->_1_2`mapQueryForm<when> _1 Map
_1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence
_1 _*  |-->_1_*<when> _1 atom
_1  |-->_1

exprlist::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

file_input::
_1  |-->_1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1;\n\n_1`functionDefinitions\n}\n
_1 _*  |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n

finally_clause::
finally : _1  |-->    finally (_1)

findQualifier::
( _1 )  |-->_1`findQualifier<when> _1 arglist
_1 , _2  |-->.substring(_2)
_1 , _2 , _3  |-->.substring(_2,_3)
_1  |-->

firstArg::
( )  |-->
( _1 )  |-->_1`first
[ ]  |-->
[ _1 ]  |-->_1`first
_1  |-->_1`firstArg

followingStatement::
_1  |--> ;\n_1

formatArguments::
. format _1  |-->_1`formatArguments
( _1 )  |-->Sequence{_1}

funcdef::
async def _1 ( _2 ) -> _3 : _4  |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n
def _1 ( _2 ) -> _3 : _4  |-->  operation _1(_2) : _3`ocltype\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_4;\n\n
async def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true
async def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n
def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true
def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n
async def _1 ( ) -> _2 : _3  |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
def _1 ( ) -> _2 : _3  |-->  operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
async def _1 ( ) : _2  |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
async def _1 ( ) : _2  |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n
def _1 ( ) : _2  |-->  operation _1(_position_ : int) : OclAny\n  pre: true post: true\n  activity:\n    var _yieldCount_ : int := 0;\n_2;\n\n<when> _2`hasYieldStatement true<action> _1 generator
def _1 ( ) : _2  |-->  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
def _1 ( ) : _2  |-->  operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n

functionDefinitions::
_1  |-->_1<when> _1 funcdef
_1  |-->_1`functionDefinitions<when> _1 compound_stmt
_1  |-->
if _1 : _2  |-->
if _1 : _2 _3  |-->
if _1 : _2 _*  |-->
while _1 : _2  |-->
for _1 in _2 : _3  |-->
_*  |-->

hasSideEffect::
_1  |-->_1`hasSideEffect<when> _1 testlist
_1  |-->_1`hasSideEffect<when> _1 test
_1  |-->_1`hasSideEffect<when> _1 logical_test
_1  |-->_1`hasSideEffect<when> _1 comparison
_1  |-->_1`hasSideEffect<when> _1 expr
print _1  |-->_1`hasSideEffect
del _1  |-->_1`hasSideEffect
_1 _2  |-->_2`trailerSideEffect<when> _1 atom, _2 trailer
_1 , _*  |-->_1`hasSideEffect
_1  |-->

hasTrailer::
_1 _2  |-->true<when> _2 trailer
_1  |-->_1`hasTrailer<when> _1 comparison
_1  |-->_1`hasTrailer<when> _1 logical_test
_1  |-->_1`hasTrailer<when> _1 test
_1  |-->_1`hasTrailer<when> _1 testlist
_1  |-->_1`hasTrailer<when> _1 testlist_star_expr
_1  |-->_1`hasTrailer<when> _1 expr
_1  |-->false

hasValueReturn::
print _1  |-->false
del _1  |-->false
pass  |-->false
break  |-->false
continue  |-->false
return _1  |-->true
return  |-->false
raise _1  |-->false
raise _1 from _2  |-->false
raise _*  |-->false
import _1  |-->false
from _*  |-->false
global _*  |-->false
exec _1  |-->false
exec _*  |-->false
assert _1  |-->false
assert _1 , _2  |-->false
nonlocal _*  |-->false
if _1 : _2  |-->_2`hasValueReturn
if _1 : _2 _3  |-->true<when> _2`hasValueReturn true, _3 else_clause
if _1 : _2 _3  |-->true<when> _3`hasValueReturn true, _3 else_clause
if _1 : _2 _3  |-->false<when> _3 else_clause
if _1 : _2 _*  |-->true<when> _2`hasValueReturn true
if _1 : _2 _*  |-->_*`recurse
while _1 : _2  |-->_2`hasValueReturn
for _1 in _2 : _3  |-->_3`hasValueReturn
try : _1  |-->_1`hasValueReturn
try : _1 _*  |-->true<when> _1`hasValueReturn true
try : _1 _*  |-->_*`recurse
with _1 : _2  |-->_2`hasValueReturn
elif _1 : _2  |-->_2`hasValueReturn
else : _1  |-->_1`hasValueReturn
except : _1  |-->_1`hasValueReturn
except _1 as _2 : _3  |-->_3`hasValueReturn
except _1 , _2 : _3  |-->_3`hasValueReturn
finally : _1  |-->_1`hasValueReturn
_1 _2  |-->false<when> _2 assign_part
_1  |-->false<when> _1 testlist_star_expr
_1  |-->_1`hasValueReturn<when> _1 stmt
_1  |-->_1`hasValueReturn<when> _1 small_stmt
_1  |-->_1`hasValueReturn<when> _1 simple_stmt
_1  |-->_1`hasValueReturn<when> _1 compound_stmt
_1  |-->_1`hasValueReturn<when> _1 elif_clause
_1  |-->_1`hasValueReturn<when> _1 else_clause
_1  |-->_1`hasValueReturn<when> _1 finally_clause
_1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true
_1 _*  |-->_*`recurse<when> _1 stmt
_1 ; _*  |-->true<when> _1 small_stmt, _1`hasValueReturn true
_1 ; _*  |-->_*`recurse<when> _1 small_stmt
_1  |-->false
_*  |-->false

hasYieldStatement::
print _1  |-->false
del _1  |-->false
pass  |-->false
break  |-->false
continue  |-->false
return _1  |-->false
return  |-->false
raise _1  |-->false
raise _1 from _2  |-->false
raise _*  |-->false
import _1  |-->false
from _*  |-->false
global _*  |-->false
exec _1  |-->false
exec _*  |-->false
assert _1  |-->false
assert _1 , _2  |-->false
nonlocal _*  |-->false
if _1 : _2  |-->_2`hasYieldStatement
if _1 : _2 _3  |-->true<when> _2`hasYieldStatement true, _3 else_clause
if _1 : _2 _3  |-->true<when> _3`hasYieldStatement true, _3 else_clause
if _1 : _2 _3  |-->false<when> _3 else_clause
if _1 : _2 _*  |-->true<when> _2`hasYieldStatement true
if _1 : _2 _*  |-->_*`recurse
while _1 : _2  |-->_2`hasYieldStatement
for _1 in _2 : _3  |-->_3`hasYieldStatement
try : _1  |-->_1`hasYieldStatement
try : _1 _*  |-->true<when> _1`hasYieldStatement true
try : _1 _*  |-->_*`recurse
with _1 : _2  |-->_2`hasYieldStatement
elif _1 : _2  |-->_2`hasYieldStatement
else : _1  |-->_1`hasYieldStatement
except : _1  |-->_1`hasYieldStatement
except _1 as _2 : _3  |-->_3`hasYieldStatement
except _1 , _2 : _3  |-->_3`hasYieldStatement
finally : _1  |-->_1`hasYieldStatement
_1  |-->true<when> _1 yield_expr
_1 _2  |-->false<when> _2 assign_part
_1  |-->false<when> _1 testlist_star_expr
_1  |-->_1`hasYieldStatement<when> _1 stmt
_1  |-->_1`hasYieldStatement<when> _1 small_stmt
_1  |-->_1`hasYieldStatement<when> _1 simple_stmt
_1  |-->_1`hasYieldStatement<when> _1 compound_stmt
_1  |-->_1`hasYieldStatement<when> _1 elif_clause
_1  |-->_1`hasYieldStatement<when> _1 else_clause
_1  |-->_1`hasYieldStatement<when> _1 finally_clause
_1 _*  |-->true<when> _1 stmt, _1`hasYieldStatement true
_1 _*  |-->_*`recurse<when> _1 stmt
_1 ; _*  |-->true<when> _1 small_stmt, _1`hasYieldStatement true
_1 ; _*  |-->_*`recurse<when> _1 small_stmt
_1  |-->false
_*  |-->false

import_as_names::
_1  |-->
_*  |-->

integer::
_1  |-->_1

isBasicTypeTrailer::
. _1  |-->true<when> _1 int
. _1  |-->true<when> _1 real
. _1  |-->true<when> _1 String
. _1  |-->true<when> _1 boolean
. _1  |-->false

isMapAtomExpression::
_1 : _2  |-->true
_1 : _2 _3  |-->true<when> _3 comp_for
** _1  |-->true
_1 : _2 , _*  |-->true
** _1 , _*  |-->true
_1  |-->false

isMapExpression::
_1  |-->_1`isMapExpression<when> _1 testlist
_1  |-->_1`isMapExpression<when> _1 test
_1  |-->_1`isMapExpression<when> _1 logical_test
_1  |-->_1`isMapExpression<when> _1 comparison
_1  |-->_1`isMapExpression<when> _1 expr
_1  |-->_1`isMapExpression<when> _1 atom
print _1  |-->false
del _1  |-->false
dict _1  |-->true
( )  |-->false
( _1 )  |-->false<when> _1 multiple
( _1 )  |-->_1`isMapExpression
[ ]  |-->false
[ _1 ]  |-->false
{ _1 }  |-->_1`isMapAtomExpression
` _1 `  |-->false
- _1  |-->false
None  |-->false
...  |-->false
_1 _2  |-->false<when> _1 atom, _2 trailer
_1 , _*  |-->false
_1  |-->false

isMultipleAssignPart::
= _1  |-->true<when> _1 multiple
= _1  |-->false
_*  |-->false

isSequenceExpression::
_1  |-->_1`isSequenceExpression<when> _1 testlist
_1  |-->_1`isSequenceExpression<when> _1 test
_1  |-->_1`isSequenceExpression<when> _1 logical_test
_1  |-->_1`isSequenceExpression<when> _1 comparison
_1  |-->_1`isSequenceExpression<when> _1 expr
_1  |-->_1`isSequenceExpression<when> _1 atom
print _1  |-->false
del _1  |-->false
dict _1  |-->false
range _1  |-->true
( )  |-->false
( _1 )  |-->false<when> _1 multiple
( _1 )  |-->_1`isSequenceExpression
[ ]  |-->true
[ _1 ]  |-->true
{ _1 }  |-->false
` _1 `  |-->false
- _1  |-->false
None  |-->false
...  |-->false
_1 + _2  |-->_1`isSequenceExpression
_1 _2  |-->false<when> _1 atom, _2 trailer
_1 , _*  |-->false
_1  |-->true<when> _1 Sequence
_1  |-->false

isUpdating::
. append _1  |-->true
. extend _1  |-->true
. insert _1  |-->true
. remove _1  |-->true
. sort _1  |-->true
. reverse _1  |-->true
. pop _1  |-->true
. popleft _1  |-->true
. add _1  |-->true
. intersection_update _1  |-->true
. difference_update _1  |-->true
. symmetric_difference _1  |-->true
. update _1  |-->true
. discard _1  |-->true
. clear _1  |-->true
. appendleft _1  |-->true
. extendleft _1  |-->true
. _1  |-->false
. _1 _*  |-->false
_1  |-->false

justificationArguments::
. ljust _1  |-->_1`justificationArguments
. rjust _1  |-->_1`justificationArguments
( _1 )  |--> _1`third, _1`first

kwargs::
** _1  |-->_1 : Map(String, OclAny)<action> _1 Map

lastArg::
( )  |-->
( _1 )  |-->_1`lastArg
[ ]  |-->
_1 , _2  |-->_2`argValue
_1 , _*  |-->_*`recurse
_1  |-->_1`argValue

literalSubscript::
...  |-->
0  |-->1
-1  |-->-1
-2  |-->-2
_1  |-->_1<when> _1 matches -.*
_1 : _2  |-->Integer.subrange(_1+1, _2)<when> _2 test
: -1  |-->
: -2  |-->
: _1  |-->Integer.subrange(1,_1)<when> _1 test
1 :  |-->
_1 :  |--><when> _1 test
_1  |-->_1`literalSubscript<when> _1 subscriptlist
_1  |-->_1`literalSubscript<when> _1 subscript
_1  |-->_1<when> _1 String
_1  |-->_1<when> _1`ocltype boolean
_1  |-->_1<when> _1`ocltype Sequence
_1  |-->_1+1

logical_test::
not _1  |-->not(_1 = 0)<when> _1 real
not _1  |-->not(_1 = "")<when> _1 String
not _1  |-->not(_1)
_1 and _2  |-->if _1 = 0 then _1 else _2 endif<when> _1 real
_1 and _2  |-->if _1 = "" then _1 else _2 endif<when> _1 String
_1 and _2  |-->_1 & _2
_1 or _2  |-->if _1 /= 0 then _1 else _2 endif<when> _1 real
_1 or _2  |-->if _1 /= "" then _1 else _2 endif<when> _1 String
_1 or _2  |-->_1 or _2
_1  |-->_1

mapArgumentsQueryForm::
( )  |-->()
( _1 )  |-->(_1)
[ ]  |-->()
[ _1 ]  |-->->selectRows(_1`literalSubscript)<when> _1`ocltype boolean
[ _1 ]  |-->->restrict(_1`literalSubscript)<when> _1`ocltype Sequence
[ _1 ]  |-->->at(_1`literalSubscript)

mapArgumentsType::
( )  |-->OclAny
( _1 )  |-->_1`ocltype
[ ]  |-->OclAny
[ _1 ]  |-->Map<when> _1`ocltype boolean
[ _1 ]  |-->Map<when> _1`ocltype Sequence
[ _1 ]  |-->OclAny

mapQueryForm::
. count _1  |-->->count_1
. index _1  |-->->indexOf_1 - 1
. sort _1  |-->->sort()
. reverse _1  |-->->reverse()
. pop _1  |-->_1`popArguments
. popleft _1  |-->_1`popleftArguments
. add _1  |-->->including_1
. copy _1  |-->->copy()
. intersection _1  |-->->intersection_1
. intersection_update _1  |-->->intersection_1
. difference _1  |--> - _1
. difference_update _1  |--> - _1
. isdisjoint _1  |-->->intersection_1->isEmpty()
. issubset _1  |--> <: _1
. issuperset _1  |-->->includesAll_1
. symmetric_difference _1  |-->->symmetricDifference_1
. update _1  |-->_1`allUnion
. remove _1  |-->->excludingFirst_1
. discard _1  |-->->excluding_1
. clear _1  |-->->intersection(Set{})
. items _1  |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
. max _1  |-->->max()
. min _1  |-->->min()
. head _1  |-->->collect( _ser | _ser.subrange(1,_1))
. tail _1  |-->->collect( _ser | _ser.subrange(_1, _ser->size()))
. at _1  |-->_1`reversedAccess
. maxlen  |-->->size()
. _1  |-->._1
. _1 _*  |-->._1_*
_1  |-->_1`mapArgumentsQueryForm<when> _1 arguments
_1  |-->_1

mapTrailerType::
. count _1  |-->int
. index _1  |-->int
. sort _1  |-->Map
. reverse _1  |-->Map
. add _1  |-->Map
. copy _1  |-->Map
. intersection _1  |-->Map
. intersection_update _1  |-->Map
. difference _1  |-->Map
. difference_update _1  |-->Map
. isdisjoint _1  |-->boolean
. issubset _1  |-->boolean
. issuperset _1  |-->boolean
. symmetric_difference _1  |-->Map
. update _1  |-->Map
. remove _1  |-->Map
. discard _1  |-->Map
. clear _1  |-->Map
. items _1  |-->Sequence
. max _1  |-->OclAny
. min _1  |-->OclAny
. head _1  |-->Map
. tail _1  |-->
. at _1  |-->OclAny
. maxlen  |-->int
. _1  |-->OclAny
. _1 _*  |-->OclAny
_1  |-->_1`mapArgumentsType<when> _1 arguments
_1  |-->_1`ocltype

mathTrailer::
. cosin _1  |-->_1->cos()
. sin _1  |-->_1->sin()
. tan _1  |-->_1->tan()
. ceil _1  |-->_1->ceil()
. floor _1  |-->_1->floor()
. trunc _1  |-->_1->oclAsType(int)
. sqrt _1  |-->_1->sqrt()
. cbrt _1  |-->_1->cbrt()
. exp _1  |-->_1->exp()
. log _1  |-->_1->log()
. log10 _1  |-->_1->log10()
. acos _1  |-->_1->acos()
. asin _1  |-->_1->asin()
. atan _1  |-->_1->atan()
. acosh _1  |-->MathLib.acosh_1
. asinh _1  |-->MathLib.asinh_1
. atanh _1  |-->MathLib.atanh_1
. cosh _1  |-->_1->cosh()
. sinh _1  |-->_1->sinh()
. tanh _1  |-->_1->tanh()
. pow _1  |-->(_1`firstArg)->pow(_1`lastArg)
. comb _1  |-->MathLib.combinatorial(_1`firstArg, _1`lastArg)
. fabs _1  |-->_1->abs()
. factorial _1  |-->MathLib.factorial_1
. fsum _1  |-->_1->sum()
. prod _1  |-->_1->prd()
. gcd _1  |-->(_1`firstArg)->gcd(_1`lastArg)
. lcm _1  |-->MathLib.lcm(_1`firstArg, _1`lastArg)
. _1  |-->
. _1 _*  |-->
_1  |-->

mathType::
. cosin _1  |-->double
. sin _1  |-->double
. tan _1  |-->double
. ceil _1  |-->double
. floor _1  |-->double
. trunc _1  |-->int
. sqrt _1  |-->double
. cbrt _1  |-->double
. exp _1  |-->double
. log _1  |-->double
. log10 _1  |-->double
. acos _1  |-->double
. asin _1  |-->double
. atan _1  |-->double
. acosh _1  |-->double
. asinh _1  |-->double
. atanh _1  |-->double
. cosh _1  |-->double
. sinh _1  |-->double
. tanh _1  |-->double
. pow _1  |-->double
. comb _1  |-->long
. fabs _1  |-->double
. factorial _1  |-->long
. fsum _1  |-->double
. prod _1  |-->double
. gcd _1  |-->long
. lcm _1  |-->int
. _1  |-->OclAny
. _1 _*  |-->OclAny
_1  |-->OclAny

methodDefinition::
def __init__ ( _1 ) : _2  |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n
def _1 ( _2 ) -> _3 : _4  |-->\n  operation _1(_2`parametersTail) : _3`ocltype\n  pre: true post: true\n  activity:\n_4;\n\n
def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true
def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n
def _1 ( ) -> _2 : _3  |-->\n  static operation _1() : _2`ocltype\n  pre: true post: true\n  activity:\n_3;\n\n
def _1 ( ) : _2  |-->\n  static operation _1() : OclAny\n  pre: true post: true\n  activity:\n_2;\n\n<when> _2`hasValueReturn true
def _1 ( ) : _2  |-->\n  static operation _1()\n  pre: true post: true\n  activity:\n_2;\n\n

name::
_  |-->_anon
True  |-->true
False  |-->false
None  |-->null
inf  |-->Math_PINFINITY
Infinity  |-->Math_PINFINITY
nan  |-->Math_NaN
ValueError  |-->IncorrectElementException
BaseException  |-->OclException
Exception  |-->ProgramException
OSError  |-->SystemException
IOError  |-->IOException
TypeError  |-->CastingException
AttributeError  |-->NullAccessException
LookupError  |-->IndexingException
ArithmeticError  |-->ArithmeticException
AssertionError  |-->AssertionException
Random  |-->OclRandom
int  |-->OclType["int"]
float  |-->OclType["double"]
str  |-->OclType["String"]
bool  |-->OclType["boolean"]
_1  |-->_1

named_parameter::
_1  |-->_1 : OclAny
_1 : int  |-->_1 : int<action> _1 int
_1 : bool  |-->_1 : boolean<action> _1 boolean
_1 : float  |-->_1 : double<action> _1 real
_1 : dict  |-->_1 : Map(String,OclAny)<action> _1 Map
_1 : str  |-->_1 : String<action> _1 String
_1 : list  |-->_1 : Sequence(OclAny)<action> _1 Sequence
_1 : set  |-->_1 : Set(OclAny)<action> _1 Set
_1 : _2  |-->_1 : _2<action> _1 _2

nestedAttributeDefinitions::
_1 _*  |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt
_1  |-->_1`nestedAttributeDefinitions<when> _1 stmt
_1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt
_1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt
_1  |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt
_1  |-->_1`nestedAttributeDefinitions<when> _1 funcdef
async def _1 ( _2 ) -> _3 : _4  |-->_4`nestedAttributeDefinitions
def _1 ( _2 ) -> _3 : _4  |-->_4`nestedAttributeDefinitions
async def _1 ( _2 ) : _3  |-->_3`nestedAttributeDefinitions
def _1 ( _2 ) : _3  |-->_3`nestedAttributeDefinitions
async def _1 ( ) -> _2 : _3  |-->_3`nestedAttributeDefinitions
def _1 ( ) -> _2 : _3  |-->_3`nestedAttributeDefinitions
async def _1 ( ) : _2  |-->_2`nestedAttributeDefinitions
def _1 ( ) : _2  |-->_2`nestedAttributeDefinitions
if _1 : _2  |-->_2`nestedAttributeDefinitions
if _1 : _2 _3  |-->_2`nestedAttributeDefinitions_3`nestedAttributeDefinitions
if _1 : _2 _*  |-->_2`nestedAttributeDefinitions_*`nestedAttributeDefinitions
while _1 : _2  |-->_2`nestedAttributeDefinitions
for _1 in _2 : _3  |-->_3`nestedAttributeDefinitions
try : _1  |-->_1`nestedAttributeDefinitions
try : _1 _*  |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions
elif _1 : _2  |-->_2`nestedAttributeDefinitions
else : _1  |-->_1`nestedAttributeDefinitions
except : _1  |-->_1`nestedAttributeDefinitions
except _1 as _2 : _3  |-->_3`nestedAttributeDefinitions
except _1 , _2 : _3  |-->_3`nestedAttributeDefinitions
finally : _1  |-->_1`nestedAttributeDefinitions
with _1 : _2  |-->_2`nestedAttributeDefinitions
global _*  |-->_*`attributeDecln
nonlocal _*  |-->_*`attributeDecln
_1  |-->
_*  |-->

npRandomTrailer::
. default_rng _1  |-->OclRandom.newOclRandom_PCG_1
. rand _1  |-->OclRandom.randomValuesMatrix_1
. randint _1  |-->(_1`firstArg + (OclRandom.newOclRandom_PCG()).nextInt(_1`lastArg - _1`firstArg))
. random _1  |-->OclRandom.newOclRandom_PCG().nextDouble()<when> _1 matches \(\)
. random _1  |-->OclRandom.randomValuesMatrix_1

npRandomType::
. default_rng _1  |-->OclRandom
. rand _1  |-->Sequence
. randint _1  |-->int
. random _1  |-->double<when> _1 matches \(\)
. random _1  |-->Sequence

number::
_1  |-->("_1")->toReal()<when> _1 matches .*E.*
_1  |-->("_1")->toReal()<when> _1 matches .*e.*
_1  |-->_1

numberOfArguments::
. _1  |-->0
. _1 _*  |-->0
_1  |-->_1`numberOfArguments<when> _1 testlist
_1  |-->_1`numberOfArguments<when> _1 test
_1  |-->_1`numberOfArguments<when> _1 logical_test
_1  |-->_1`numberOfArguments<when> _1 comparison
_1  |-->_1`numberOfArguments<when> _1 expr
_1  |-->_1`numberOfArguments<when> _1 trailer
_1  |-->_1`numberOfArguments<when> _1 arguments
_1  |-->0<when> _1 atom
print _1  |-->0
del _1  |-->0
dict _1  |-->0
( )  |-->0
( _1 )  |-->_1`arity<when> _1 multiple
( _1 )  |-->1
[ ]  |-->0
[ _1 ]  |-->0
{ _1 }  |-->0
` _1 `  |-->0
- _1  |-->0
None  |-->0
...  |-->0
_1  |-->0
_*  |-->0

numberType::
_1  |-->int<when> _1 int
_1  |-->double

numpyTrailer::
. inf  |-->Math_PINFINITY
. Inf  |-->Math_PINFINITY
. Infinity  |-->Math_PINFINITY
. infty  |-->Math_PINFINITY
. PINF  |-->Math_PINFINITY
. NINF  |-->Math_NINFINITY
. nan  |-->Math_NaN
. NaN  |-->Math_NaN
. NAN  |-->Math_NaN
. NZERO  |-->-0.0
. PZERO  |-->0.0
. newaxis  |-->null
. pi  |-->MathLib.piValue()
. e  |-->MathLib.eValue()
. euler_gamma  |-->MathLib.gammaValue()
. int32  |-->OclType["int"]
. int64  |-->OclType["long"]
. float32  |-->OclType["double"]
. float64  |-->OclType["double"]
. arange _1  |-->MathLib.numericRange(0, _1, 1)<when> _1`argCount 1
. arange _1  |-->MathLib.numericRange(_1`firstArg, _1`secondArg, 1)<when> _1`argCount 3
. arange _1  |-->MathLib.numericRange(_1`firstArg, _1`secondArg, _1`thirdArg)<when> _1`argCount 5
. linspace _1  |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, 50)<when> _1`argCount 3
. linspace _1  |-->MathLib.numericSeries(_1`firstArg, _1`secondArg, _1`thirdArg->oclAsType(int))<when> _1`argCount 5
. matmul _1  |-->MatrixLib.matrixMultiplication(_1`firstArg,_1`secondArg)
. prod _1  |-->MatrixLib.prdMatrix(_1`firstArg)
. sum _1  |-->MatrixLib.sumMatrix(_1`firstArg)
. sort _1  |-->_1->sort()
. shape _1  |-->MatrixLib.shape_1
. array _1  |-->_1
. concatenate _1  |-->_1->concatenateAll()
. copyto _1  |-->_1`firstArg := (_1`secondArg)->copy()
. empty _1  |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0)
. empty_like _1  |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0)
. eye _1  |-->MatrixLib.identityMatrix(_1`firstArg)
. identity _1  |-->MatrixLib.identityMatrix(_1`firstArg)
. ones _1  |-->MatrixLib.singleValueMatrix(_1`firstArg, 1.0)
. ones_like _1  |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 1.0)
. zeros _1  |-->MatrixLib.singleValueMatrix(_1`firstArg, 0.0)
. zeros_like _1  |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), 0.0)
. full _1  |-->MatrixLib.singleValueMatrix(_1`firstArg, _1`secondArg)
. full_like _1  |-->MatrixLib.singleValueMatrix(MatrixLib.shape(_1`firstArg), _1`secondArg)
. ravel _1  |-->MatrixLib.flattenMatrix(_1`firstArg)
. reshape _1  |-->MatrixLib.fillMatrixFrom(_1`firstArg, _1`secondArg)
. sin _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sin()))
. cos _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cos()))
. tan _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tan()))
. arcsin _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->asin()))
. arccos _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->acos()))
. arctan _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->atan()))
. sqrt _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sqrt()))
. round _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round()))
. floor _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->floor()))
. ceil _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->ceil()))
. sinh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->sinh()))
. cosh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->cosh()))
. tanh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->tanh()))
. arcsinh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.asinh(x)))
. arccosh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.acosh(x)))
. arctanh _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (MathLib.atanh(x)))
. rint _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->round()))
. trunc _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->oclAsType(int)))
. exp _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->exp()))
. log _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log()))
. log10 _1  |-->MatrixLib.elementwiseApply(_1`firstArg, lambda x : double in (x->log10()))
. transpose _1  |-->MatrixLib.transpose(_1`firstArg)
. add _1  |-->MatrixLib.matrixAddition(_1`firstArg, _1`secondArg)
. multiply _1  |-->MatrixLib.dotProduct(_1`firstArg, _1`secondArg)
. subtract _1  |-->MatrixLib.matrixSubtraction(_1`firstArg, _1`secondArg)
. divide _1  |-->MatrixLib.dotDivide(_1`firstArg, _1`secondArg)
. _1  |-->
. _1 _*  |-->
_1  |-->

numpyType::
. inf  |-->double
. Inf  |-->double
. Infinity  |-->double
. infty  |-->double
. PINF  |-->double
. NINF  |-->double
. nan  |-->double
. NaN  |-->double
. NAN  |-->double
. NZERO  |-->double
. PZERO  |-->double
. newaxis  |-->OclAny
. pi  |-->double
. e  |-->double
. euler_gamma  |-->double
. int32  |-->OclType
. int64  |-->OclType
. float32  |-->OclType
. float64  |-->OclType
. array _1  |-->Sequence
. arange _1  |-->Sequence
. concatenate _1  |-->Sequence
. shape _1  |-->Sequence
. empty _1  |-->Sequence
. empty_like _1  |-->Sequence
. eye _1  |-->Sequence
. identity _1  |-->Sequence
. ones _1  |-->Sequence
. ones_like _1  |-->Sequence
. zeros _1  |-->Sequence
. zeros_like _1  |-->Sequence
. full _1  |-->Sequence
. full_like _1  |-->Sequence
. asarray _1  |-->Sequence
. asanyarray _1  |-->Sequence
. ascontiguousarray _1  |-->Sequence
. asmatrix _1  |-->Sequence
. copy _1  |-->Sequence
. fromstring _1  |-->Sequence
. linspace _1  |-->Sequence
. transpose _1  |-->Sequence
. sin _1  |-->Sequence
. cos _1  |-->Sequence
. tan _1  |-->Sequence
. arcsin _1  |-->Sequence
. arccos _1  |-->Sequence
. arctan _1  |-->Sequence
. sqrt _1  |-->Sequence
. round _1  |-->Sequence
. floor _1  |-->Sequence
. ceil _1  |-->Sequence
. sinh _1  |-->Sequence
. cosh _1  |-->Sequence
. tanh _1  |-->Sequence
. arcsinh _1  |-->Sequence
. arccosh _1  |-->Sequence
. arctanh _1  |-->Sequence
. rint _1  |-->Sequence
. trunc _1  |-->Sequence
. exp _1  |-->Sequence
. log _1  |-->Sequence
. log10 _1  |-->Sequence
. add _1  |-->Sequence
. subtract _1  |-->Sequence
. multiply _1  |-->Sequence
. divide _1  |-->Sequence
. matmul _1  |-->Sequence
. sort _1  |-->Sequence
. sum _1  |-->double
. prod _1  |-->double

ocltype::
= _1  |-->String<when> _1 String
= _1  |-->int<when> _1 int
= _1  |-->double<when> _1 real
= _1  |-->Sequence<when> _1`isSequenceExpression true
= _1  |-->Map<when> _1`isMapExpression true
= _1  |-->_1`ocltype
True  |-->boolean
False  |-->boolean
inf  |-->double
Infinity  |-->double
nan  |-->double
int  |-->int
float  |-->double
str  |-->String
dict  |-->Map
list  |-->Sequence
deque  |-->Sequence
set  |-->Set
tuple  |-->Sequence
bool  |-->boolean
callable _1  |-->boolean
bool _1  |-->boolean
abs _1  |-->double
all _1  |-->boolean
dict _1  |-->Map
globals _1  |-->Map
hex _1  |-->String
id _1  |-->int
any _1  |-->boolean
ascii _1  |-->String
filter _1  |-->Sequence
frozenset _1  |-->Set
hash _1  |-->int
input _1  |-->String
isinstance _1  |-->boolean
issubclass _1  |-->boolean
hasattr _1  |-->boolean
len _1  |-->int
list _1  |-->Sequence
deque _1  |-->Sequence
map _1  |-->Sequence
set _1  |-->Set
sorted _1  |-->Sequence
tuple _1  |-->Sequence
pow _1  |-->double
repr _1  |-->String
reversed _1  |-->Sequence
round _1  |-->double
print _1  |-->void
int _1  |-->int
float _1  |-->double
str _1  |-->String
format _1  |-->String
chr _1  |-->String
unichr _1  |-->String
ord _1  |-->int
type _1  |-->OclType
range _1  |-->Sequence
enumerate _1  |-->Sequence
zip _1  |-->Sequence
slice _1  |-->Sequence
open _1  |-->OclFile
asyncio _1  |-->OclProcess
collections _1  |-->_1`collectionsType
math _1  |-->_1`mathType
re _1  |-->_1`reType
np _1  |-->_1`numpyType
np _1 _2  |-->_2`npRandomType<when> _1 matches .random
numpy _1  |-->_1`numpyType
numpy _1 _2  |-->_2`npRandomType<when> _1 matches .random
pd _1  |-->_1`pandasType
pandas _1  |-->_1`pandasType
sys _1  |-->_1`sysType
sys _1 _2  |-->_2`trailerOclType<when> _2 trailer
_1 if _2 else _3  |-->_1`ocltype
lambda _1 : _2  |-->Function
lambda : _1  |-->Function
* _1  |-->Sequence
** _1  |-->Map
_1 ** _2  |-->double
+ _1  |-->_1`ocltype
- _1  |-->_1`ocltype
~ _1  |-->int
_1 * _2  |-->String<when> _1 String
_1 * _2  |-->Sequence<when> _1`ocltype Sequence
_1 * _2  |-->Sequence<when> _2`ocltype Sequence
_1 * _2  |-->int<when> _1`ocltype int, _2`ocltype int
_1 * _2  |-->double
_1 / _2  |-->double
_1 % _2  |-->String<when> _1 String
_1 % _2  |-->int
_1 // _2  |-->int
_1 @ _2  |-->Sequence
_1 + _2  |-->_1`ocltype
_1 - _2  |-->double
_1 << _2  |-->int
_1 >> _2  |-->int
_1 & _2  |-->int
_1 ^ _2  |-->int
_1 | _2  |-->Map<when> _1 Map
_1 | _2  |-->int
not _1  |-->boolean
_1 and _2  |-->boolean
_1 or _2  |-->boolean
_1 < _2  |-->boolean
_1 > _2  |-->boolean
_1 == _2  |-->boolean
_1 >= _2  |-->boolean
_1 <= _2  |-->boolean
_1 <> _2  |-->boolean
_1 != _2  |-->boolean
_1 not in _2  |-->boolean
_1 in _2  |-->boolean
_1 is not _2  |-->boolean
_1 is _2  |-->boolean
( _1 )  |-->_1`ocltype
{ _1 }  |-->Set<when> _1 dictorsetmaker
r _1  |-->String
R _1  |-->String
f _1  |-->String
_1 _2  |-->Sequence<when> _2 matches .shape
_1 _2  |-->OclIterator<when> _1 generator, _2 trailer
_1 _2  |-->_1<when> _1 Class, _2 trailer
_1 _2  |-->_2`mapTrailerType<when> _1 Map, _2 trailer
_1 _2  |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer
_1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer
_1  |-->int<when> _1 int
_1  |-->double<when> _1 real
_1  |-->String<when> _1 String
_1  |-->Sequence<when> _1`isSequenceExpression true
_1  |-->_1`ocltype<when> _1 testlist_star_expr
_1  |-->_1`ocltype<when> _1 testlist
_1  |-->_1`ocltype<when> _1 trailer
_1  |-->_1`ocltype<when> _1 arglist
_1  |-->_1`ocltype<when> _1 argument
_1  |-->_1`ocltype<when> _1 arguments
_1  |-->_1`ocltype<when> _1 test
_1  |-->_1`ocltype<when> _1 logical_test
_1  |-->_1`ocltype<when> _1 comparison
_1  |-->_1`ocltype<when> _1 expr
_1  |-->_1`ocltype<when> _1 atom
_1  |-->_1`ocltype<when> _1 name
_1  |-->_1`ocltype<when> _1 subscriptlist
_1  |-->_1`ocltype<when> _1 subscript
_1  |-->_1`numberType<when> _1 number
_1  |-->OclAny
_*  |-->OclAny

pandasTrailer::
. read_csv _1  |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap()
. read_json _1  |-->OclFile.newOclFile_Read(OclFile.newOclFile(_1)).readMap()
. DataFrame _1  |-->_1
. Series _1  |-->_1`first

pandasType::
. read_csv _1  |-->OclDataTable
. read_json _1  |-->OclDataTable
. DataFrame _1  |-->OclDataTable
. Series _1  |-->Sequence
_1  |-->OclAny
_*  |-->OclAny

paramDefaultCode::
_1 = _2  |-->    if _1`parameterName->oclIsUndefined() then _1`parameterName := _2 else skip;\n
*  |-->
_1  |-->

parameterName::
_1  |-->_1
_1 : _2  |-->_1

parametersTail::
self  |-->
_1  |-->_1`parametersTail<when> _1 def_parameters
self ,  |-->
_1 ,  |-->_1
self , _*  |-->_*
_1 , _*  |-->_1 , _*

pickleTrailer::
. dump _1  |-->_1`secondArg.writeObject(_1`firstArg)
. load _1  |-->_1.readObject()
. _1  |-->
. _1 _*  |-->
_1  |-->

popArguments::
( )  |-->->last()
( _1 )  |-->->at(_1`firstArg+1)
[ ]  |-->->last()
[ _1 ]  |-->->at(_1`firstArg+1)

popUpdateArguments::
( )  |-->->front()
( _1 )  |-->->excludingAt(_1+1)
[ ]  |-->->front()
[ _1 ]  |-->->excludingAt(_1`firstArg+1)

popleftArguments::
( )  |-->->first()
[ ]  |-->->first()

popleftUpdateArguments::
( )  |-->->tail()
[ ]  |-->->tail()

printTrailer::
_1  |-->_1`printTrailer<when> _1 trailer
_1  |-->_1`printTrailer<when> _1 arguments
( _1 )  |-->(_1`printTrailer)
_1 _*  |-->_1
_1  |-->_1

randomTrailer::
. Random _1  |-->OclRandom.newOclRandom()
. choice _1  |-->OclRandom.randomElement_1
. choices _1  |-->OclRandom.randomElements_1
. gauss _1  |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr())
. normalvariate _1  |-->(OclRandom.defaultInstanceOclRandom()).nextNormal(_1`firstArg,(_1`secondArg)->sqr())
. random _1  |-->(OclRandom.defaultInstanceOclRandom()).nextDouble()
. randint _1  |-->(_1`firstArg + (OclRandom.defaultInstanceOclRandom()).nextInt(_1`lastArg - _1`firstArg))
. randrange _1  |-->(OclRandom.defaultInstanceOclRandom()).nextInt_1
. sample _1  |-->OclRandom.randomUniqueElements_1
. seed _1  |-->(OclRandom.defaultInstanceOclRandom()).setSeed_1
. shuffle _1  |-->OclRandom.randomiseSequence_1
. uniform _1  |-->(OclRandom.defaultInstanceOclRandom()).nextUniform_1
. _1  |-->
. _1 _*  |-->
_1  |-->

rangeArguments::
( )  |-->
( _1 )  |-->_1`rangeArguments
_1  |-->Integer.subrange(0, _1-1)
_1 , _2  |-->Integer.subrange(_1, _2-1)
_1 , _2 , -1  |-->Integer.subrange(_2 + 1, _1)->reverse()
_1 , _2 , _3  |-->Integer.subrange(_1, _2-1)->select( $x | ($x - _1) mod _3 = 0 )

rangeTrailer::
_1  |-->_1`rangeArguments

reTrailer::
. compile _1  |-->OclRegex.compile_1
. search _1  |-->(_1`secondArg)->firstMatch(_1`firstArg)
. match _1  |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + ".*")
. fullmatch _1  |-->(_1`secondArg)->firstMatch("^" + _1`firstArg + "$")
. split _1  |-->(_1`secondArg)->split(_1`firstArg)
. findall _1  |-->(_1`secondArg)->allMatches(_1`firstArg)
. finditer _1  |-->OclIterator.newOclIterator_Sequence((_1`secondArg)->allMatches(_1`firstArg))
. sub _1  |-->(_1`thirdArg).replaceAllMatches(_1`firstArg, _1`secondArg)
. _1  |-->
. _1 _*  |-->
_1  |-->

reType::
. compile _1  |-->OclRegex
. search _1  |-->String
. match _1  |-->String
. fullmatch _1  |-->String
. split _1  |-->Sequence(String)
. findall _1  |-->Sequence(String)
. finditer _1  |-->OclIterator
. sub _1  |-->String
. _1  |-->OclAny
. _1 _*  |-->OclAny
_1  |-->OclAny

removeAtomBrackets::
( )  |-->()
( _1 )  |-->_1`first<when> _1 multiple
( _1 )  |-->_1
[ ]  |-->Sequence{}
{ }  |-->Set{}
[ _1 ]  |-->_1`sequenceFormation
{ _1 }  |-->_1
` _1 `  |-->"_1"
- _1  |-->-_1
None  |-->null
True  |-->true
False  |-->false
inf  |-->Math_PINFINITY
Infinity  |-->Math_PINFINITY
nan  |-->Math_NaN
...  |-->...
print  |-->print
exec  |-->exec
int  |-->OclType["int"]
float  |-->OclType["double"]
str  |-->OclType["String"]
bool  |-->OclType["boolean"]
dict  |-->OclType["Map"]
list  |-->OclType["Sequence"]
set  |-->OclType["Set"]
R _1  |-->StringLib.rawString(_1)
r _1  |-->StringLib.rawString(_1)
f _1  |-->StringLib.formattedString(_1)
_1  |-->_1`removeAtomBrackets<when> _1 arguments
_1  |-->_1

removeSelf::
self _1  |-->_1`removeSelf<when> _1 trailer
. _1  |-->_1
_1  |-->_1`removeSelf<when> _1 testlist
_1  |-->_1`removeSelf<when> _1 test
_1  |-->_1`removeSelf<when> _1 logical_test
_1  |-->_1`removeSelf<when> _1 comparison
_1  |-->_1`removeSelf<when> _1 expr
_1  |-->

removeTrailerBrackets::
. _1 _2  |-->_2`removeAtomBrackets

reversedAccess::
0  |-->->first()
_1 , _2  |-->_2`reversedAccess_1`reversedAccess
[ _1 ]  |-->_1`reversedAccess<when> _1 subscriptlist
_1  |-->_1`reversedAccess<when> _1 subscriptlist
_1  |-->->at(_1)<when> _1 String
_1  |-->->at(_1 + 1)

secondArg::
( )  |-->
( _1 )  |-->_1`third
[ ]  |-->
[ _1 ]  |-->_1`third
_1  |-->_1`secondArg

selectPart::
for _1 in _2  |-->true
for _1 in _2 _3  |-->let _1`first : OclAny = _tuple->at(1) in let _1`third : OclAny = _tuple->at(2) in _3`selectPart<when> _1 multiple
for _1 in _2 _3  |-->_3`selectPart
_1  |-->true
if _1  |-->_1
if _1 _2  |-->_1 & _2`selectPart

sequenceArgumentsQueryForm::
( )  |-->()
( _1 )  |-->(_1)
[ ]  |-->()
[ _1 ]  |-->->selectElements(_1`literalSubscript)<when> _1`ocltype boolean
[ _1 ]  |-->->restrict(_1`literalSubscript->collect(_ind | _ind+1))<when> _1`ocltype Sequence
[ _1 ]  |-->->at(_1`literalSubscript+1)

sequenceArgumentsType::
( )  |-->OclAny
( _1 )  |-->_1`ocltype
[ ]  |-->OclAny
[ _1 ]  |-->Sequence<when> _1`ocltype boolean
[ _1 ]  |-->Sequence<when> _1`ocltype Sequence
[ _1 ]  |-->OclAny

sequenceFormation::
_1  |-->_1<when> _1 star_expr
_1  |-->Sequence{ _1 }
_1 ,  |-->Sequence{ _1 }
_1 , _*  |-->_1->union(_*`recurse)<when> _1 star_expr
_1 , _*  |-->Sequence{_1}->union(_*`recurse)
_1 _2  |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _2`collectPart(_1))<when> _2 comp_for

sequenceQueryForm::
. count _1  |-->->count_1
. index _1  |-->->indexOf_1 - 1
. sort _1  |-->->sort()
. reverse _1  |-->->reverse()
. pop _1  |-->_1`popArguments
. popleft _1  |-->_1`popleftArguments
. add _1  |-->->including_1
. copy _1  |-->->copy()
. intersection _1  |-->->intersection_1
. intersection_update _1  |-->->intersection_1
. difference _1  |--> - _1
. difference_update _1  |--> - _1
. isdisjoint _1  |-->->intersection_1->isEmpty()
. issubset _1  |--> <: _1
. issuperset _1  |-->->includesAll_1
. symmetric_difference _1  |-->->symmetricDifference_1
. update _1  |-->_1`allUnion
. remove _1  |-->->excludingFirst_1
. discard _1  |-->->excluding_1
. clear _1  |-->->intersection(Set{})
. items _1  |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
. max _1  |-->->max()
. min _1  |-->->min()
. head _1  |-->->collect( _ser | _ser.subrange(1,_1))
. tail _1  |-->->collect( _ser | _ser.subrange(_1, _ser->size()))
. at _1  |-->_1`reversedAccess
. maxlen  |-->->size()
. _1  |-->._1
. _1 _*  |-->._1_*
_1  |-->_1`sequenceArgumentsQueryForm<when> _1 arguments
_1  |-->_1

sequenceTrailerType::
. count _1  |-->int
. index _1  |-->int
. sort _1  |-->Sequence
. reverse _1  |-->Sequence
. pop _1  |-->OclAny
. popleft _1  |-->OclAny
. add _1  |-->Sequence
. copy _1  |-->Sequence
. intersection _1  |-->Sequence
. intersection_update _1  |-->Sequence
. difference _1  |-->Sequence
. difference_update _1  |-->Sequence
. isdisjoint _1  |-->boolean
. issubset _1  |-->boolean
. issuperset _1  |-->boolean
. symmetric_difference _1  |-->Sequence
. update _1  |-->Sequence
. remove _1  |-->Sequence
. discard _1  |-->Sequence
. clear _1  |-->Sequence
. items _1  |-->Sequence
. max _1  |-->OclAny
. min _1  |-->OclAny
. head _1  |-->Sequence
. tail _1  |-->Sequence
. at _1  |-->OclAny
. maxlen  |-->int
. _1  |-->OclAny
. _1 _*  |-->OclAny
_1  |-->_1`sequenceArgumentsType<when> _1 arguments
_1  |-->_1`ocltype

setFormation::
** _1  |-->_1
_1  |-->Set{ _1 }
** _1 , _*  |-->_1->union(_*`recurse)
_1 , _*  |-->Set{_1}->union(_*`recurse)
_1 _2  |-->_2`domainPart->select(_2`variablePart | _2`selectPart)->collect(_2`variablePart | _1)->asSet()<when> _2 comp_for

simple_stmt::
_1  |-->_1
_1 <EOF>  |-->_1
_*  |-->_*

single_input::
_1  |-->_1
_1 _2  |-->_1

sliceop::
: _1  |-->

small_stmt::
_1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true
_1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple
_1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true
_1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true
_1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..*
_1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.*
_1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true
_1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype
_1 _2  |-->    _1 := _1_2<when> _2 assign_part
print _1  |-->    execute (_1`printTrailer)->display()
del _1  |-->    execute (_1)->isDeleted()
pass  |-->    skip
break  |-->    break
continue  |-->    continue
return _1  |-->    return _1
return  |-->    return
raise _1  |-->    error _1`errorToUML
raise _1 from _2  |-->    error _1`errorToUML
raise _*  |-->    _*`errorlist
import _1  |-->    skip
from _*  |-->    skip
global _*  |-->_*`assertDefined
exec _1  |-->_0`pythonExec
exec _*  |-->    execute _*
assert _1  |-->    assert _1 do "assertion failed"
assert _1 , _2  |-->    assert _1 do _2
nonlocal _*  |-->_*`assertDefined
_1  |-->_1<when> _1 yield_expr
_1  |-->_1`updateForm<when> _1 testlist_star_expr

sortedArguments::
( _1 )  |-->_1`sortedArguments
_1  |-->_1->keys()->sort()<when> _1 Map
_1  |-->_1->sort()
_1 , _2  |-->_1->sortedBy($x | _2`sortedKeySpecification)
_1 , _2 , _3  |-->_1->sortedBy($x | _2`sortedKeySpecification)

sortedKeySpecification::
key = _1  |-->(_1)->apply($x)
_1  |-->_1`sortedKeySpecification<when> _1 test
_1  |-->_1`sortedKeySpecification<when> _1 logical_test
_1  |-->$x

sortedTrailer::
_1  |-->_1`sortedArguments

sqliteTrailer::
. connect _1  |-->OclDatasource.getConnection(_1`firstArg, "", "")
. complete_statement _1  |-->SQLStatement.isValidSQL(_1`firstArg)
. enable_callback_tracebacks _1  |-->
. register_adapter _1  |-->
. register_converter _1  |-->
. _1  |-->
. _1 _*  |-->
_1  |-->

star_expr::
* _1  |-->_1

stmt::
_1  |-->_1

subscript::
...  |-->
0  |-->->first()
-1  |-->->last()
-2  |-->->front()->last()
-3  |-->->front()->front()->last()
_1  |-->->reverse()->at(-(_1))<when> _1 matches -.*
_1 : _2  |-->.subrange(_1+1, _2)<when> _2 test
: -1  |-->->front()
: -2  |-->->front()->front()
: -3  |-->->front()->front()->front()
: _1  |-->.subrange(1,_1)<when> _1 test
1 :  |-->->tail()
_1 :  |-->.subrange(_1+1)<when> _1 test
_1  |-->->at(_1)<when> _1 String
_1  |-->->selectRows(_1)<when> _1`ocltype boolean
_1  |-->->restrict(_1)<when> _1`ocltype Sequence
_1  |-->[_1+1]

subscriptlist::
:  |-->
_1  |-->_1
: , _1  |-->->collect( _r | _r_1 )
_1 , :  |-->_1
_1 , _*  |-->_1_*`recurse

subslistOclType::
:  |-->Sequence
_1  |-->OclAny
: _*  |-->Sequence
_1 , :  |-->Sequence
_1 , _*  |-->_*`recurse

suite::
_1  |-->_1
_1 _*  |-->_1_*`followingStatement

sysTrailer::
. exception _1  |-->OclException->allInstances()->last()
. platform  |-->OclProcess.getEnvironmentProperty("OS")
. stdin  |-->OclFile["System.in"]
. stderr  |-->OclFile["System.err"]
. stdout  |-->OclFile["System.out"]

sysType::
. exception _1  |-->OclException
. platform  |-->String
. stdin  |-->OclFile
. stderr  |-->OclFile
. stdout  |-->OclFile

test::
_1 if _2 else _3  |-->if _2 then _1 else _3 endif
lambda _1 : _2  |-->lambda _1 in (_2)
lambda : _2  |-->lambda $$ : OclAny in (_2)
_1  |-->_1

testlist::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

testlist_comp::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

testlist_star_expr::
_1  |-->_1
_1 , _*  |-->_1,_*`recurse

thirdArg::
( )  |-->
( _1 )  |-->_1`fifth
[ ]  |-->
[ _1 ]  |-->_1`fifth
_1  |-->_1`thirdArg

thirdFirstArg::
_1 _2 _3  |-->_3`firstArg

thirdSecondArg::
_1 _2 _3  |-->_3`secondArg

trailer::
. count _1  |-->->count_1
. index _1  |-->->indexOf_1 - 1
. sort _1  |-->->sort()
. reverse _1  |-->->reverse()
. pop _1  |-->_1`popArguments
. popleft _1  |-->_1`popleftArguments
. add _1  |-->->including_1
. copy _1  |-->->copy()
. intersection _1  |-->->intersection_1
. intersection_update _1  |-->->intersection_1
. difference _1  |--> - _1
. difference_update _1  |--> - _1
. isdisjoint _1  |-->->excludesAll_1
. issubset _1  |--> <: _1
. issuperset _1  |-->->includesAll_1
. symmetric_difference _1  |-->->symmetricDifference_1
. update _1  |-->_1`allUnion
. remove _1  |-->->excludingFirst_1
. discard _1  |-->->excluding_1
. clear _1  |-->->intersection(Set{})
. items _1  |-->->asSequence()->collect( _mx | Sequence{_mx->keys()->any(), _mx->values()->any()})
. upper _1  |-->->toUpperCase()
. lower _1  |-->->toLowerCase()
. strip _1  |-->->trim()
. split _1  |-->->split_1
. replace _1  |-->.replace_1
. find _1  |-->_1`findQualifier->indexOf(_1`firstArg) - 1
. startswith _1  |-->->hasPrefix_1
. endswith _1  |-->->hasSuffix_1
. isalpha _1  |-->->matches("[a-zA-Z]*")
. isnumeric _1  |-->->matches("[0-9]*")
. isalnum _1  |-->->matches("[a-zA-Z0-9]*")
. islower _1  |-->->matches("[a-z ]*")
. isupper _1  |-->->matches("[A-Z ]*")
. isspace _1  |-->->matches("[ \t\n\r]*")
. isdigit _1  |-->->matches("[0-9]*")
. isdecimal _1  |-->->matches("[0-9]*")
. readable _1  |-->.canRead()
. writable _1  |-->.canWrite()
. close _1  |-->.closeFile()
. read _1  |-->.readAll()
. write _1  |-->.write_1
. seek _1  |-->.setPosition_1
. tell _1  |-->.getPosition()
. readline _1  |-->.readLine()
. sleep _1  |-->OclProcess.sleepSeconds_1
. create_task _1  |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).startProcess()
. run _1  |-->(OclProcess.newOclProcess(_1`createTaskArguments, "")).start()
. cursor _1  |-->.createStatement()
. commit _1  |-->.commit()
. rollback _1  |-->.rollback()
. execute _1  |-->.executeQuery(_1`firstArg)
. executemany _1  |-->.executeMany(_1`firstArg,_1`secondArg)
. fetchone _1  |-->.next()
. fetchall _1  |-->.getElements()
. close _1  |-->.close()
. deque _1  |-->_1
. OrderedDict _1  |-->_1
. gauss _1  |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr())
. normalvariate _1  |-->.nextNormal(_1`firstArg, (_1`secondArg)->sqr())
. standard_normal _1  |-->.nextGaussian_1
. uniform _1  |-->.nextUniform_1
. randrange _1  |-->.nextInt_1
. random _1  |-->.nextDouble()
. randint _1  |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg
. integers _1  |-->.nextInt(_1`lastArg - _1`firstArg) + _1`firstArg
. seed _1  |-->.setSeed_1
. max _1  |-->->max()
. min _1  |-->->min()
. head _1  |-->->collect( _ser | _ser.subrange(1,_1))
. tail _1  |-->->collect( _ser | _ser.subrange(_1, _ser->size()))
. at _1  |-->_1`reversedAccess
. day  |-->.getDate()
. year  |-->.getYear()
. month  |-->.getMonth()
. hour  |-->.getHours()
. minute  |-->.getMinutes()
. second  |-->.getSeconds()
. maxlen  |-->->size()
. _1  |-->._1
. _1 _*  |-->._1_*
_1  |-->_1

trailerOclType::
. cosin _1  |-->double
. sin _1  |-->double
. tan _1  |-->double
. ceil _1  |-->int
. floor _1  |-->int
. trunc _1  |-->int
. sqrt _1  |-->double
. cbrt _1  |-->double
. exp _1  |-->double
. log _1  |-->double
. log10 _1  |-->double
. acos _1  |-->double
. asin _1  |-->double
. atan _1  |-->double
. acosh _1  |-->double
. asinh _1  |-->double
. atanh _1  |-->double
. cosh _1  |-->double
. sinh _1  |-->double
. tanh _1  |-->double
. pow _1  |-->double
. comb _1  |-->int
. fabs _1  |-->double
. factorial _1  |-->int
. fsum _1  |-->double
. prod _1  |-->double
. gcd _1  |-->int
. lcm _1  |-->int
. count _1  |-->int
. index _1  |-->int
. isdisjoint _1  |-->boolean
. issubset _1  |-->boolean
. issuperset _1  |-->boolean
. clear _1  |-->Set
. items _1  |-->Sequence
. upper _1  |-->String
. lower _1  |-->String
. split _1  |-->Sequence
. strip _1  |-->String
. replace _1  |-->String
. find _1  |-->int
. startswith _1  |-->boolean
. endswith _1  |-->boolean
. isalpha _1  |-->boolean
. isnumeric _1  |-->boolean
. isalnum _1  |-->boolean
. islower _1  |-->boolean
. isupper _1  |-->boolean
. isspace _1  |-->boolean
. isdigit _1  |-->boolean
. isdecimal _1  |-->boolean
. readable _1  |-->boolean
. writable _1  |-->boolean
. read _1  |-->String
. tell _1  |-->int
. readline _1  |-->String
. Random _1  |-->OclRandom
. gauss _1  |-->double
. normalvariate _1  |-->double
. uniform _1  |-->double
. randrange _1  |-->int
. random _1  |-->double
. randint _1  |-->int
. choices _1  |-->Sequence
. sample _1  |-->Sequence
. today _1  |-->OclDate
. now _1  |-->OclDate
. fromtimestamp _1  |-->OclDate
. fromisoformat _1  |-->OclDate
. max _1  |-->double
. min _1  |-->double
. mean _1  |-->double
. median _1  |-->double
. head _1  |-->Map
. tail _1  |-->Map
. at _1  |-->OclAny
. capitalize _1  |-->String
. join _1  |-->String
. title _1  |-->String
. swapcase _1  |-->String
. lstrip_1  |-->String
. rstrip _1  |-->String
. istitle _1  |-->boolean
. rjust _1  |-->String
. ljust _1  |-->String
. format _1  |-->String
. _1  |-->OclAny
. _1 _2  |-->OclAny
. _*  |-->OclAny
_1  |-->_1`argsOclType<when> _1 arguments
_1  |-->OclAny

trailerSideEffect::
. pop ( )  |-->true
. pop _1  |-->true
. popleft ( )  |-->true
. popleft _1  |-->true
. _1  |-->
. _1 _*  |-->
_1  |-->

trailerUpdateForm::
. append _1  |-->->append_1
. extend _1  |-->->union(_1->characters())<when> _1 String
. extend _1  |-->->union_1
. insert _1  |-->.insertAt(_1`firstArg+1, _1`lastArg)
. remove _1  |-->->excludingFirst_1
. sort _1  |-->->sort()
. reverse _1  |-->->reverse()
. pop _1  |-->_1`popUpdateArguments
. popleft _1  |-->_1`popleftUpdateArguments
. add _1  |-->->including_1
. intersection _1  |-->->intersection_1
. intersection_update _1  |-->->intersection_1
. difference _1  |--> - _1
. difference_update _1  |--> - _1
. symmetric_difference _1  |-->->symmetricDifference_1
. update _1  |-->_1`allUnion
. discard _1  |-->->excluding_1
. clear _1  |-->->intersection(Set{})
. appendleft _1  |-->->prepend_1
. extendleft _1  |-->->reverse()->union_1->reverse()
. _1  |-->._1
. _1 _*  |-->._1_*
_1  |-->_1

tupleDeclarations::
_1 , _*  |-->      var _1 : OclAny := _tuple->at(_indx); _indx := _indx + 1;\n_*`recurse
_1  |-->      var _1 : OclAny := _tuple->at(_indx);\n

typedargslist::
_1  |-->_1
_1 ,  |-->_1
_1 , _*  |-->_1, _*`recurse

typedargslistAttributes::
_1  |-->_1`asAttributes
_1 ,  |-->_1`asAttributes
_1 , _*  |-->_1`asAttributes_*`recurse

typedargslistSettings::
_1  |-->_1`asSettings
_1 ,  |-->_1`asSettings
_1 , _*  |-->_1`asSettings_*`recurse

updateForm::
_1  |-->_1`updateForm<when> _1 testlist_star_expression
_1  |-->_1`updateForm<when> _1 testlist
_1  |-->_1`updateForm<when> _1 test
_1  |-->_1`updateForm<when> _1 logical_test
_1  |-->_1`updateForm<when> _1 comparison
_1  |-->_1`updateForm<when> _1 expr
exec _1  |-->_0`pythonExec
exec _*  |-->    execute _*
print _1  |-->    execute _1`printTrailer->display()
del _1  |-->    execute _1->isDeleted()
await asyncio _1  |-->    _1`asyncioTrailer<when> _1 trailer
await _1  |-->    _1.join()
np _1  |-->    _1`removeTrailerBrackets := _1`numpyTrailer
np _1 _2  |-->_2`npRandomTrailer<when> _1 matches .random
pickle _1  |-->    _1`thirdSecondArg.writeObject(_1`thirdFirstArg)<when> _1`second dump
asyncio _1  |-->    _1`asyncioTrailer
numpy _1  |-->    _1`removeTrailerBrackets := _1`numpyTrailer
numpy _1 _2  |-->_2`npRandomTrailer<when> _1 matches .random
_1 _2  |-->    _1.closeFile()<when> _1 atom, _2`second close
_1 _2  |-->    _1.write_2`third<when> _1 atom, _2`second write
_1 _2  |-->    execute (_2`third : _1)<when> _1 atom, _2`second append
_1 _2  |-->    execute (_2`third : _1)<when> _1 atom, _2`second add
_1 _2  |-->    execute (_2`third /: _1)<when> _1 atom, _2`second remove
_1 _2  |-->    execute (_2`third /: _1)<when> _1 atom, _2`second discard
_1 _2  |-->    execute (_2`third <: _1)<when> _1 atom, _2`second update
_1 _2  |-->    execute (_2`third /<: _1)<when> _1 atom, _2`second difference_update
_1 _2  |-->    execute ((_1 - _2`third) /<: _1)<when> _1 atom, _2`second intersection_update
_1 _2  |-->    execute (_1 /<: _1)<when> _1 atom, _2`second clear
_1 _2  |-->    _1`removeAtomBrackets := _1_2`trailerUpdateForm<when> _1 atom, _2 trailer, _2`isUpdating true
_1 _2  |-->    _1_2<when> _1 atom, _2 trailer
_1 , _*  |-->    _1 ;\n_*`recurse
_1  |-->

varargs::
* _1  |-->_1 : Sequence(OclAny)

varargslist::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

vardef_parameter::
*  |-->$star : Sequence(OclAny)
_1  |-->_1 : OclAny
_1 = _2  |-->_1 : int<when> _2 integer
_1 = _2  |-->_1 : double<when> _2 real
_1 = _2  |-->_1 : String<when> _2 String
_1 = _2  |-->_1 : boolean<when> _2 boolean
_1 = _2  |-->_1 : OclAny

vardef_parameters::
_1  |-->_1
_1 , _*  |-->_1, _*`recurse

variablePart::
for _1 in _2  |-->_tuple<when> _1 multiple
for _1 in _2 _3  |-->_tuple<when> _1 multiple
for _1 in _2  |-->_1
for _1 in _2 _3  |-->_1_3`variableTailPart

variableTailPart::
for _1 in _2  |-->; _tuple : _2<when> _1 multiple
for _1 in _2 _3  |-->; _tuple : _2<when> _1 multiple
for _1 in _2  |-->; _1 : _2
for _1 in _2 _3  |-->; _1 : _2_3`variableTailPart
_1  |-->_1`variableTailPart<when> _1 comp_for
if _1  |-->
if _1 _2  |-->_2`variableTailPart
_1  |-->

varkwargs::
** _1  |-->_1 : Map(String, OclAny)

with_item::
_1 as _2  |-->var _2 : _1`ocltype := _1;\n
( _* )  |-->_*`with_item

yield_arg::
from _1  |-->_1
_1  |-->_1

yield_expr::
yield  |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return null
yield _1  |-->    if _yieldCount_ < _position_ then _yieldCount_ := _yieldCount_ + 1 else return _1



>>> Read 2 lines
>>> Parsed AST: (file_input (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))))
>>> arity = 4
>>> Subterms are:
(stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))

>>>> Applying basic term name rule _1  |-->_1 for (name Student)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Student
>>>> Applying basic term name rule _1  |-->_1 for (name __init__)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by __init__
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name self))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by self
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set self tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name name))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by name
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name name)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set name tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name num))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by num
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name num)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set num tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name age))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by age
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name age)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set age tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name degree))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by degree
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name degree)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set degree tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree : OclAny
>>>> Applying def_parameters rule _1 , _*  |-->_1, _*`recurse for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name name))), ,, (def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name name))), ,, (def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying def_parameters rule _1 , _*  |-->_1, _*`recurse for (def_parameters (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying def_parameters rule _1 , _*  |-->_1, _*`recurse for (def_parameters (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying def_parameters rule _1 , _*  |-->_1, _*`recurse for (def_parameters (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name degree)))]

>>>> Applying def_parameters rule _1  |-->_1 for (def_parameters (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree : OclAny
>--> Replacing metafeature _*`recurse by degree : OclAny
>> Applied vector rule: _1, degree : OclAny
>***> RHS after replacement of metafeatures: _1, degree : OclAny

>--> Replacing _1 by age : OclAny
>--> Replacing _* by degree : OclAny
>--> Replacing metafeature _*`recurse by age : OclAny, degree : OclAny
>> Applied vector rule: _1, age : OclAny, degree : OclAny
>***> RHS after replacement of metafeatures: _1, age : OclAny, degree : OclAny

>--> Replacing _1 by num : OclAny
>--> Replacing _* by age : OclAny,degree : OclAny
>--> Replacing metafeature _*`recurse by num : OclAny, age : OclAny, degree : OclAny
>> Applied vector rule: _1, num : OclAny, age : OclAny, degree : OclAny
>***> RHS after replacement of metafeatures: _1, num : OclAny, age : OclAny, degree : OclAny

>--> Replacing _1 by name : OclAny
>--> Replacing _* by num : OclAny,age : OclAny,degree : OclAny
>--> Replacing metafeature _*`recurse by name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>> Applied vector rule: _1, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>***> RHS after replacement of metafeatures: _1, name : OclAny, num : OclAny, age : OclAny, degree : OclAny

>--> Replacing _1 by self : OclAny
>--> Replacing _* by name : OclAny,num : OclAny,age : OclAny,degree : OclAny
>>>> Applying typedargslist rule _1  |-->_1 for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Name))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Name
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Name))

>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Name))

>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Name))

>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Name))

>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Name)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Name
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Name))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Name
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Name
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Name
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Name
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Name
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->_1 for (atom (name name))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name name)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name name))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name name))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name name)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name name)))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (name name)))
>>>> Applying expr rule _1  |--> for (expr (atom (name name)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by name
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by name
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by name
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches .*\..* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))

||| Condition _1 matches .*\..* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 _2

>--> Replacing _1 by self.Name
>--> Replacing _2 by := name
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Name := name
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Name := name
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Num))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Num
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Num))

>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Num))

>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Num))

>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Num))

>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Num)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Num
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Num))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Num
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Num
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Num
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Num
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Num
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->_1 for (atom (name num))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name num)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name num))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name num))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name num)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name num)))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (name num)))
>>>> Applying expr rule _1  |--> for (expr (atom (name num)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by num
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by num
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by num
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches .*\..* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))

||| Condition _1 matches .*\..* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 _2

>--> Replacing _1 by self.Num
>--> Replacing _2 by := num
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Num := num
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Num := num
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Age))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Age
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Age)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Age
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Age))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->_1 for (atom (name age))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name age)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name age))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name age))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name age)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name age)))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (name age)))
>>>> Applying expr rule _1  |--> for (expr (atom (name age)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by age
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by age
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by age
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches .*\..* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

||| Condition _1 matches .*\..* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 _2

>--> Replacing _1 by self.Age
>--> Replacing _2 by := age
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Age := age
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Age := age
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Degree))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Degree
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Degree)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Degree
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Degree))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->_1 for (atom (name degree))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name degree))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name degree))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name degree)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (name degree)))
>>>> Applying expr rule _1  |--> for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by degree
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by degree
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by degree
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches .*\..* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))

||| Condition _1 matches .*\..* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 _2

>--> Replacing _1 by self.Degree
>--> Replacing _2 by := degree
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Degree := degree
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Degree := degree
>>>> Applying suite rule _1 _*  |-->_1_*`followingStatement for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1 _*  |-->_1_*`followingStatement are [_*`followingStatement]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature followingStatement to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))] : java.util.Vector

>***> Applying followingStatement to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))]

>***> Valid ruleset followingStatement

>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     self.Num := num
>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     self.Age := age
>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     self.Degree := degree
>--> Replacing metafeature _*`followingStatement by  ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree
>> Applied vector rule: _1 ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree
>***> RHS after replacement of metafeatures: _1 ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree

>--> Replacing _1 by     self.Name := name
>--> Replacing _* by     self.Num := num    self.Age := age    self.Degree := degree
>>> found metafeature _3`hasValueReturn for _3`
*** Metafeatures of _3`hasValueReturn are: [_3`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>>> found metafeature _1`hasValueReturn for _1`
*** Metafeatures of _1`hasValueReturn are: [_1`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Name
>--> Replacing _2 by := name
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Name := name
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Name := name
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

>!!> Conditions failed of rule _1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>>>> Applying suite rule _1 _*  |-->_*`recurse<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1 _*  |-->_*`recurse<when> _1 stmt are [_*`recurse]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature recurse to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))]

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>>> found metafeature _1`hasValueReturn for _1`
*** Metafeatures of _1`hasValueReturn are: [_1`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Num
>--> Replacing _2 by := num
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Num := num
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Num := num
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))

>!!> Conditions failed of rule _1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>>>> Applying hasValueReturn rule _1 _*  |-->_*`recurse<when> _1 stmt for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1 _*  |-->_*`recurse<when> _1 stmt are [_*`recurse]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature recurse to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))]

*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->false<when> _2 assign_part for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>>> found metafeature _1`hasValueReturn for _1`
*** Metafeatures of _1`hasValueReturn are: [_1`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Age
>--> Replacing _2 by := age
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := age
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := age
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))

>!!> Conditions failed of rule _1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>>>> Applying hasValueReturn rule _1 _*  |-->_*`recurse<when> _1 stmt for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1 _*  |-->_*`recurse<when> _1 stmt are [_*`recurse]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature recurse to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))]

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
>>>> Applying hasValueReturn rule _1  |-->_1`hasValueReturn<when> _1 stmt for (hasValueReturn (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Degree
>--> Replacing _2 by := degree
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := degree
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := degree
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := degree
>--> Replacing metafeature _*`recurse by false
>> Applied vector rule: false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := age
>--> Replacing _* by     self.Degree := degree
>--> Replacing metafeature _*`recurse by false
>> Applied vector rule: false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Num := num
>--> Replacing _* by     self.Age := age    self.Degree := degree
>--> Replacing metafeature _*`recurse by false
>> Applied vector rule: false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Name := name
>--> Replacing _* by     self.Num := num    self.Age := age    self.Degree := degree
>***> Applying ruleset hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))

>!!> Conditions failed of rule def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true for (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))
>>>> Applying basic term name rule _1  |-->_1 for (name __init__)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by __init__
>>>> Applying funcdef rule def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n for (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))
>***> Metafeatures of rule def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n are [_2`defaultParamSettings]
>***> LHS tokens: [def, _1, (, _2, ), :, _3]


>***> Applying metafeature defaultParamSettings to (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) : ASTCompositeTerm

>***> Applying defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))

>***> Valid ruleset defaultParamSettings

>>>> Applying typedargslist rule _1  |-->_1`defaultParamCode for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))
>***> Metafeatures of rule _1  |-->_1`defaultParamCode are [_1`defaultParamCode]
>***> LHS tokens: [_1]


>***> Applying metafeature defaultParamCode to (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))) : ASTCompositeTerm

>***> Applying defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))

>***> Valid ruleset defaultParamCode

>>>> Applying def_parameters rule _1 , _*  |-->_1`paramDefaultCode_*`recurse for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1`paramDefaultCode_*`recurse are [_*`recurse, _1`paramDefaultCode]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name name))), ,, (def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name name))), ,, (def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying defaultParamCode rule _1 , _*  |-->_1`paramDefaultCode_*`recurse for (defaultParamCode (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1`paramDefaultCode_*`recurse are [_*`recurse, _1`paramDefaultCode]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name num))), ,, (def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying defaultParamCode rule _1 , _*  |-->_1`paramDefaultCode_*`recurse for (defaultParamCode (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1`paramDefaultCode_*`recurse are [_*`recurse, _1`paramDefaultCode]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name age))), ,, (def_parameter (named_parameter (name degree)))]

>>>> Applying defaultParamCode rule _1 , _*  |-->_1`paramDefaultCode_*`recurse for (defaultParamCode (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1 , _*  |-->_1`paramDefaultCode_*`recurse are [_*`recurse, _1`paramDefaultCode]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name degree)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name degree)))]

>>>> Applying defaultParamCode rule _1  |-->_1`paramDefaultCode for (defaultParamCode (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule _1  |-->_1`paramDefaultCode are [_1`paramDefaultCode]
>***> LHS tokens: [_1]


>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name degree))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name degree)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name degree)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name degree)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by degree : OclAny
>--> Replacing metafeature _*`recurse by 
>> Applied vector rule: _1`paramDefaultCode

>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name age))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name age)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name age)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name age)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by age : OclAny
>--> Replacing _* by degree : OclAny
>--> Replacing metafeature _*`recurse by 
>> Applied vector rule: _1`paramDefaultCode

>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name num))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name num)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name num)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name num)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by num : OclAny
>--> Replacing _* by age : OclAny,degree : OclAny
>--> Replacing metafeature _*`recurse by 
>> Applied vector rule: _1`paramDefaultCode

>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name name))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name name)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name name)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name name)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by name : OclAny
>--> Replacing _* by num : OclAny,age : OclAny,degree : OclAny
>--> Replacing metafeature _*`recurse by 
>> Applied vector rule: _1`paramDefaultCode

>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name self))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>--> Replacing _* by name : OclAny,num : OclAny,age : OclAny,degree : OclAny
>***> Applying ruleset defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))

>--> Replacing metafeature _1`defaultParamCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>***> Applying ruleset defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))

>--> Replacing metafeature _2`defaultParamSettings by 
>***> RHS after replacement of metafeatures:   operation _1(_2)\n  pre: true post: true\n  activity:\n_3;\n\n

>--> Replacing _1 by __init__
>--> Replacing _2 by self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>--> Replacing _3 by     self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree
>>>> Applying compound_stmt rule _1  |-->    skip for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
>***> Metafeatures of rule _1  |-->    skip are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:     skip

>--> Replacing _1 by   operation __init__(self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny)
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;


>>>> Applying stmt rule _1  |-->_1 for (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     skip
>>>> Applying basic term name rule _1  |-->_1 for (name Degree_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree_F
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name self))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by self
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set self tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name n)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name n))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by n
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name n)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set n tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n : OclAny
>>>> Applying def_parameters rule _1 , _*  |-->_1, _*`recurse for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name n)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name n)))]

>>>> Applying def_parameters rule _1  |-->_1 for (def_parameters (def_parameter (named_parameter (name n))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n : OclAny
>--> Replacing metafeature _*`recurse by n : OclAny
>> Applied vector rule: _1, n : OclAny
>***> RHS after replacement of metafeatures: _1, n : OclAny

>--> Replacing _1 by self : OclAny
>--> Replacing _* by n : OclAny
>>>> Applying typedargslist rule _1  |-->_1 for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny, n : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Degree))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Degree
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Degree))

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Degree)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Degree
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Degree))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Degree
>>>> Applying basic term name rule _1  |-->_1 for (name n)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying atom rule _1  |-->_1 for (atom (name n))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name n)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name n))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name n)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name n))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name n)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by n
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name n)))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name n)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name n))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name n))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name n)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name n)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name n))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name n))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name n))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name n)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name n)))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name n))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name n))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name n)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name n)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name n)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name n)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name n))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name n))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name n)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name n)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name n))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name n))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name n))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name n))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name n))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name n)))

||| Condition _1 expr is satisfied by (expr (atom (name n)))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name n))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name n))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name n)))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (name n)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (name n)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (name n)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (name n)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (name n)))
>>>> Applying expr rule _1  |--> for (expr (atom (name n)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name n)))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name n))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name n)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name n))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name n)))))))

>!!> Conditions failed of rule += _1  |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>>>> Applying assign_part rule += _1  |--> + _1 for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule += _1  |--> + _1 are []
>***> LHS tokens: [+=, _1]

>***> RHS after replacement of metafeatures:  + _1

>--> Replacing _1 by n
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset colonAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by n
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 := _1_2<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 := _1_2<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 := _1_2

>--> Replacing _1 by self.Degree
>--> Replacing _2 by  + n
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Degree := self.Degree + n
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Degree := self.Degree + n
>>>> Applying suite rule _1  |-->_1 for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Degree := self.Degree + n
>>> found metafeature _3`hasValueReturn for _3`
*** Metafeatures of _3`hasValueReturn are: [_3`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
>>>> Applying suite rule _1  |-->_1`hasValueReturn<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Degree
>--> Replacing _2 by  + n
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))

>!!> Conditions failed of rule def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true for (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))
>>>> Applying basic term name rule _1  |-->_1 for (name Degree_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree_F
>>>> Applying funcdef rule def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n for (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))
>***> Metafeatures of rule def _1 ( _2 ) : _3  |-->  operation _1(_2)\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n are [_2`defaultParamSettings]
>***> LHS tokens: [def, _1, (, _2, ), :, _3]


>***> Applying metafeature defaultParamSettings to (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) : ASTCompositeTerm

>***> Applying defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))

>***> Valid ruleset defaultParamSettings

>>>> Applying typedargslist rule _1  |-->_1`defaultParamCode for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))
>***> Metafeatures of rule _1  |-->_1`defaultParamCode are [_1`defaultParamCode]
>***> LHS tokens: [_1]


>***> Applying metafeature defaultParamCode to (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))) : ASTCompositeTerm

>***> Applying defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))

>***> Valid ruleset defaultParamCode

>>>> Applying def_parameters rule _1 , _*  |-->_1`paramDefaultCode_*`recurse for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))
>***> Metafeatures of rule _1 , _*  |-->_1`paramDefaultCode_*`recurse are [_*`recurse, _1`paramDefaultCode]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(def_parameter (named_parameter (name n)))] : java.util.Vector

>***> Applying recurse to vector of terms [(def_parameter (named_parameter (name n)))]

>>>> Applying defaultParamCode rule _1  |-->_1`paramDefaultCode for (defaultParamCode (def_parameter (named_parameter (name n))))
>***> Metafeatures of rule _1  |-->_1`paramDefaultCode are [_1`paramDefaultCode]
>***> LHS tokens: [_1]


>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name n))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name n)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name n)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name n)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by n : OclAny
>--> Replacing metafeature _*`recurse by 
>> Applied vector rule: _1`paramDefaultCode

>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name self))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>--> Replacing _* by n : OclAny
>***> Applying ruleset defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))

>--> Replacing metafeature _1`defaultParamCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny, n : OclAny
>***> Applying ruleset defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))

>--> Replacing metafeature _2`defaultParamSettings by 
>***> RHS after replacement of metafeatures:   operation _1(_2)\n  pre: true post: true\n  activity:\n_3;\n\n

>--> Replacing _1 by Degree_F
>--> Replacing _2 by self : OclAny, n : OclAny
>--> Replacing _3 by     self.Degree := self.Degree + n
>>>> Applying compound_stmt rule _1  |-->    skip for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
>***> Metafeatures of rule _1  |-->    skip are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:     skip

>--> Replacing _1 by   operation Degree_F(self : OclAny, n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


>>>> Applying stmt rule _1  |-->_1 for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     skip
>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying named_parameter rule _1  |-->_1 : OclAny for (named_parameter (name self))
>***> Metafeatures of rule _1  |-->_1 : OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1 : OclAny

>--> Replacing _1 by self
>>>> Applying def_parameter rule _1  |-->_1<action> _1`defined true for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |-->_1<action> _1`defined true are []
>***> LHS tokens: [_1]

>>> found metafeature _1`defined for _1`
*** Set self tagged values: [defined=true]
>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny
>>>> Applying def_parameters rule _1  |-->_1 for (def_parameters (def_parameter (named_parameter (name self))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny
>>>> Applying typedargslist rule _1  |-->_1 for (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self : OclAny
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Age))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Age
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Age)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Age
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Age))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying basic term integer rule _1  |-->_1 for (integer 1)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*E.* for (number (integer 1))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 1)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*e.* for (number (integer 1))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 1)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying number rule _1  |-->_1 for (number (integer 1))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying atom rule _1  |-->_1 for (atom (number (integer 1)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying expr rule _1  |-->_1 for (expr (atom (number (integer 1))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (number (integer 1)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (number (integer 1))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (number (integer 1)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 1
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (number (integer 1)))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (number (integer 1)))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (number (integer 1))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (number (integer 1)))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (number (integer 1)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (number (integer 1)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (number (integer 1))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (number (integer 1))))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (number (integer 1)))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (number (integer 1)))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (number (integer 1))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (number (integer 1))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (number (integer 1))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (number (integer 1))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (number (integer 1)))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (number (integer 1)))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (number (integer 1))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (number (integer 1))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (number (integer 1)))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (number (integer 1)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (number (integer 1)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (number (integer 1)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (number (integer 1)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (number (integer 1))))

||| Condition _1 expr is satisfied by (expr (atom (number (integer 1))))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (number (integer 1)))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (number (integer 1)))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (number (integer 1))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (expr (atom (number (integer 1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (expr (atom (number (integer 1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (expr (atom (number (integer 1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (expr (atom (number (integer 1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 expr for (expr (atom (number (integer 1))))
>>>> Applying expr rule _1  |--> for (expr (atom (number (integer 1))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by 1
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (number (integer 1))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by 1
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (number (integer 1)))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by 1
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (number (integer 1))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by 1
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (number (integer 1)))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by 1
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))

>!!> Conditions failed of rule += _1  |--> + _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>>>> Applying assign_part rule += _1  |--> + _1 for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule += _1  |--> + _1 are []
>***> LHS tokens: [+=, _1]

>***> RHS after replacement of metafeatures:  + _1

>--> Replacing _1 by 1
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset colonAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by +=
>--> Replacing _2 by 1
>***> Applying ruleset equalAssign to ASTTerm (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>>>> Applying small_stmt rule _1 _2  |-->    _1 := _1_2<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>***> Metafeatures of rule _1 _2  |-->    _1 := _1_2<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures:     _1 := _1_2

>--> Replacing _1 by self.Age
>--> Replacing _2 by  + 1
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Age := self.Age + 1
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     self.Age := self.Age + 1
>>>> Applying basic term name rule _1  |-->_1 for (name self)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying atom rule _1  |-->_1 for (atom (name self))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self
>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>>>> Applying trailer rule . _1  |-->._1 for (trailer . (name Age))
>***> Metafeatures of rule . _1  |-->._1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: ._1

>--> Replacing _1 by Age
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Age))

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name self)) (trailer . (name Age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name self))

||| Condition _1 atom is satisfied by (atom (name self))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name self)) (trailer . (name Age)))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by self
>--> Replacing _* by .Age
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name self)) (trailer . (name Age))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by self.Age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset colonAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))


>>>> Applying testlist rule _*  |-->false for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _*  |-->false are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: false

>--> Replacing _* by self.Age
>***> Applying ruleset equalAssign to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->    _1 := _1_2<when> _2 assign_part for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>>> Applying small_stmt rule return _1  |-->    return _1 for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule return _1  |-->    return _1 are []
>***> LHS tokens: [return, _1]

>***> RHS after replacement of metafeatures:     return _1

>--> Replacing _1 by self.Age
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     return self.Age
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     return self.Age
>>>> Applying suite rule _1 _*  |-->_1_*`followingStatement for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>***> Metafeatures of rule _1 _*  |-->_1_*`followingStatement are [_*`followingStatement]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature followingStatement to [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))] : java.util.Vector

>***> Applying followingStatement to vector of terms [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))]

>***> Valid ruleset followingStatement

>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     return self.Age
>--> Replacing metafeature _*`followingStatement by  ;
    return self.Age
>> Applied vector rule: _1 ;
    return self.Age
>***> RHS after replacement of metafeatures: _1 ;
    return self.Age

>--> Replacing _1 by     self.Age := self.Age + 1
>--> Replacing _* by     return self.Age
>>> found metafeature _3`hasValueReturn for _3`
*** Metafeatures of _3`hasValueReturn are: [_3`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))


*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->false<when> _2 assign_part for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>>> found metafeature _1`hasValueReturn for _1`
*** Metafeatures of _1`hasValueReturn are: [_1`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Age
>--> Replacing _2 by  + 1
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := self.Age + 1
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := self.Age + 1
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

>!!> Conditions failed of rule _1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>>>> Applying suite rule _1 _*  |-->_*`recurse<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>***> Metafeatures of rule _1 _*  |-->_*`recurse<when> _1 stmt are [_*`recurse]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature recurse to [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))]

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (hasValueReturn (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>>>> Applying hasValueReturn rule _1  |-->_1`hasValueReturn<when> _1 stmt for (hasValueReturn (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>***> Valid ruleset hasValueReturn

>>>> Applying small_stmt rule return _1  |-->true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule return _1  |-->true are []
>***> LHS tokens: [return, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>--> Replacing metafeature _*`recurse by true
>> Applied vector rule: true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     self.Age := self.Age + 1
>--> Replacing _* by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))

||| ASTTerm condition _3`hasValueReturn true satisfied by term (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))

||| Condition _3`hasValueReturn true is satisfied by (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>>>> Applying funcdef rule def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true for (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))
>***> Metafeatures of rule def _1 ( _2 ) : _3  |-->  operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_2`defaultParamSettings_3;\n\n<when> _3`hasValueReturn true are [_2`defaultParamSettings]
>***> LHS tokens: [def, _1, (, _2, ), :, _3]


>***> Applying metafeature defaultParamSettings to (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) : ASTCompositeTerm

>***> Applying defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))

>***> Valid ruleset defaultParamSettings

>>>> Applying typedargslist rule _1  |-->_1`defaultParamCode for (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))
>***> Metafeatures of rule _1  |-->_1`defaultParamCode are [_1`defaultParamCode]
>***> LHS tokens: [_1]


>***> Applying metafeature defaultParamCode to (def_parameters (def_parameter (named_parameter (name self)))) : ASTCompositeTerm

>***> Applying defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))))

>***> Valid ruleset defaultParamCode

>>>> Applying def_parameters rule _1  |-->_1`paramDefaultCode for (def_parameters (def_parameter (named_parameter (name self))))
>***> Metafeatures of rule _1  |-->_1`paramDefaultCode are [_1`paramDefaultCode]
>***> LHS tokens: [_1]


>***> Applying metafeature paramDefaultCode to (def_parameter (named_parameter (name self))) : ASTCompositeTerm

>***> Applying paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>***> Valid ruleset paramDefaultCode

>>>> Applying def_parameter rule _1  |--> for (def_parameter (named_parameter (name self)))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>***> Applying ruleset paramDefaultCode to ASTTerm (def_parameter (named_parameter (name self)))

>--> Replacing metafeature _1`paramDefaultCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>***> Applying ruleset defaultParamCode to ASTTerm (def_parameters (def_parameter (named_parameter (name self))))

>--> Replacing metafeature _1`defaultParamCode by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by self : OclAny
>***> Applying ruleset defaultParamSettings to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))

>--> Replacing metafeature _2`defaultParamSettings by 
>***> RHS after replacement of metafeatures:   operation _1(_2) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n

>--> Replacing _1 by Birthday_F
>--> Replacing _2 by self : OclAny
>--> Replacing _3 by     self.Age := self.Age + 1 ;
    return self.Age
>>>> Applying compound_stmt rule _1  |-->    skip for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
>***> Metafeatures of rule _1  |-->    skip are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:     skip

>--> Replacing _1 by   operation Birthday_F(self : OclAny) : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>>>> Applying stmt rule _1  |-->_1 for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     skip
>>>> Applying suite rule _1 _*  |-->_1_*`followingStatement for (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))
>***> Metafeatures of rule _1 _*  |-->_1_*`followingStatement are [_*`followingStatement]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature followingStatement to [(stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))), (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))] : java.util.Vector

>***> Applying followingStatement to vector of terms [(stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))), (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))]

>***> Valid ruleset followingStatement

>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     skip
>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     skip
>--> Replacing metafeature _*`followingStatement by  ;
    skip ;
    skip
>> Applied vector rule: _1 ;
    skip ;
    skip
>***> RHS after replacement of metafeatures: _1 ;
    skip ;
    skip

>--> Replacing _1 by     skip
>--> Replacing _* by     skip    skip
>>>> Applying classdef rule class _1 : _2  |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1 for (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))
>***> Metafeatures of rule class _1 : _2  |-->class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n_2`classcontent}\n\n<action> _1 Class, _$ _1 are [_2`classcontent]
>***> LHS tokens: [class, _1, :, _2]

>>>--- Global variable _$ has value null

>--> Replacing global variable _$ by 
*** Student metafeature values set to [Class]
>>>--- Global variable _$ has value null

>--> Replacing global variable _$ by 
>>>--- Global variable _$ set to Student


>***> Applying metafeature classcontent to (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))) : ASTCompositeTerm

>***> Applying classcontent to ASTTerm (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))

||| Condition _1 stmt is satisfied by (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
>>>> Applying suite rule _1 _*  |-->_1`classcontent_*`classcontent<when> _1 stmt for (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))
>***> Metafeatures of rule _1 _*  |-->_1`classcontent_*`classcontent<when> _1 stmt are [_*`classcontent, _1`classcontent]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature classcontent to [(stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))), (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))] : java.util.Vector

>***> Applying classcontent to vector of terms [(stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))), (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))]

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
>>>> Applying stmt rule _1  |-->_1`classcontent<when> _1 compound_stmt for (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))))
>***> Metafeatures of rule _1  |-->_1`classcontent<when> _1 compound_stmt are [_1`classcontent]
>***> LHS tokens: [_1]


>***> Applying metafeature classcontent to (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))) : ASTCompositeTerm

>***> Applying classcontent to ASTTerm (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 compound_stmt for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 funcdef satisfied by term (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))

||| Condition _1 funcdef is satisfied by (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))
>>>> Applying compound_stmt rule _1  |-->_1`methodDefinition<when> _1 funcdef for (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))
>***> Metafeatures of rule _1  |-->_1`methodDefinition<when> _1 funcdef are [_1`methodDefinition]
>***> LHS tokens: [_1]


>***> Applying metafeature methodDefinition to (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))) : ASTCompositeTerm

>***> Applying methodDefinition to ASTTerm (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))

>***> Valid ruleset methodDefinition

>>>> Applying basic term name rule _1  |-->_1 for (name Degree_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree_F
>>> found metafeature _3`hasValueReturn for _3`
*** Metafeatures of _3`hasValueReturn are: [_3`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
>>>> Applying suite rule _1  |-->_1`hasValueReturn<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Degree
>--> Replacing _2 by  + n
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Degree := self.Degree + n
>***> Applying ruleset hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))

>!!> Conditions failed of rule def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true for (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))
>>>> Applying basic term name rule _1  |-->_1 for (name Degree_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree_F
>>>> Applying funcdef rule def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n for (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))
>***> Metafeatures of rule def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail)\n  pre: true post: true\n  activity:\n_3;\n\n are [_2`parametersTail]
>***> LHS tokens: [def, _1, (, _2, ), :, _3]


>***> Applying metafeature parametersTail to (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) : ASTCompositeTerm

>***> Applying parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))

>***> Valid ruleset parametersTail

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 def_parameters satisfied by term (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))

||| Condition _1 def_parameters is satisfied by (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))
>>>> Applying typedargslist rule _1  |-->_1`parametersTail<when> _1 def_parameters for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))
>***> Metafeatures of rule _1  |-->_1`parametersTail<when> _1 def_parameters are [_1`parametersTail]
>***> LHS tokens: [_1]


>***> Applying metafeature parametersTail to (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))) : ASTCompositeTerm

>***> Applying parametersTail to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))

>***> Valid ruleset parametersTail

>>>> Applying def_parameters rule self , _*  |-->_* for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))
>***> Metafeatures of rule self , _*  |-->_* are []
>***> LHS tokens: [self, ,, _*]

>***> RHS after replacement of metafeatures: _*

>--> Replacing _* by n : OclAny
>***> Applying ruleset parametersTail to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))

>--> Replacing metafeature _1`parametersTail by n : OclAny
>***> RHS after replacement of metafeatures: n : OclAny

>--> Replacing _1 by self : OclAny, n : OclAny
>***> Applying ruleset parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n)))))

>--> Replacing metafeature _2`parametersTail by n : OclAny
>***> RHS after replacement of metafeatures: \n  operation _1(n : OclAny)\n  pre: true post: true\n  activity:\n_3;\n\n

>--> Replacing _1 by Degree_F
>--> Replacing _2 by self : OclAny, n : OclAny
>--> Replacing _3 by     self.Degree := self.Degree + n
>***> Applying ruleset methodDefinition to ASTTerm (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n)))))))))))))

>--> Replacing metafeature _1`methodDefinition by 
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


>***> RHS after replacement of metafeatures: 
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;



>--> Replacing _1 by   operation Degree_F(self : OclAny, n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


>***> Applying ruleset classcontent to ASTTerm (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))

>--> Replacing metafeature _1`classcontent by 
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


>***> RHS after replacement of metafeatures: 
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;



>--> Replacing _1 by     skip
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
>>>> Applying stmt rule _1  |-->_1`classcontent<when> _1 compound_stmt for (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))
>***> Metafeatures of rule _1  |-->_1`classcontent<when> _1 compound_stmt are [_1`classcontent]
>***> LHS tokens: [_1]


>***> Applying metafeature classcontent to (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))) : ASTCompositeTerm

>***> Applying classcontent to ASTTerm (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 compound_stmt for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 funcdef satisfied by term (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))

||| Condition _1 funcdef is satisfied by (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))
>>>> Applying compound_stmt rule _1  |-->_1`methodDefinition<when> _1 funcdef for (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))
>***> Metafeatures of rule _1  |-->_1`methodDefinition<when> _1 funcdef are [_1`methodDefinition]
>***> LHS tokens: [_1]


>***> Applying metafeature methodDefinition to (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))) : ASTCompositeTerm

>***> Applying methodDefinition to ASTTerm (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))

>***> Valid ruleset methodDefinition

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>> found metafeature _3`hasValueReturn for _3`
*** Metafeatures of _3`hasValueReturn are: [_3`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))


*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->false<when> _2 assign_part for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>>> found metafeature _1`hasValueReturn for _1`
*** Metafeatures of _1`hasValueReturn are: [_1`hasValueReturn]
>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))

||| Condition _2 assign_part is satisfied by (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))
>>>> Applying small_stmt rule _1 _2  |-->false<when> _2 assign_part for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))
>***> Metafeatures of rule _1 _2  |-->false<when> _2 assign_part are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by self.Age
>--> Replacing _2 by  + 1
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := self.Age + 1
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))

>--> Replacing metafeature _1`hasValueReturn by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by     self.Age := self.Age + 1
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

>!!> Conditions failed of rule _1 _*  |-->true<when> _1 stmt, _1`hasValueReturn true for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1))))))))))))
>>>> Applying suite rule _1 _*  |-->_*`recurse<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>***> Metafeatures of rule _1 _*  |-->_*`recurse<when> _1 stmt are [_*`recurse]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature recurse to [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))]

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (hasValueReturn (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>>>> Applying hasValueReturn rule _1  |-->_1`hasValueReturn<when> _1 stmt for (hasValueReturn (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
>>>> Applying stmt rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 simple_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

>***> Valid ruleset hasValueReturn

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->false<when> _1 testlist_star_expr for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasValueReturn<when> _1 stmt for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>>> Applying simple_stmt rule _1  |-->_1`hasValueReturn<when> _1 small_stmt for (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))
>***> Metafeatures of rule _1  |-->_1`hasValueReturn<when> _1 small_stmt are [_1`hasValueReturn]
>***> LHS tokens: [_1]


>***> Applying metafeature hasValueReturn to (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) : ASTCompositeTerm

>***> Applying hasValueReturn to ASTTerm (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>***> Valid ruleset hasValueReturn

>>>> Applying small_stmt rule return _1  |-->true for (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule return _1  |-->true are []
>***> LHS tokens: [return, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))

>--> Replacing metafeature _1`hasValueReturn by true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     return self.Age
>--> Replacing metafeature _*`recurse by true
>> Applied vector rule: true
>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by     self.Age := self.Age + 1
>--> Replacing _* by     return self.Age
>***> Applying ruleset hasValueReturn to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))

||| ASTTerm condition _3`hasValueReturn true satisfied by term (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))

||| Condition _3`hasValueReturn true is satisfied by (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))
>>>> Applying funcdef rule def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true for (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))
>***> Metafeatures of rule def _1 ( _2 ) : _3  |-->\n  operation _1(_2`parametersTail) : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n<when> _3`hasValueReturn true are [_2`parametersTail]
>***> LHS tokens: [def, _1, (, _2, ), :, _3]


>***> Applying metafeature parametersTail to (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) : ASTCompositeTerm

>***> Applying parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))

>***> Valid ruleset parametersTail

>>>> Applying typedargslist rule self  |--> for (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))
>***> Metafeatures of rule self  |--> are []
>***> LHS tokens: [self]

>***> RHS after replacement of metafeatures: 

>***> Applying ruleset parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self)))))

>--> Replacing metafeature _2`parametersTail by 
>***> RHS after replacement of metafeatures: \n  operation _1() : OclAny\n  pre: true post: true\n  activity:\n_3;\n\n

>--> Replacing _1 by Birthday_F
>--> Replacing _2 by self : OclAny
>--> Replacing _3 by     self.Age := self.Age + 1 ;
    return self.Age
>***> Applying ruleset methodDefinition to ASTTerm (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))

>--> Replacing metafeature _1`methodDefinition by 
  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>***> RHS after replacement of metafeatures: 
  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;



>--> Replacing _1 by   operation Birthday_F(self : OclAny) : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>***> Applying ruleset classcontent to ASTTerm (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))

>--> Replacing metafeature _1`classcontent by 
  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>***> RHS after replacement of metafeatures: 
  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;



>--> Replacing _1 by     skip
>--> Replacing metafeature _*`classcontent by 
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>> Applied vector rule: _1`classcontent
  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;



>***> Applying metafeature classcontent to (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) : ASTCompositeTerm

>***> Applying classcontent to ASTTerm (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
>>>> Applying stmt rule _1  |-->_1`classcontent<when> _1 compound_stmt for (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))
>***> Metafeatures of rule _1  |-->_1`classcontent<when> _1 compound_stmt are [_1`classcontent]
>***> LHS tokens: [_1]


>***> Applying metafeature classcontent to (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))) : ASTCompositeTerm

>***> Applying classcontent to ASTTerm (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))

>***> Valid ruleset classcontent

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 stmt for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 simple_stmt for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 small_stmt for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classcontent<when> _1 compound_stmt for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 funcdef satisfied by term (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))

||| Condition _1 funcdef is satisfied by (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))
>>>> Applying compound_stmt rule _1  |-->_1`methodDefinition<when> _1 funcdef for (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))
>***> Metafeatures of rule _1  |-->_1`methodDefinition<when> _1 funcdef are [_1`methodDefinition]
>***> LHS tokens: [_1]


>***> Applying metafeature methodDefinition to (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))) : ASTCompositeTerm

>***> Applying methodDefinition to ASTTerm (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))

>***> Valid ruleset methodDefinition

>>>> Applying funcdef rule def __init__ ( _1 ) : _2  |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n for (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))
>***> Metafeatures of rule def __init__ ( _1 ) : _2  |-->_2`attributeDefinitions\n  operation initialise(_1`parametersTail) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n are [_1`parametersTail, _2`attributeDefinitions]
>***> LHS tokens: [def, __init__, (, _1, ), :, _2]


>***> Applying metafeature parametersTail to (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) : ASTCompositeTerm

>***> Applying parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))

>***> Valid ruleset parametersTail

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 def_parameters satisfied by term (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))

||| Condition _1 def_parameters is satisfied by (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>>>> Applying typedargslist rule _1  |-->_1`parametersTail<when> _1 def_parameters for (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))
>***> Metafeatures of rule _1  |-->_1`parametersTail<when> _1 def_parameters are [_1`parametersTail]
>***> LHS tokens: [_1]


>***> Applying metafeature parametersTail to (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))) : ASTCompositeTerm

>***> Applying parametersTail to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))

>***> Valid ruleset parametersTail

>>>> Applying def_parameters rule self , _*  |-->_* for (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))
>***> Metafeatures of rule self , _*  |-->_* are []
>***> LHS tokens: [self, ,, _*]

>***> RHS after replacement of metafeatures: _*

>--> Replacing _* by name : OclAny,num : OclAny,age : OclAny,degree : OclAny
>***> Applying ruleset parametersTail to ASTTerm (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))

>--> Replacing metafeature _1`parametersTail by name : OclAny,num : OclAny,age : OclAny,degree : OclAny
>***> RHS after replacement of metafeatures: name : OclAny,num : OclAny,age : OclAny,degree : OclAny

>--> Replacing _1 by self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>***> Applying ruleset parametersTail to ASTTerm (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree)))))

>--> Replacing metafeature _1`parametersTail by name : OclAny,num : OclAny,age : OclAny,degree : OclAny

>***> Applying metafeature attributeDefinitions to (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 stmt satisfied by term (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

||| Condition _1 stmt is satisfied by (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>>>> Applying suite rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt for (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))
>***> Metafeatures of rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt are [_*`attributeDefinitions, _1`attributeDefinitions]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature attributeDefinitions to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))] : java.util.Vector

>***> Applying attributeDefinitions to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))]

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
>>>> Applying stmt rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches self.* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))

||| Condition _1 matches self.* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))
>>>> Applying small_stmt rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))
>***> Metafeatures of rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* are [_1`removeSelf, _2`ocltype]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature removeSelf to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 testlist are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))
>>>> Applying testlist rule _1  |-->_1`removeSelf<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
>>>> Applying test rule _1  |-->_1`removeSelf<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 logical_test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name self)) (trailer . (name Num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name self)) (trailer . (name Num))))
>>>> Applying logical_test rule _1  |-->_1`removeSelf<when> _1 comparison for (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 comparison are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (comparison (expr (atom (name self)) (trailer . (name Num)))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Num))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (comparison (expr (atom (name self)) (trailer . (name Num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (comparison (expr (atom (name self)) (trailer . (name Num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (comparison (expr (atom (name self)) (trailer . (name Num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 comparison for (comparison (expr (atom (name self)) (trailer . (name Num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name self)) (trailer . (name Num)))

||| Condition _1 expr is satisfied by (expr (atom (name self)) (trailer . (name Num)))
>>>> Applying comparison rule _1  |-->_1`removeSelf<when> _1 expr for (comparison (expr (atom (name self)) (trailer . (name Num))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 expr are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (expr (atom (name self)) (trailer . (name Num))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Num)))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 trailer satisfied by term (trailer . (name Num))

||| Condition _1 trailer is satisfied by (trailer . (name Num))
>>>> Applying expr rule self _1  |-->_1`removeSelf<when> _1 trailer for (expr (atom (name self)) (trailer . (name Num)))
>***> Metafeatures of rule self _1  |-->_1`removeSelf<when> _1 trailer are [_1`removeSelf]
>***> LHS tokens: [self, _1]


>***> Applying metafeature removeSelf to (trailer . (name Num)) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (trailer . (name Num))

>***> Valid ruleset removeSelf

>>>> Applying basic term name rule _1  |-->_1 for (name Num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>>>> Applying trailer rule . _1  |-->_1 for (trailer . (name Num))
>***> Metafeatures of rule . _1  |-->_1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Num
>***> Applying ruleset removeSelf to ASTTerm (trailer . (name Num))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by .Num
>***> Applying ruleset removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Num)))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by self.Num
>***> Applying ruleset removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Num))))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by self.Num
>***> Applying ruleset removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by self.Num
>***> Applying ruleset removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by self.Num
>***> Applying ruleset removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))

>--> Replacing metafeature _1`removeSelf by Num
>***> RHS after replacement of metafeatures: Num

>--> Replacing _1 by self.Num
>***> Applying ruleset removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num))))))))

>--> Replacing metafeature _1`removeSelf by Num

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name num)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name num))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name num))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name num)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name num)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name num))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name num))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name num)))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isMapExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 atom are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (atom (name num))

>***> Valid ruleset isMapExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name num))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name num)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name num)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name num))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name num))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name num))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name num)))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name num)))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name num))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name num))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name num)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name num)))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name num))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name num))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name num)))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name num))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name num)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name num))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name num))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name num)))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name num)))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name num))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name num))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name num)))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name num)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name num))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name num)))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name num))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name num)))

||| Condition _1 expr is satisfied by (expr (atom (name num)))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name num))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name num))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name num)))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (expr (atom (name num)))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (atom (name num))


>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>>> Applying atom rule _1  |-->false for (atom (name num))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name num))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (expr (atom (name num)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (expr (atom (name num)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name num))

||| Condition _1 atom is satisfied by (atom (name num))
>>>> Applying expr rule _1  |-->_1`ocltype<when> _1 atom for (expr (atom (name num)))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 atom are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (atom (name num)) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (atom (name num))

>***> Valid ruleset ocltype

>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (name num)


*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->false for (name num)
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by num
>***> Applying ruleset isSequenceExpression to ASTTerm (name num)

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 atom for (atom (name num))
>>>> Applying basic term name rule _1  |-->_1 for (name num)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by num
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 name satisfied by term (name num)

||| Condition _1 name is satisfied by (name num)
>>>> Applying atom rule _1  |-->_1`ocltype<when> _1 name for (atom (name num))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 name are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (name num) : ASTBasicTerm

>***> Applying ocltype to ASTTerm (name num)

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm num


>>> cgRules for num [_1  |-->_1`isSequenceExpression<when> _1 testlist, _1  |-->_1`isSequenceExpression<when> _1 test, _1  |-->_1`isSequenceExpression<when> _1 logical_test, _1  |-->_1`isSequenceExpression<when> _1 comparison, _1  |-->_1`isSequenceExpression<when> _1 expr, _1  |-->_1`isSequenceExpression<when> _1 atom, print _1  |-->false, del _1  |-->false, dict _1  |-->false, range _1  |-->true, ( )  |-->false, ( _1 )  |-->false<when> _1 multiple, ( _1 )  |-->_1`isSequenceExpression, [ ]  |-->true, [ _1 ]  |-->true, { _1 }  |-->false, ` _1 `  |-->false, - _1  |-->false, None  |-->false, ...  |-->false, _1 + _2  |-->_1`isSequenceExpression, _1 _2  |-->false<when> _1 atom, _2 trailer, _1 , _*  |-->false, _1  |-->true<when> _1 Sequence, _1  |-->false]
> Rule _1  |-->_1`isSequenceExpression<when> _1 testlist has tokens [_1] variables [_1]
>***> Applying ruleset isSequenceExpression to ASTTerm num

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->OclAny for (name num)
>***> Metafeatures of rule _1  |-->OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (name num)

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (atom (name num))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name num)))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name num))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name num)))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name num))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name num)))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by num
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))

>--> Replacing metafeature _2`ocltype by OclAny
>***> RHS after replacement of metafeatures:   attribute Num : OclAny;\n

>--> Replacing _1 by self.Num
>--> Replacing _2 by := num
>***> Applying ruleset attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Num : OclAny;

>***> RHS after replacement of metafeatures:   attribute Num : OclAny;


>--> Replacing _1 by     self.Num := num
>***> Applying ruleset attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Num : OclAny;

>***> RHS after replacement of metafeatures:   attribute Num : OclAny;


>--> Replacing _1 by     self.Num := num
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
>>>> Applying stmt rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches self.* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

||| Condition _1 matches self.* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>>>> Applying small_stmt rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))
>***> Metafeatures of rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* are [_1`removeSelf, _2`ocltype]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature removeSelf to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 testlist are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
>>>> Applying testlist rule _1  |-->_1`removeSelf<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
>>>> Applying test rule _1  |-->_1`removeSelf<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 logical_test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name self)) (trailer . (name Age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name self)) (trailer . (name Age))))
>>>> Applying logical_test rule _1  |-->_1`removeSelf<when> _1 comparison for (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 comparison are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (comparison (expr (atom (name self)) (trailer . (name Age)))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Age))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (comparison (expr (atom (name self)) (trailer . (name Age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (comparison (expr (atom (name self)) (trailer . (name Age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (comparison (expr (atom (name self)) (trailer . (name Age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 comparison for (comparison (expr (atom (name self)) (trailer . (name Age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name self)) (trailer . (name Age)))

||| Condition _1 expr is satisfied by (expr (atom (name self)) (trailer . (name Age)))
>>>> Applying comparison rule _1  |-->_1`removeSelf<when> _1 expr for (comparison (expr (atom (name self)) (trailer . (name Age))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 expr are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (expr (atom (name self)) (trailer . (name Age))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Age)))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 trailer satisfied by term (trailer . (name Age))

||| Condition _1 trailer is satisfied by (trailer . (name Age))
>>>> Applying expr rule self _1  |-->_1`removeSelf<when> _1 trailer for (expr (atom (name self)) (trailer . (name Age)))
>***> Metafeatures of rule self _1  |-->_1`removeSelf<when> _1 trailer are [_1`removeSelf]
>***> LHS tokens: [self, _1]


>***> Applying metafeature removeSelf to (trailer . (name Age)) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (trailer . (name Age))

>***> Valid ruleset removeSelf

>>>> Applying basic term name rule _1  |-->_1 for (name Age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>>>> Applying trailer rule . _1  |-->_1 for (trailer . (name Age))
>***> Metafeatures of rule . _1  |-->_1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Age
>***> Applying ruleset removeSelf to ASTTerm (trailer . (name Age))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by .Age
>***> Applying ruleset removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Age)))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by self.Age
>***> Applying ruleset removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Age))))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by self.Age
>***> Applying ruleset removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by self.Age
>***> Applying ruleset removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by self.Age
>***> Applying ruleset removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))

>--> Replacing metafeature _1`removeSelf by Age
>***> RHS after replacement of metafeatures: Age

>--> Replacing _1 by self.Age
>***> Applying ruleset removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))

>--> Replacing metafeature _1`removeSelf by Age

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name age)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name age))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name age))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name age)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name age)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name age))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name age))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name age)))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isMapExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 atom are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (atom (name age))

>***> Valid ruleset isMapExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name age))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name age)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name age)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name age))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name age))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name age))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name age)))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name age)))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name age))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name age))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name age)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name age)))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name age))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name age))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name age)))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name age))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name age)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name age))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name age))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name age)))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name age)))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name age))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name age))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name age)))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name age)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name age))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name age)))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name age))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name age)))

||| Condition _1 expr is satisfied by (expr (atom (name age)))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name age))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name age))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name age)))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (expr (atom (name age)))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (atom (name age))


>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>>> Applying atom rule _1  |-->false for (atom (name age))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name age))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (expr (atom (name age)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (expr (atom (name age)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name age))

||| Condition _1 atom is satisfied by (atom (name age))
>>>> Applying expr rule _1  |-->_1`ocltype<when> _1 atom for (expr (atom (name age)))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 atom are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (atom (name age)) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (atom (name age))

>***> Valid ruleset ocltype

>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (name age)


*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->false for (name age)
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by age
>***> Applying ruleset isSequenceExpression to ASTTerm (name age)

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 atom for (atom (name age))
>>>> Applying basic term name rule _1  |-->_1 for (name age)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by age
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 name satisfied by term (name age)

||| Condition _1 name is satisfied by (name age)
>>>> Applying atom rule _1  |-->_1`ocltype<when> _1 name for (atom (name age))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 name are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (name age) : ASTBasicTerm

>***> Applying ocltype to ASTTerm (name age)

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm age


>>> cgRules for age [_1  |-->_1`isSequenceExpression<when> _1 testlist, _1  |-->_1`isSequenceExpression<when> _1 test, _1  |-->_1`isSequenceExpression<when> _1 logical_test, _1  |-->_1`isSequenceExpression<when> _1 comparison, _1  |-->_1`isSequenceExpression<when> _1 expr, _1  |-->_1`isSequenceExpression<when> _1 atom, print _1  |-->false, del _1  |-->false, dict _1  |-->false, range _1  |-->true, ( )  |-->false, ( _1 )  |-->false<when> _1 multiple, ( _1 )  |-->_1`isSequenceExpression, [ ]  |-->true, [ _1 ]  |-->true, { _1 }  |-->false, ` _1 `  |-->false, - _1  |-->false, None  |-->false, ...  |-->false, _1 + _2  |-->_1`isSequenceExpression, _1 _2  |-->false<when> _1 atom, _2 trailer, _1 , _*  |-->false, _1  |-->true<when> _1 Sequence, _1  |-->false]
> Rule _1  |-->_1`isSequenceExpression<when> _1 testlist has tokens [_1] variables [_1]
>***> Applying ruleset isSequenceExpression to ASTTerm age

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->OclAny for (name age)
>***> Metafeatures of rule _1  |-->OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (name age)

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (atom (name age))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name age)))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name age))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name age)))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name age))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name age)))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by age
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))

>--> Replacing metafeature _2`ocltype by OclAny
>***> RHS after replacement of metafeatures:   attribute Age : OclAny;\n

>--> Replacing _1 by self.Age
>--> Replacing _2 by := age
>***> Applying ruleset attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Age : OclAny;

>***> RHS after replacement of metafeatures:   attribute Age : OclAny;


>--> Replacing _1 by     self.Age := age
>***> Applying ruleset attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Age : OclAny;

>***> RHS after replacement of metafeatures:   attribute Age : OclAny;


>--> Replacing _1 by     self.Age := age
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
>>>> Applying stmt rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches self.* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))

||| Condition _1 matches self.* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))
>>>> Applying small_stmt rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))
>***> Metafeatures of rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* are [_1`removeSelf, _2`ocltype]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature removeSelf to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 testlist are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
>>>> Applying testlist rule _1  |-->_1`removeSelf<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
>>>> Applying test rule _1  |-->_1`removeSelf<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 logical_test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name self)) (trailer . (name Degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name self)) (trailer . (name Degree))))
>>>> Applying logical_test rule _1  |-->_1`removeSelf<when> _1 comparison for (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 comparison are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (comparison (expr (atom (name self)) (trailer . (name Degree)))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Degree))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (comparison (expr (atom (name self)) (trailer . (name Degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (comparison (expr (atom (name self)) (trailer . (name Degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (comparison (expr (atom (name self)) (trailer . (name Degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 comparison for (comparison (expr (atom (name self)) (trailer . (name Degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name self)) (trailer . (name Degree)))

||| Condition _1 expr is satisfied by (expr (atom (name self)) (trailer . (name Degree)))
>>>> Applying comparison rule _1  |-->_1`removeSelf<when> _1 expr for (comparison (expr (atom (name self)) (trailer . (name Degree))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 expr are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (expr (atom (name self)) (trailer . (name Degree))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Degree)))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 trailer satisfied by term (trailer . (name Degree))

||| Condition _1 trailer is satisfied by (trailer . (name Degree))
>>>> Applying expr rule self _1  |-->_1`removeSelf<when> _1 trailer for (expr (atom (name self)) (trailer . (name Degree)))
>***> Metafeatures of rule self _1  |-->_1`removeSelf<when> _1 trailer are [_1`removeSelf]
>***> LHS tokens: [self, _1]


>***> Applying metafeature removeSelf to (trailer . (name Degree)) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (trailer . (name Degree))

>***> Valid ruleset removeSelf

>>>> Applying basic term name rule _1  |-->_1 for (name Degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>>>> Applying trailer rule . _1  |-->_1 for (trailer . (name Degree))
>***> Metafeatures of rule . _1  |-->_1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Degree
>***> Applying ruleset removeSelf to ASTTerm (trailer . (name Degree))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by .Degree
>***> Applying ruleset removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Degree)))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by self.Degree
>***> Applying ruleset removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Degree))))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by self.Degree
>***> Applying ruleset removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by self.Degree
>***> Applying ruleset removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by self.Degree
>***> Applying ruleset removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))

>--> Replacing metafeature _1`removeSelf by Degree
>***> RHS after replacement of metafeatures: Degree

>--> Replacing _1 by self.Degree
>***> Applying ruleset removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree))))))))

>--> Replacing metafeature _1`removeSelf by Degree

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name degree))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name degree))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name degree)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name degree))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name degree))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name degree)))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isMapExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 atom are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isMapExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name degree))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name degree)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name degree))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name degree))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name degree))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name degree)))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name degree)))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name degree))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name degree))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name degree)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name degree)))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name degree))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name degree))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name degree)))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name degree))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name degree)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name degree))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name degree))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name degree)))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name degree)))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name degree))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name degree))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name degree)))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name degree)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name degree))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name degree)))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name degree))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name degree)))

||| Condition _1 expr is satisfied by (expr (atom (name degree)))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name degree))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name degree))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name degree)))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (expr (atom (name degree)))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (atom (name degree))


>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>>> Applying atom rule _1  |-->false for (atom (name degree))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name degree))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (expr (atom (name degree)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name degree))

||| Condition _1 atom is satisfied by (atom (name degree))
>>>> Applying expr rule _1  |-->_1`ocltype<when> _1 atom for (expr (atom (name degree)))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 atom are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (atom (name degree)) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (atom (name degree))

>***> Valid ruleset ocltype

>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (name degree)


*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->false for (name degree)
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by degree
>***> Applying ruleset isSequenceExpression to ASTTerm (name degree)

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 atom for (atom (name degree))
>>>> Applying basic term name rule _1  |-->_1 for (name degree)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by degree
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 name satisfied by term (name degree)

||| Condition _1 name is satisfied by (name degree)
>>>> Applying atom rule _1  |-->_1`ocltype<when> _1 name for (atom (name degree))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 name are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (name degree) : ASTBasicTerm

>***> Applying ocltype to ASTTerm (name degree)

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm degree


>>> cgRules for degree [_1  |-->_1`isSequenceExpression<when> _1 testlist, _1  |-->_1`isSequenceExpression<when> _1 test, _1  |-->_1`isSequenceExpression<when> _1 logical_test, _1  |-->_1`isSequenceExpression<when> _1 comparison, _1  |-->_1`isSequenceExpression<when> _1 expr, _1  |-->_1`isSequenceExpression<when> _1 atom, print _1  |-->false, del _1  |-->false, dict _1  |-->false, range _1  |-->true, ( )  |-->false, ( _1 )  |-->false<when> _1 multiple, ( _1 )  |-->_1`isSequenceExpression, [ ]  |-->true, [ _1 ]  |-->true, { _1 }  |-->false, ` _1 `  |-->false, - _1  |-->false, None  |-->false, ...  |-->false, _1 + _2  |-->_1`isSequenceExpression, _1 _2  |-->false<when> _1 atom, _2 trailer, _1 , _*  |-->false, _1  |-->true<when> _1 Sequence, _1  |-->false]
> Rule _1  |-->_1`isSequenceExpression<when> _1 testlist has tokens [_1] variables [_1]
>***> Applying ruleset isSequenceExpression to ASTTerm degree

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->OclAny for (name degree)
>***> Metafeatures of rule _1  |-->OclAny are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (name degree)

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (atom (name degree))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name degree)))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name degree))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name degree)))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name degree))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name degree)))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by degree
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))

>--> Replacing metafeature _2`ocltype by OclAny
>***> RHS after replacement of metafeatures:   attribute Degree : OclAny;\n

>--> Replacing _1 by self.Degree
>--> Replacing _2 by := degree
>***> Applying ruleset attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Degree : OclAny;

>***> RHS after replacement of metafeatures:   attribute Degree : OclAny;


>--> Replacing _1 by     self.Degree := degree
>***> Applying ruleset attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Degree : OclAny;

>***> RHS after replacement of metafeatures:   attribute Degree : OclAny;


>--> Replacing _1 by     self.Degree := degree
>--> Replacing metafeature _*`attributeDefinitions by   attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

>> Applied vector rule: _1`attributeDefinitions  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;


>***> Applying metafeature attributeDefinitions to (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
>>>> Applying stmt rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`attributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))
>***> Metafeatures of rule _1  |-->_1`attributeDefinitions<when> _1 small_stmt are [_1`attributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature attributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))) : ASTCompositeTerm

>***> Applying attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

>***> Valid ruleset attributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`attributeDefinitions_*`attributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 assign_part satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

||| Condition _2 assign_part is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 matches self.* satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))

||| Condition _1 matches self.* is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))
>>>> Applying small_stmt rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))
>***> Metafeatures of rule _1 _2  |-->  attribute _1`removeSelf : _2`ocltype;\n<when> _2 assign_part, _1 matches self.* are [_1`removeSelf, _2`ocltype]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature removeSelf to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 testlist are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))
>>>> Applying testlist rule _1  |-->_1`removeSelf<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
>>>> Applying test rule _1  |-->_1`removeSelf<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 logical_test are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name self)) (trailer . (name Name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name self)) (trailer . (name Name))))
>>>> Applying logical_test rule _1  |-->_1`removeSelf<when> _1 comparison for (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 comparison are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (comparison (expr (atom (name self)) (trailer . (name Name)))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Name))))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 testlist for (comparison (expr (atom (name self)) (trailer . (name Name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 test for (comparison (expr (atom (name self)) (trailer . (name Name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 logical_test for (comparison (expr (atom (name self)) (trailer . (name Name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`removeSelf<when> _1 comparison for (comparison (expr (atom (name self)) (trailer . (name Name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name self)) (trailer . (name Name)))

||| Condition _1 expr is satisfied by (expr (atom (name self)) (trailer . (name Name)))
>>>> Applying comparison rule _1  |-->_1`removeSelf<when> _1 expr for (comparison (expr (atom (name self)) (trailer . (name Name))))
>***> Metafeatures of rule _1  |-->_1`removeSelf<when> _1 expr are [_1`removeSelf]
>***> LHS tokens: [_1]


>***> Applying metafeature removeSelf to (expr (atom (name self)) (trailer . (name Name))) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Name)))

>***> Valid ruleset removeSelf

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 trailer satisfied by term (trailer . (name Name))

||| Condition _1 trailer is satisfied by (trailer . (name Name))
>>>> Applying expr rule self _1  |-->_1`removeSelf<when> _1 trailer for (expr (atom (name self)) (trailer . (name Name)))
>***> Metafeatures of rule self _1  |-->_1`removeSelf<when> _1 trailer are [_1`removeSelf]
>***> LHS tokens: [self, _1]


>***> Applying metafeature removeSelf to (trailer . (name Name)) : ASTCompositeTerm

>***> Applying removeSelf to ASTTerm (trailer . (name Name))

>***> Valid ruleset removeSelf

>>>> Applying basic term name rule _1  |-->_1 for (name Name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>>>> Applying trailer rule . _1  |-->_1 for (trailer . (name Name))
>***> Metafeatures of rule . _1  |-->_1 are []
>***> LHS tokens: [., _1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Name
>***> Applying ruleset removeSelf to ASTTerm (trailer . (name Name))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by .Name
>***> Applying ruleset removeSelf to ASTTerm (expr (atom (name self)) (trailer . (name Name)))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by self.Name
>***> Applying ruleset removeSelf to ASTTerm (comparison (expr (atom (name self)) (trailer . (name Name))))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by self.Name
>***> Applying ruleset removeSelf to ASTTerm (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by self.Name
>***> Applying ruleset removeSelf to ASTTerm (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by self.Name
>***> Applying ruleset removeSelf to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))

>--> Replacing metafeature _1`removeSelf by Name
>***> RHS after replacement of metafeatures: Name

>--> Replacing _1 by self.Name
>***> Applying ruleset removeSelf to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name))))))))

>--> Replacing metafeature _1`removeSelf by Name

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name name)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name name))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name name))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name name)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name name)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name name))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name name))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name name)))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isMapExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 atom are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (atom (name name))

>***> Valid ruleset isMapExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name name))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name name)))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name name)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name name))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name name))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name name))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name name)))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name name)))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name name))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name name))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name name)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name name)))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name name))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name name))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name name)))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name name))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name name)))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name name))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name name))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name name)))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name name)))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name name))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name name))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name name)))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`isSequenceExpression<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 atom are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (atom (name name)) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (atom (name name))

>***> Valid ruleset isSequenceExpression

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name name)))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name name))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name name)))

||| Condition _1 expr is satisfied by (expr (atom (name name)))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name name))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name name))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name name)))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (expr (atom (name name)))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (atom (name name))


>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->true<when> _1 Sequence for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>>> Applying atom rule _1  |-->false for (atom (name name))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (atom (name name))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (expr (atom (name name)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (expr (atom (name name)))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name name))

||| Condition _1 atom is satisfied by (atom (name name))
>>>> Applying expr rule _1  |-->_1`ocltype<when> _1 atom for (expr (atom (name name)))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 atom are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (atom (name name)) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (atom (name name))

>***> Valid ruleset ocltype

>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (name name)


*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>>> Applying basic term name rule _1  |-->false for (name name)
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by name
>***> Applying ruleset isSequenceExpression to ASTTerm (name name)

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 expr for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 atom for (atom (name name))
>>>> Applying basic term name rule _1  |-->_1 for (name name)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by name
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 name satisfied by term (name name)

||| Condition _1 name is satisfied by (name name)
>>>> Applying atom rule _1  |-->_1`ocltype<when> _1 name for (atom (name name))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 name are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (name name) : ASTBasicTerm

>***> Applying ocltype to ASTTerm (name name)

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm name


>>> cgRules for name [_1  |-->_1`isSequenceExpression<when> _1 testlist, _1  |-->_1`isSequenceExpression<when> _1 test, _1  |-->_1`isSequenceExpression<when> _1 logical_test, _1  |-->_1`isSequenceExpression<when> _1 comparison, _1  |-->_1`isSequenceExpression<when> _1 expr, _1  |-->_1`isSequenceExpression<when> _1 atom, print _1  |-->false, del _1  |-->false, dict _1  |-->false, range _1  |-->true, ( )  |-->false, ( _1 )  |-->false<when> _1 multiple, ( _1 )  |-->_1`isSequenceExpression, [ ]  |-->true, [ _1 ]  |-->true, { _1 }  |-->false, ` _1 `  |-->false, - _1  |-->false, None  |-->false, ...  |-->false, _1 + _2  |-->_1`isSequenceExpression, _1 _2  |-->false<when> _1 atom, _2 trailer, _1 , _*  |-->false, _1  |-->true<when> _1 Sequence, _1  |-->false]
> Rule _1  |-->_1`isSequenceExpression<when> _1 testlist has tokens [_1] variables [_1]
>***> Applying ruleset isSequenceExpression to ASTTerm name

*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 name satisfied by term name

||| Condition _1 name is satisfied by name
>>>> Applying basic term name rule _1  |-->_1`ocltype<when> _1 name for (name name)
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 name are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to name : ASTSymbolTerm

>***> Applying ocltype to ASTTerm name

>***> Valid ruleset ocltype

>>> cgRules for name [= _1  |-->String<when> _1 String, = _1  |-->int<when> _1 int, = _1  |-->double<when> _1 real, = _1  |-->Sequence<when> _1`isSequenceExpression true, = _1  |-->Map<when> _1`isMapExpression true, = _1  |-->_1`ocltype, True  |-->boolean, False  |-->boolean, inf  |-->double, Infinity  |-->double, nan  |-->double, int  |-->int, float  |-->double, str  |-->String, dict  |-->Map, list  |-->Sequence, deque  |-->Sequence, set  |-->Set, tuple  |-->Sequence, bool  |-->boolean, callable _1  |-->boolean, bool _1  |-->boolean, abs _1  |-->double, all _1  |-->boolean, dict _1  |-->Map, globals _1  |-->Map, hex _1  |-->String, id _1  |-->int, any _1  |-->boolean, ascii _1  |-->String, filter _1  |-->Sequence, frozenset _1  |-->Set, hash _1  |-->int, input _1  |-->String, isinstance _1  |-->boolean, issubclass _1  |-->boolean, hasattr _1  |-->boolean, len _1  |-->int, list _1  |-->Sequence, deque _1  |-->Sequence, map _1  |-->Sequence, set _1  |-->Set, sorted _1  |-->Sequence, tuple _1  |-->Sequence, pow _1  |-->double, repr _1  |-->String, reversed _1  |-->Sequence, round _1  |-->double, print _1  |-->void, int _1  |-->int, float _1  |-->double, str _1  |-->String, format _1  |-->String, chr _1  |-->String, unichr _1  |-->String, ord _1  |-->int, type _1  |-->OclType, range _1  |-->Sequence, enumerate _1  |-->Sequence, zip _1  |-->Sequence, slice _1  |-->Sequence, open _1  |-->OclFile, asyncio _1  |-->OclProcess, collections _1  |-->_1`collectionsType, math _1  |-->_1`mathType, re _1  |-->_1`reType, np _1  |-->_1`numpyType, np _1 _2  |-->_2`npRandomType<when> _1 matches .random, numpy _1  |-->_1`numpyType, numpy _1 _2  |-->_2`npRandomType<when> _1 matches .random, pd _1  |-->_1`pandasType, pandas _1  |-->_1`pandasType, sys _1  |-->_1`sysType, sys _1 _2  |-->_2`trailerOclType<when> _2 trailer, _1 if _2 else _3  |-->_1`ocltype, lambda _1 : _2  |-->Function, lambda : _1  |-->Function, * _1  |-->Sequence, ** _1  |-->Map, _1 ** _2  |-->double, + _1  |-->_1`ocltype, - _1  |-->_1`ocltype, ~ _1  |-->int, _1 * _2  |-->String<when> _1 String, _1 * _2  |-->Sequence<when> _1`ocltype Sequence, _1 * _2  |-->Sequence<when> _2`ocltype Sequence, _1 * _2  |-->int<when> _1`ocltype int, _2`ocltype int, _1 * _2  |-->double, _1 / _2  |-->double, _1 % _2  |-->String<when> _1 String, _1 % _2  |-->int, _1 // _2  |-->int, _1 @ _2  |-->Sequence, _1 + _2  |-->_1`ocltype, _1 - _2  |-->double, _1 << _2  |-->int, _1 >> _2  |-->int, _1 & _2  |-->int, _1 ^ _2  |-->int, _1 | _2  |-->Map<when> _1 Map, _1 | _2  |-->int, not _1  |-->boolean, _1 and _2  |-->boolean, _1 or _2  |-->boolean, _1 < _2  |-->boolean, _1 > _2  |-->boolean, _1 == _2  |-->boolean, _1 >= _2  |-->boolean, _1 <= _2  |-->boolean, _1 <> _2  |-->boolean, _1 != _2  |-->boolean, _1 not in _2  |-->boolean, _1 in _2  |-->boolean, _1 is not _2  |-->boolean, _1 is _2  |-->boolean, ( _1 )  |-->_1`ocltype, { _1 }  |-->Set<when> _1 dictorsetmaker, r _1  |-->String, R _1  |-->String, f _1  |-->String, _1 _2  |-->Sequence<when> _2 matches .shape, _1 _2  |-->OclIterator<when> _1 generator, _2 trailer, _1 _2  |-->_1<when> _1 Class, _2 trailer, _1 _2  |-->_2`mapTrailerType<when> _1 Map, _2 trailer, _1 _2  |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer, _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer, _1  |-->int<when> _1 int, _1  |-->double<when> _1 real, _1  |-->String<when> _1 String, _1  |-->Sequence<when> _1`isSequenceExpression true, _1  |-->_1`ocltype<when> _1 testlist_star_expr, _1  |-->_1`ocltype<when> _1 testlist, _1  |-->_1`ocltype<when> _1 trailer, _1  |-->_1`ocltype<when> _1 arglist, _1  |-->_1`ocltype<when> _1 argument, _1  |-->_1`ocltype<when> _1 arguments, _1  |-->_1`ocltype<when> _1 test, _1  |-->_1`ocltype<when> _1 logical_test, _1  |-->_1`ocltype<when> _1 comparison, _1  |-->_1`ocltype<when> _1 expr, _1  |-->_1`ocltype<when> _1 atom, _1  |-->_1`ocltype<when> _1 name, _1  |-->_1`ocltype<when> _1 subscriptlist, _1  |-->_1`ocltype<when> _1 subscript, _1  |-->_1`numberType<when> _1 number, _1  |-->OclAny, _*  |-->OclAny]
> Rule = _1  |-->String<when> _1 String has tokens [=, _1] variables [_1]
> Rule = _1  |-->int<when> _1 int has tokens [=, _1] variables [_1]
> Rule = _1  |-->double<when> _1 real has tokens [=, _1] variables [_1]
> Rule = _1  |-->Sequence<when> _1`isSequenceExpression true has tokens [=, _1] variables [_1]
> Rule = _1  |-->Map<when> _1`isMapExpression true has tokens [=, _1] variables [_1]
> Rule = _1  |-->_1`ocltype has tokens [=, _1] variables [_1]
> Rule True  |-->boolean has tokens [True] variables []
> Rule False  |-->boolean has tokens [False] variables []
> Rule inf  |-->double has tokens [inf] variables []
> Rule Infinity  |-->double has tokens [Infinity] variables []
> Rule nan  |-->double has tokens [nan] variables []
> Rule int  |-->int has tokens [int] variables []
> Rule float  |-->double has tokens [float] variables []
> Rule str  |-->String has tokens [str] variables []
> Rule dict  |-->Map has tokens [dict] variables []
> Rule list  |-->Sequence has tokens [list] variables []
> Rule deque  |-->Sequence has tokens [deque] variables []
> Rule set  |-->Set has tokens [set] variables []
> Rule tuple  |-->Sequence has tokens [tuple] variables []
> Rule bool  |-->boolean has tokens [bool] variables []
> Rule callable _1  |-->boolean has tokens [callable, _1] variables [_1]
> Rule bool _1  |-->boolean has tokens [bool, _1] variables [_1]
> Rule abs _1  |-->double has tokens [abs, _1] variables [_1]
> Rule all _1  |-->boolean has tokens [all, _1] variables [_1]
> Rule dict _1  |-->Map has tokens [dict, _1] variables [_1]
> Rule globals _1  |-->Map has tokens [globals, _1] variables [_1]
> Rule hex _1  |-->String has tokens [hex, _1] variables [_1]
> Rule id _1  |-->int has tokens [id, _1] variables [_1]
> Rule any _1  |-->boolean has tokens [any, _1] variables [_1]
> Rule ascii _1  |-->String has tokens [ascii, _1] variables [_1]
> Rule filter _1  |-->Sequence has tokens [filter, _1] variables [_1]
> Rule frozenset _1  |-->Set has tokens [frozenset, _1] variables [_1]
> Rule hash _1  |-->int has tokens [hash, _1] variables [_1]
> Rule input _1  |-->String has tokens [input, _1] variables [_1]
> Rule isinstance _1  |-->boolean has tokens [isinstance, _1] variables [_1]
> Rule issubclass _1  |-->boolean has tokens [issubclass, _1] variables [_1]
> Rule hasattr _1  |-->boolean has tokens [hasattr, _1] variables [_1]
> Rule len _1  |-->int has tokens [len, _1] variables [_1]
> Rule list _1  |-->Sequence has tokens [list, _1] variables [_1]
> Rule deque _1  |-->Sequence has tokens [deque, _1] variables [_1]
> Rule map _1  |-->Sequence has tokens [map, _1] variables [_1]
> Rule set _1  |-->Set has tokens [set, _1] variables [_1]
> Rule sorted _1  |-->Sequence has tokens [sorted, _1] variables [_1]
> Rule tuple _1  |-->Sequence has tokens [tuple, _1] variables [_1]
> Rule pow _1  |-->double has tokens [pow, _1] variables [_1]
> Rule repr _1  |-->String has tokens [repr, _1] variables [_1]
> Rule reversed _1  |-->Sequence has tokens [reversed, _1] variables [_1]
> Rule round _1  |-->double has tokens [round, _1] variables [_1]
> Rule print _1  |-->void has tokens [print, _1] variables [_1]
> Rule int _1  |-->int has tokens [int, _1] variables [_1]
> Rule float _1  |-->double has tokens [float, _1] variables [_1]
> Rule str _1  |-->String has tokens [str, _1] variables [_1]
> Rule format _1  |-->String has tokens [format, _1] variables [_1]
> Rule chr _1  |-->String has tokens [chr, _1] variables [_1]
> Rule unichr _1  |-->String has tokens [unichr, _1] variables [_1]
> Rule ord _1  |-->int has tokens [ord, _1] variables [_1]
> Rule type _1  |-->OclType has tokens [type, _1] variables [_1]
> Rule range _1  |-->Sequence has tokens [range, _1] variables [_1]
> Rule enumerate _1  |-->Sequence has tokens [enumerate, _1] variables [_1]
> Rule zip _1  |-->Sequence has tokens [zip, _1] variables [_1]
> Rule slice _1  |-->Sequence has tokens [slice, _1] variables [_1]
> Rule open _1  |-->OclFile has tokens [open, _1] variables [_1]
> Rule asyncio _1  |-->OclProcess has tokens [asyncio, _1] variables [_1]
> Rule collections _1  |-->_1`collectionsType has tokens [collections, _1] variables [_1]
> Rule math _1  |-->_1`mathType has tokens [math, _1] variables [_1]
> Rule re _1  |-->_1`reType has tokens [re, _1] variables [_1]
> Rule np _1  |-->_1`numpyType has tokens [np, _1] variables [_1]
> Rule np _1 _2  |-->_2`npRandomType<when> _1 matches .random has tokens [np, _1, _2] variables [_1, _2]
> Rule numpy _1  |-->_1`numpyType has tokens [numpy, _1] variables [_1]
> Rule numpy _1 _2  |-->_2`npRandomType<when> _1 matches .random has tokens [numpy, _1, _2] variables [_1, _2]
> Rule pd _1  |-->_1`pandasType has tokens [pd, _1] variables [_1]
> Rule pandas _1  |-->_1`pandasType has tokens [pandas, _1] variables [_1]
> Rule sys _1  |-->_1`sysType has tokens [sys, _1] variables [_1]
> Rule sys _1 _2  |-->_2`trailerOclType<when> _2 trailer has tokens [sys, _1, _2] variables [_1, _2]
> Rule _1 if _2 else _3  |-->_1`ocltype has tokens [_1, if, _2, else, _3] variables [_1, _2, _3]
> Rule lambda _1 : _2  |-->Function has tokens [lambda, _1, :, _2] variables [_1, _2]
> Rule lambda : _1  |-->Function has tokens [lambda, :, _1] variables [_1]
> Rule * _1  |-->Sequence has tokens [*, _1] variables [_1]
> Rule ** _1  |-->Map has tokens [**, _1] variables [_1]
> Rule _1 ** _2  |-->double has tokens [_1, **, _2] variables [_1, _2]
> Rule + _1  |-->_1`ocltype has tokens [+, _1] variables [_1]
> Rule - _1  |-->_1`ocltype has tokens [-, _1] variables [_1]
> Rule ~ _1  |-->int has tokens [~, _1] variables [_1]
> Rule _1 * _2  |-->String<when> _1 String has tokens [_1, *, _2] variables [_1, _2]
> Rule _1 * _2  |-->Sequence<when> _1`ocltype Sequence has tokens [_1, *, _2] variables [_1, _2]
> Rule _1 * _2  |-->Sequence<when> _2`ocltype Sequence has tokens [_1, *, _2] variables [_1, _2]
> Rule _1 * _2  |-->int<when> _1`ocltype int, _2`ocltype int has tokens [_1, *, _2] variables [_1, _2]
> Rule _1 * _2  |-->double has tokens [_1, *, _2] variables [_1, _2]
> Rule _1 / _2  |-->double has tokens [_1, /, _2] variables [_1, _2]
> Rule _1 % _2  |-->String<when> _1 String has tokens [_1, %, _2] variables [_1, _2]
> Rule _1 % _2  |-->int has tokens [_1, %, _2] variables [_1, _2]
> Rule _1 // _2  |-->int has tokens [_1, //, _2] variables [_1, _2]
> Rule _1 @ _2  |-->Sequence has tokens [_1, @, _2] variables [_1, _2]
> Rule _1 + _2  |-->_1`ocltype has tokens [_1, +, _2] variables [_1, _2]
> Rule _1 - _2  |-->double has tokens [_1, -, _2] variables [_1, _2]
> Rule _1 << _2  |-->int has tokens [_1, <<, _2] variables [_1, _2]
> Rule _1 >> _2  |-->int has tokens [_1, >>, _2] variables [_1, _2]
> Rule _1 & _2  |-->int has tokens [_1, &, _2] variables [_1, _2]
> Rule _1 ^ _2  |-->int has tokens [_1, ^, _2] variables [_1, _2]
> Rule _1 | _2  |-->Map<when> _1 Map has tokens [_1, |, _2] variables [_1, _2]
> Rule _1 | _2  |-->int has tokens [_1, |, _2] variables [_1, _2]
> Rule not _1  |-->boolean has tokens [not, _1] variables [_1]
> Rule _1 and _2  |-->boolean has tokens [_1, and, _2] variables [_1, _2]
> Rule _1 or _2  |-->boolean has tokens [_1, or, _2] variables [_1, _2]
> Rule _1 < _2  |-->boolean has tokens [_1, <, _2] variables [_1, _2]
> Rule _1 > _2  |-->boolean has tokens [_1, >, _2] variables [_1, _2]
> Rule _1 == _2  |-->boolean has tokens [_1, ==, _2] variables [_1, _2]
> Rule _1 >= _2  |-->boolean has tokens [_1, >=, _2] variables [_1, _2]
> Rule _1 <= _2  |-->boolean has tokens [_1, <=, _2] variables [_1, _2]
> Rule _1 <> _2  |-->boolean has tokens [_1, <>, _2] variables [_1, _2]
> Rule _1 != _2  |-->boolean has tokens [_1, !=, _2] variables [_1, _2]
> Rule _1 not in _2  |-->boolean has tokens [_1, not, in, _2] variables [_1, _2]
> Rule _1 in _2  |-->boolean has tokens [_1, in, _2] variables [_1, _2]
> Rule _1 is not _2  |-->boolean has tokens [_1, is, not, _2] variables [_1, _2]
> Rule _1 is _2  |-->boolean has tokens [_1, is, _2] variables [_1, _2]
> Rule ( _1 )  |-->_1`ocltype has tokens [(, _1, )] variables [_1]
> Rule { _1 }  |-->Set<when> _1 dictorsetmaker has tokens [{, _1, }] variables [_1]
> Rule r _1  |-->String has tokens [r, _1] variables [_1]
> Rule R _1  |-->String has tokens [R, _1] variables [_1]
> Rule f _1  |-->String has tokens [f, _1] variables [_1]
> Rule _1 _2  |-->Sequence<when> _2 matches .shape has tokens [_1, _2] variables [_1, _2]
> Rule _1 _2  |-->OclIterator<when> _1 generator, _2 trailer has tokens [_1, _2] variables [_1, _2]
> Rule _1 _2  |-->_1<when> _1 Class, _2 trailer has tokens [_1, _2] variables [_1, _2]
> Rule _1 _2  |-->_2`mapTrailerType<when> _1 Map, _2 trailer has tokens [_1, _2] variables [_1, _2]
> Rule _1 _2  |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer has tokens [_1, _2] variables [_1, _2]
> Rule _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer has tokens [_1, _2] variables [_1, _2]
> Rule _1  |-->int<when> _1 int has tokens [_1] variables [_1]
>***> Applying ruleset ocltype to ASTTerm name

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (name name)

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (atom (name name))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name name)))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name name))))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name name)))))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name name))))))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name name)))))))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))

>--> Replacing metafeature _1`ocltype by int
>***> RHS after replacement of metafeatures: int

>--> Replacing _1 by name
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))

>--> Replacing metafeature _2`ocltype by int
>***> RHS after replacement of metafeatures:   attribute Name : int;\n

>--> Replacing _1 by self.Name
>--> Replacing _2 by := name
>***> Applying ruleset attributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Name : int;

>***> RHS after replacement of metafeatures:   attribute Name : int;


>--> Replacing _1 by     self.Name := name
>***> Applying ruleset attributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Name : int;

>***> RHS after replacement of metafeatures:   attribute Name : int;


>--> Replacing _1 by     self.Name := name
>***> Applying ruleset attributeDefinitions to ASTTerm (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name))))))))))))

>--> Replacing metafeature _1`attributeDefinitions by   attribute Name : int;

>***> RHS after replacement of metafeatures:   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;


>--> Replacing _1 by     self.Name := name
>--> Replacing _* by     self.Num := num    self.Age := age    self.Degree := degree
>***> Applying ruleset attributeDefinitions to ASTTerm (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))

>--> Replacing metafeature _2`attributeDefinitions by   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

>***> RHS after replacement of metafeatures:   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;
\n  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : _$\n  pre: true post: true\n  activity:\n_2;\n    return self;\n\n

>--> Replacing _1 by self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny
>--> Replacing _2 by     self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree
>>>--- Global variable _$ has value Student

>--> Replacing global variable _$ by Student
>***> Applying ruleset methodDefinition to ASTTerm (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))

>--> Replacing metafeature _1`methodDefinition by   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


>***> RHS after replacement of metafeatures:   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;



>--> Replacing _1 by   operation __init__(self : OclAny, name : OclAny, num : OclAny, age : OclAny, degree : OclAny)
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;


>***> Applying ruleset classcontent to ASTTerm (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))

>--> Replacing metafeature _1`classcontent by   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


>***> RHS after replacement of metafeatures:   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;



>--> Replacing _1 by     skip
>***> Applying ruleset classcontent to ASTTerm (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree))))))))))))))))

>--> Replacing metafeature _1`classcontent by   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


>***> RHS after replacement of metafeatures:   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;



>--> Replacing _1 by     skip
>--> Replacing _* by     skip    skip
>***> Applying ruleset classcontent to ASTTerm (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))

>--> Replacing metafeature _2`classcontent by   attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;


>***> RHS after replacement of metafeatures: class _1 {\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n\n  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}\n\n

>--> Replacing _1 by Student
>--> Replacing _2 by     skip ;
    skip ;
    skip
>>>--- Global variable _$ has value Student

>--> Replacing global variable _$ by Student
>>>> Applying compound_stmt rule _1  |-->    skip for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>***> Metafeatures of rule _1  |-->    skip are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:     skip

>--> Replacing _1 by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


>>>> Applying stmt rule _1  |-->_1 for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     skip
>>>> Applying basic term name rule _1  |-->_1 for (name A1)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying atom rule _1  |-->_1 for (atom (name A1))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name A1)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name A1))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name A1)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name A1))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name A1)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying basic term name rule _1  |-->_1 for (name Student)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Student
>>>> Applying atom rule _1  |-->_1 for (atom (name Student))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Student
>>>> Applying basic term atom rule _1  |-->_1 for (atom "Jorge")
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying expr rule _1  |-->_1 for (expr (atom "Jorge"))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom "Jorge")))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom "Jorge"))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom "Jorge")))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying argument rule _1  |-->_1 for (argument (test (logical_test (comparison (expr (atom "Jorge"))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "Jorge"
>>>> Applying basic term atom rule _1  |-->_1 for (atom "123")
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying expr rule _1  |-->_1 for (expr (atom "123"))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom "123")))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom "123"))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom "123")))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying argument rule _1  |-->_1 for (argument (test (logical_test (comparison (expr (atom "123"))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by "123"
>>>> Applying basic term integer rule _1  |-->_1 for (integer 18)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*E.* for (number (integer 18))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 18)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*e.* for (number (integer 18))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 18)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying number rule _1  |-->_1 for (number (integer 18))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying atom rule _1  |-->_1 for (atom (number (integer 18)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying expr rule _1  |-->_1 for (expr (atom (number (integer 18))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (number (integer 18)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (number (integer 18))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (number (integer 18)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying argument rule _1  |-->_1 for (argument (test (logical_test (comparison (expr (atom (number (integer 18))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 18
>>>> Applying basic term integer rule _1  |-->_1 for (integer 80)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*E.* for (number (integer 80))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 80)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->("_1")->toReal()<when> _1 matches .*e.* for (number (integer 80))
>>>> Applying basic term integer rule _1  |-->_1 for (integer 80)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying number rule _1  |-->_1 for (number (integer 80))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying atom rule _1  |-->_1 for (atom (number (integer 80)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying expr rule _1  |-->_1 for (expr (atom (number (integer 80))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (number (integer 80)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (number (integer 80))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (number (integer 80)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying argument rule _1  |-->_1 for (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>>>> Applying arglist rule _1 , _*  |-->_1, _*`recurse for (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80)))))))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(argument (test (logical_test (comparison (expr (atom "123")))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(argument (test (logical_test (comparison (expr (atom "123")))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))]

>>>> Applying arglist rule _1 , _*  |-->_1, _*`recurse for (arglist (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80)))))))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))), ,, (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))]

>>>> Applying arglist rule _1 , _*  |-->_1, _*`recurse for (arglist (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80)))))))))
>***> Metafeatures of rule _1 , _*  |-->_1, _*`recurse are [_*`recurse]
>***> LHS tokens: [_1, ,, _*]


>***> Applying metafeature recurse to [(argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))] : java.util.Vector

>***> Applying recurse to vector of terms [(argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))]

>>>> Applying arglist rule _1  |-->_1 for (arglist (argument (test (logical_test (comparison (expr (atom (number (integer 80)))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by 80
>--> Replacing metafeature _*`recurse by 80
>> Applied vector rule: _1, 80
>***> RHS after replacement of metafeatures: _1, 80

>--> Replacing _1 by 18
>--> Replacing _* by 80
>--> Replacing metafeature _*`recurse by 18, 80
>> Applied vector rule: _1, 18, 80
>***> RHS after replacement of metafeatures: _1, 18, 80

>--> Replacing _1 by "123"
>--> Replacing _* by 18,80
>--> Replacing metafeature _*`recurse by "123", 18, 80
>> Applied vector rule: _1, "123", 18, 80
>***> RHS after replacement of metafeatures: _1, "123", 18, 80

>--> Replacing _1 by "Jorge"
>--> Replacing _* by "123",18,80
>>>> Applying arguments rule ( _1 )  |-->(_1) for (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))
>***> Metafeatures of rule ( _1 )  |-->(_1) are []
>***> LHS tokens: [(, _1, )]

>***> RHS after replacement of metafeatures: (_1)

>--> Replacing _1 by "Jorge", "123", 18, 80
>>>> Applying trailer rule _1  |-->_1 for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by ("Jorge", "123", 18, 80)
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
|||>> condition that type of (atom (name Student)) = Class is satisfied
||| ASTTerm condition _1 Class satisfied by term (atom (name Student))

||| Condition _1 Class is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: (_1.new_1()).initialise_2

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->_2`trailerSideEffect<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->_2`trailerSideEffect<when> _1 atom, _2 trailer are [_2`trailerSideEffect]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature trailerSideEffect to (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))) : ASTCompositeTerm

>***> Applying trailerSideEffect to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

>***> Valid ruleset trailerSideEffect

>>>> Applying trailer rule _1  |--> for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by ("Jorge", "123", 18, 80)
>***> Applying ruleset trailerSideEffect to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

>--> Replacing metafeature _2`trailerSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`hasTrailer for _1`
*** Metafeatures of _1`hasTrailer are: [_1`hasTrailer]
>***> Applying hasTrailer to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasTrailer<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 testlist are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (testlist (test (logical_test (comparison (expr (atom (name A1))))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)))))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (testlist (test (logical_test (comparison (expr (atom (name A1)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (testlist (test (logical_test (comparison (expr (atom (name A1)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1))))))
>>>> Applying testlist rule _1  |-->_1`hasTrailer<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 test are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (test (logical_test (comparison (expr (atom (name A1)))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (test (logical_test (comparison (expr (atom (name A1))))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (test (logical_test (comparison (expr (atom (name A1))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)))))
>>>> Applying test rule _1  |-->_1`hasTrailer<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 logical_test are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (logical_test (comparison (expr (atom (name A1))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (logical_test (comparison (expr (atom (name A1)))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1))))
>>>> Applying logical_test rule _1  |-->_1`hasTrailer<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 comparison are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (comparison (expr (atom (name A1)))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (comparison (expr (atom (name A1))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (comparison (expr (atom (name A1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (comparison (expr (atom (name A1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (comparison (expr (atom (name A1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist for (comparison (expr (atom (name A1))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist_star_expr for (comparison (expr (atom (name A1))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)))

||| Condition _1 expr is satisfied by (expr (atom (name A1)))
>>>> Applying comparison rule _1  |-->_1`hasTrailer<when> _1 expr for (comparison (expr (atom (name A1))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 expr are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (expr (atom (name A1))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (expr (atom (name A1)))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (expr (atom (name A1)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (expr (atom (name A1)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (expr (atom (name A1)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist for (expr (atom (name A1)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist_star_expr for (expr (atom (name A1)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 expr for (expr (atom (name A1)))
>>>> Applying expr rule _1  |-->false for (expr (atom (name A1)))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (expr (atom (name A1)))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (comparison (expr (atom (name A1))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (logical_test (comparison (expr (atom (name A1)))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (test (logical_test (comparison (expr (atom (name A1))))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)))))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>***> Applying ruleset hasTrailer to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>>> Applying small_stmt rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>***> Metafeatures of rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype are [_2`ocltype]
>***> LHS tokens: [_1, _2]

>>> found metafeature _1`defined for _1`
*** Set A1 tagged values: [defined=true]
>>> found metafeature _2`ocltype for _2`
>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset ocltype

*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->Sequence<when> _2 matches .shape for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator<when> _1 generator, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
|||>> condition that type of (atom (name Student)) = Class is satisfied
||| ASTTerm condition _1 Class satisfied by term (atom (name Student))

||| Condition _1 Class is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->_1<when> _1 Class, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->_1<when> _1 Class, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

*** A1 metafeature values set to [Student, defined=true]

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name Student))

||| Condition _1 atom is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>***> Valid ruleset ocltype

*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->Sequence<when> _2 matches .shape for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator<when> _1 generator, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
*** Metafeatures of _1 are: []
|||>> condition that type of (atom (name Student)) = Class is satisfied
||| ASTTerm condition _1 Class satisfied by term (atom (name Student))

||| Condition _1 Class is satisfied by (atom (name Student))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))

||| Condition _2 trailer is satisfied by (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))
>>>> Applying expr rule _1 _2  |-->_1<when> _1 Class, _2 trailer for (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))
>***> Metafeatures of rule _1 _2  |-->_1<when> _1 Class, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Student
>--> Replacing _2 by ("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))

>--> Replacing metafeature _1`ocltype by Student
>***> RHS after replacement of metafeatures: Student

>--> Replacing _1 by (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))

>--> Replacing metafeature _2`ocltype by Student
>***> RHS after replacement of metafeatures:     var _1 : Student _2

>--> Replacing _1 by A1
>--> Replacing _2 by := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying basic term name rule _1  |-->_1 for (name X)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying atom rule _1  |-->_1 for (atom (name X))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name X)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name X))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name X)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name X))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name X)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying basic term name rule _1  |-->_1 for (name A1)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying atom rule _1  |-->_1 for (atom (name A1))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1
>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>>> Applying arguments rule ( )  |-->() for (arguments ( ))
>***> Metafeatures of rule ( )  |-->() are []
>***> LHS tokens: [(, )]

>***> RHS after replacement of metafeatures: ()

>>>> Applying trailer rule . _1 _*  |-->._1_* for (trailer . (name Birthday_F) (arguments ( )))
>***> Metafeatures of rule . _1 _*  |-->._1_* are []
>***> LHS tokens: [., _1, _*]

>***> RHS after replacement of metafeatures: ._1_*

>--> Replacing _1 by Birthday_F
>--> Replacing _* by ()
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)<when> _2 matches .shape for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->size()<when> _2 matches .ndim for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.shape(_1)->prd()<when> _2 matches .size for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MatrixLib.flattenMatrix(_1)->first()->oclType()<when> _2 matches .dtype for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 atom, _2 matches .head\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator.newOclIterator_Function(lambda _i : int in self._1(_i))<when> _1 generator, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1.new_1()).initialise_2<when> _1 Class, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.mean(_1)<when> _1 atom, _2 matches .mean\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->MathLib.median(_1)<when> _1 atom, _2 matches .median\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.capitalise(_1)<when> _1 atom, _2 matches .capitalize\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>!!> Conditions failed of rule _1 _2  |-->StringLib.sumStringsWithSeparator(_2`third, _1)<when> _1 atom, _2`second join for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.toTitleCase(_1)<when> _1 atom, _2 matches .title\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.swapCase(_1)<when> _1 atom, _2 matches .swapcase\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.leftTrim(_1)<when> _1 atom, _2 matches .lstrip\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->StringLib.rightTrim(_1)<when> _1 atom, _2 matches .rstrip\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->(_1 = StringLib.toTitleCase(_1))<when> _1 atom, _2 matches .istitle\(\) for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>!!> Conditions failed of rule _1 _2  |-->StringLib.padLeftWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second rjust for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>!!> Conditions failed of rule _1 _2  |-->StringLib.padRightWithInto(_1,_2`justificationArguments)<when> _1 atom, _2`second ljust for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
>>> found metafeature _2`second for _2`
*** Metafeatures of _2`second are: [_2`second]
>***> Applying second to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>!!> Conditions failed of rule _1 _2  |-->StringLib.interpolateStrings(_1, _2`formatArguments)<when> _1 atom, _2`second format for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1->apply_*<when> _1 Function for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`mapQueryForm<when> _1 Map for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1_2`sequenceQueryForm<when> _1 Sequence for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
>>>> Applying expr rule _1 _*  |-->_1_*<when> _1 atom for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _*  |-->_1_*<when> _1 atom are []
>***> LHS tokens: [_1, _*]

>***> RHS after replacement of metafeatures: _1_*

>--> Replacing _1 by A1
>--> Replacing _* by .Birthday_F()
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1.Birthday_F()
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1.Birthday_F()
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1.Birthday_F()
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1.Birthday_F()
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by A1.Birthday_F()
>>> found metafeature _1`hasSideEffect for _1`
*** Metafeatures of _1`hasSideEffect are: [_1`hasSideEffect]
>***> Applying hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 testlist are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`hasSideEffect<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 logical_test are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`hasSideEffect<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 comparison are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasSideEffect<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`hasSideEffect<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`hasSideEffect<when> _1 expr are [_1`hasSideEffect]
>***> LHS tokens: [_1]


>***> Applying metafeature hasSideEffect to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying hasSideEffect to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset hasSideEffect

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->_2`trailerSideEffect<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->_2`trailerSideEffect<when> _1 atom, _2 trailer are [_2`trailerSideEffect]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature trailerSideEffect to (trailer . (name Birthday_F) (arguments ( ))) : ASTCompositeTerm

>***> Applying trailerSideEffect to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>***> Valid ruleset trailerSideEffect

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>>> Applying trailer rule . _1 _*  |--> for (trailer . (name Birthday_F) (arguments ( )))
>***> Metafeatures of rule . _1 _*  |--> are []
>***> LHS tokens: [., _1, _*]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by Birthday_F
>--> Replacing _* by ()
>***> Applying ruleset trailerSideEffect to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>--> Replacing metafeature _2`trailerSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`hasSideEffect by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset hasSideEffect to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>!!> Conditions failed of rule = _1  |-->:= _1 ; _1`updateForm<when> _1`hasSideEffect true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>>> Applying assign_part rule = _1  |-->:= _1 for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->:= _1 are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: := _1

>--> Replacing _1 by A1.Birthday_F()
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} := Sequence{_2`second}<when> _1 multiple, _2`isMultipleAssignPart true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
*** Metafeatures of _1 are: []
.>>>. Checking vector condition  multiple
>!!> Conditions failed of rule _1 _2  |-->_1`declareIfNecessary    Sequence{_1} _2<when> _1 multiple for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`colonAssign for _2`
*** Metafeatures of _2`colonAssign are: [_2`colonAssign]
>***> Applying colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule _1 _2  |-->false for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule _1 _2  |-->false are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by =
>--> Replacing _2 by A1.Birthday_F()
>***> Applying ruleset colonAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

>!!> Conditions failed of rule _1 _2  |-->    var _1 _2<when> _2`colonAssign true<action> _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`defined for _1`
*** Metafeatures of _1`defined are: [_1`defined]
>***> Applying defined to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`defined true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\..* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1 matches .*\[.* for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`hasTrailer for _1`
*** Metafeatures of _1`hasTrailer are: [_1`hasTrailer]
>***> Applying hasTrailer to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name X)))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name X)))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`hasTrailer<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 testlist are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (testlist (test (logical_test (comparison (expr (atom (name X))))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name X)))))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (testlist (test (logical_test (comparison (expr (atom (name X)))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (testlist (test (logical_test (comparison (expr (atom (name X)))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name X))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name X))))))
>>>> Applying testlist rule _1  |-->_1`hasTrailer<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name X)))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 test are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (test (logical_test (comparison (expr (atom (name X)))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (test (logical_test (comparison (expr (atom (name X))))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (test (logical_test (comparison (expr (atom (name X))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name X)))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name X)))))
>>>> Applying test rule _1  |-->_1`hasTrailer<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name X))))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 logical_test are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (logical_test (comparison (expr (atom (name X))))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (logical_test (comparison (expr (atom (name X)))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name X))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name X))))
>>>> Applying logical_test rule _1  |-->_1`hasTrailer<when> _1 comparison for (logical_test (comparison (expr (atom (name X)))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 comparison are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (comparison (expr (atom (name X)))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (comparison (expr (atom (name X))))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (comparison (expr (atom (name X))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (comparison (expr (atom (name X))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (comparison (expr (atom (name X))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist for (comparison (expr (atom (name X))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist_star_expr for (comparison (expr (atom (name X))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name X)))

||| Condition _1 expr is satisfied by (expr (atom (name X)))
>>>> Applying comparison rule _1  |-->_1`hasTrailer<when> _1 expr for (comparison (expr (atom (name X))))
>***> Metafeatures of rule _1  |-->_1`hasTrailer<when> _1 expr are [_1`hasTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature hasTrailer to (expr (atom (name X))) : ASTCompositeTerm

>***> Applying hasTrailer to ASTTerm (expr (atom (name X)))

>***> Valid ruleset hasTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 comparison for (expr (atom (name X)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 logical_test for (expr (atom (name X)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 test for (expr (atom (name X)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist for (expr (atom (name X)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 testlist_star_expr for (expr (atom (name X)))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`hasTrailer<when> _1 expr for (expr (atom (name X)))
>>>> Applying expr rule _1  |-->false for (expr (atom (name X)))
>***> Metafeatures of rule _1  |-->false are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (expr (atom (name X)))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (comparison (expr (atom (name X))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (logical_test (comparison (expr (atom (name X)))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (test (logical_test (comparison (expr (atom (name X))))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name X)))))))

>--> Replacing metafeature _1`hasTrailer by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by X
>***> Applying ruleset hasTrailer to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X))))))))

>!!> Conditions failed of rule _1 _2  |-->    _1 _2<when> _2`equalAssign true, _1`hasTrailer true for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>> found metafeature _2`equalAssign for _2`
*** Metafeatures of _2`equalAssign are: [_2`equalAssign]
>***> Applying equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


>>>> Applying assign_part rule = _1  |-->true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->true are []
>***> LHS tokens: [=, _1]

>***> RHS after replacement of metafeatures: true

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset equalAssign to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| ASTTerm condition _2`equalAssign true satisfied by term (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

||| Condition _2`equalAssign true is satisfied by (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>>> Applying small_stmt rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>***> Metafeatures of rule _1 _2  |-->    var _1 : _2`ocltype _2<when> _2`equalAssign true<action> _1`defined true, _1 _2`ocltype are [_2`ocltype]
>***> LHS tokens: [_1, _2]

>>> found metafeature _1`defined for _1`
*** Set X tagged values: [defined=true]
>>> found metafeature _2`ocltype for _2`
>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset ocltype

*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->Sequence<when> _2 matches .shape for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator<when> _1 generator, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 Class, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_2`mapTrailerType<when> _1 Map, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer are [_2`trailerOclType]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature trailerOclType to (trailer . (name Birthday_F) (arguments ( ))) : ASTCompositeTerm

>***> Applying trailerOclType to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>***> Valid ruleset trailerOclType

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>>> Applying trailer rule . _1 _2  |-->OclAny for (trailer . (name Birthday_F) (arguments ( )))
>***> Metafeatures of rule . _1 _2  |-->OclAny are []
>***> LHS tokens: [., _1, _2]

>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by Birthday_F
>--> Replacing _2 by ()
>***> Applying ruleset trailerOclType to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>--> Replacing metafeature _2`trailerOclType by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

*** X metafeature values set to [OclAny, defined=true]

>***> Applying metafeature ocltype to (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->String<when> _1 String for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->int<when> _1 int for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule = _1  |-->double<when> _1 real for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 testlist are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>!!> Conditions failed of rule = _1  |-->Sequence<when> _1`isSequenceExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>> found metafeature _1`isMapExpression for _1`
*** Metafeatures of _1`isMapExpression are: [_1`isMapExpression]
>***> Applying isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 testlist are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isMapExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isMapExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 logical_test are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isMapExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 comparison are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isMapExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isMapExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isMapExpression<when> _1 expr are [_1`isMapExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isMapExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isMapExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isMapExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`isMapExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isMapExpression to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>!!> Conditions failed of rule = _1  |-->Map<when> _1`isMapExpression true for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>>>> Applying assign_part rule = _1  |-->_1`ocltype for (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))
>***> Metafeatures of rule = _1  |-->_1`ocltype are [_1`ocltype]
>***> LHS tokens: [=, _1]


>***> Applying metafeature ocltype to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`isSequenceExpression<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`ocltype<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 testlist are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>>> Applying testlist rule _1  |-->_1`ocltype<when> _1 test for (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 comparison are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>>> Applying test rule _1  |-->_1`ocltype<when> _1 logical_test for (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 logical_test are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))


*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`isSequenceExpression<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`isSequenceExpression<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`isSequenceExpression<when> _1 expr are [_1`isSequenceExpression]
>***> LHS tokens: [_1]


>***> Applying metafeature isSequenceExpression to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset isSequenceExpression

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`isSequenceExpression by false
>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>>> Applying logical_test rule _1  |-->_1`ocltype<when> _1 comparison for (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 comparison are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>***> Valid ruleset ocltype

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->int<when> _1 int for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->double<when> _1 real for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->String<when> _1 String for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>>> found metafeature _1`isSequenceExpression for _1`
*** Metafeatures of _1`isSequenceExpression are: [_1`isSequenceExpression]
>***> Applying isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))


*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->false<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->false<when> _1 atom, _2 trailer are []
>***> LHS tokens: [_1, _2]

>***> RHS after replacement of metafeatures: false

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset isSequenceExpression to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>!!> Conditions failed of rule _1  |-->Sequence<when> _1`isSequenceExpression true for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist_star_expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 testlist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 trailer for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arglist for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 argument for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 arguments for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 logical_test for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`ocltype<when> _1 comparison for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

||| Condition _1 expr is satisfied by (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>>>> Applying comparison rule _1  |-->_1`ocltype<when> _1 expr for (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))
>***> Metafeatures of rule _1  |-->_1`ocltype<when> _1 expr are [_1`ocltype]
>***> LHS tokens: [_1]


>***> Applying metafeature ocltype to (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))) : ASTCompositeTerm

>***> Applying ocltype to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>***> Valid ruleset ocltype

*** Metafeatures of _2 are: []
>!!> Conditions failed of rule _1 _2  |-->Sequence<when> _2 matches .shape for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->OclIterator<when> _1 generator, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_1<when> _1 Class, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_2`mapTrailerType<when> _1 Map, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _2  |-->_2`sequenceTrailerType<when> _1 Sequence, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 atom satisfied by term (atom (name A1))

||| Condition _1 atom is satisfied by (atom (name A1))
*** Metafeatures of _2 are: []
||| ASTTerm condition _2 trailer satisfied by term (trailer . (name Birthday_F) (arguments ( )))

||| Condition _2 trailer is satisfied by (trailer . (name Birthday_F) (arguments ( )))
>>>> Applying expr rule _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer for (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))
>***> Metafeatures of rule _1 _2  |-->_2`trailerOclType<when> _1 atom, _2 trailer are [_2`trailerOclType]
>***> LHS tokens: [_1, _2]


>***> Applying metafeature trailerOclType to (trailer . (name Birthday_F) (arguments ( ))) : ASTCompositeTerm

>***> Applying trailerOclType to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>***> Valid ruleset trailerOclType

>>>> Applying basic term name rule _1  |-->_1 for (name Birthday_F)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by Birthday_F
>>>> Applying trailer rule . _1 _2  |-->OclAny for (trailer . (name Birthday_F) (arguments ( )))
>***> Metafeatures of rule . _1 _2  |-->OclAny are []
>***> LHS tokens: [., _1, _2]

>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by Birthday_F
>--> Replacing _2 by ()
>***> Applying ruleset trailerOclType to ASTTerm (trailer . (name Birthday_F) (arguments ( )))

>--> Replacing metafeature _2`trailerOclType by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1
>--> Replacing _2 by .Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))

>--> Replacing metafeature _1`ocltype by OclAny
>***> RHS after replacement of metafeatures: OclAny

>--> Replacing _1 by A1.Birthday_F()
>***> Applying ruleset ocltype to ASTTerm (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))

>--> Replacing metafeature _2`ocltype by OclAny
>***> RHS after replacement of metafeatures:     var _1 : OclAny _2

>--> Replacing _1 by X
>--> Replacing _2 by := A1.Birthday_F()
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
>>>> Applying basic term name rule _1  |-->_1 for (name X)
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying atom rule _1  |-->_1 for (atom (name X))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying expr rule _1  |-->_1 for (expr (atom (name X)))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom (name X))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom (name X)))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom (name X))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying argument rule _1  |-->_1 for (argument (test (logical_test (comparison (expr (atom (name X)))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying arglist rule _1  |-->_1 for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>>>> Applying arguments rule ( _1 )  |-->(_1) for (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))
>***> Metafeatures of rule ( _1 )  |-->(_1) are []
>***> LHS tokens: [(, _1, )]

>***> RHS after replacement of metafeatures: (_1)

>--> Replacing _1 by X
>>>> Applying trailer rule _1  |-->_1 for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)
>>>> Applying expr rule print _1  |-->_1`printTrailer->display() for (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))
>***> Metafeatures of rule print _1  |-->_1`printTrailer->display() are [_1`printTrailer]
>***> LHS tokens: [print, _1]


>***> Applying metafeature printTrailer to (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))

>***> Valid ruleset printTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 trailer for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 arguments satisfied by term (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

||| Condition _1 arguments is satisfied by (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))
>>>> Applying trailer rule _1  |-->_1`printTrailer<when> _1 arguments for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))
>***> Metafeatures of rule _1  |-->_1`printTrailer<when> _1 arguments are [_1`printTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature printTrailer to (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

>***> Valid ruleset printTrailer

>>>> Applying arguments rule ( _1 )  |-->(_1`printTrailer) for (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))
>***> Metafeatures of rule ( _1 )  |-->(_1`printTrailer) are [_1`printTrailer]
>***> LHS tokens: [(, _1, )]


>***> Applying metafeature printTrailer to (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))

>***> Valid ruleset printTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 trailer for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 arguments for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
>>>> Applying arglist rule _1  |-->_1 for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>***> Applying ruleset printTrailer to ASTTerm (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))

>--> Replacing metafeature _1`printTrailer by X
>***> RHS after replacement of metafeatures: (X)

>--> Replacing _1 by X
>***> Applying ruleset printTrailer to ASTTerm (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

>--> Replacing metafeature _1`printTrailer by (X)
>***> RHS after replacement of metafeatures: (X)

>--> Replacing _1 by (X)
>***> Applying ruleset printTrailer to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))

>--> Replacing metafeature _1`printTrailer by (X)
>***> RHS after replacement of metafeatures: (X)->display()

>--> Replacing _1 by (X)
>>>> Applying comparison rule _1  |-->_1 for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)->display()
>>>> Applying logical_test rule _1  |-->_1 for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)->display()
>>>> Applying test rule _1  |-->_1 for (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)->display()
>>>> Applying testlist rule _1  |-->_1 for (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)->display()
>>>> Applying testlist_star_expr rule _1  |-->_1 for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by (X)->display()
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 yield_expr for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist_star_expr satisfied by term (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))

||| Condition _1 testlist_star_expr is satisfied by (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))
>>>> Applying small_stmt rule _1  |-->_1`updateForm<when> _1 testlist_star_expr for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 testlist_star_expr are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))

>***> Valid ruleset updateForm

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist_star_expression for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 testlist satisfied by term (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))

||| Condition _1 testlist is satisfied by (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))
>>>> Applying testlist_star_expr rule _1  |-->_1`updateForm<when> _1 testlist for (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 testlist are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))

>***> Valid ruleset updateForm

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist_star_expression for (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist for (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 test satisfied by term (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))

||| Condition _1 test is satisfied by (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
>>>> Applying testlist rule _1  |-->_1`updateForm<when> _1 test for (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 test are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))

>***> Valid ruleset updateForm

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist_star_expression for (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist for (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 test for (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 logical_test satisfied by term (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))

||| Condition _1 logical_test is satisfied by (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
>>>> Applying test rule _1  |-->_1`updateForm<when> _1 logical_test for (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 logical_test are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))

>***> Valid ruleset updateForm

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist_star_expression for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 test for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 logical_test for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 comparison satisfied by term (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))

||| Condition _1 comparison is satisfied by (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
>>>> Applying logical_test rule _1  |-->_1`updateForm<when> _1 comparison for (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 comparison are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))

>***> Valid ruleset updateForm

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist_star_expression for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 testlist for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 test for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 logical_test for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`updateForm<when> _1 comparison for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 expr satisfied by term (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))

||| Condition _1 expr is satisfied by (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))
>>>> Applying comparison rule _1  |-->_1`updateForm<when> _1 expr for (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))
>***> Metafeatures of rule _1  |-->_1`updateForm<when> _1 expr are [_1`updateForm]
>***> LHS tokens: [_1]


>***> Applying metafeature updateForm to (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))) : ASTCompositeTerm

>***> Applying updateForm to ASTTerm (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))

>***> Valid ruleset updateForm

>>>> Applying expr rule print _1  |-->    execute _1`printTrailer->display() for (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))
>***> Metafeatures of rule print _1  |-->    execute _1`printTrailer->display() are [_1`printTrailer]
>***> LHS tokens: [print, _1]


>***> Applying metafeature printTrailer to (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))

>***> Valid ruleset printTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 trailer for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 arguments satisfied by term (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

||| Condition _1 arguments is satisfied by (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))
>>>> Applying trailer rule _1  |-->_1`printTrailer<when> _1 arguments for (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))
>***> Metafeatures of rule _1  |-->_1`printTrailer<when> _1 arguments are [_1`printTrailer]
>***> LHS tokens: [_1]


>***> Applying metafeature printTrailer to (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

>***> Valid ruleset printTrailer

>>>> Applying arguments rule ( _1 )  |-->(_1`printTrailer) for (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))
>***> Metafeatures of rule ( _1 )  |-->(_1`printTrailer) are [_1`printTrailer]
>***> LHS tokens: [(, _1, )]


>***> Applying metafeature printTrailer to (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) : ASTCompositeTerm

>***> Applying printTrailer to ASTTerm (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))

>***> Valid ruleset printTrailer

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 trailer for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`printTrailer<when> _1 arguments for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
>>>> Applying arglist rule _1  |-->_1 for (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by X
>***> Applying ruleset printTrailer to ASTTerm (arglist (argument (test (logical_test (comparison (expr (atom (name X))))))))

>--> Replacing metafeature _1`printTrailer by X
>***> RHS after replacement of metafeatures: (X)

>--> Replacing _1 by X
>***> Applying ruleset printTrailer to ASTTerm (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))

>--> Replacing metafeature _1`printTrailer by (X)
>***> RHS after replacement of metafeatures: (X)

>--> Replacing _1 by (X)
>***> Applying ruleset printTrailer to ASTTerm (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))

>--> Replacing metafeature _1`printTrailer by (X)
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)
>***> Applying ruleset updateForm to ASTTerm (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>***> Applying ruleset updateForm to ASTTerm (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>***> Applying ruleset updateForm to ASTTerm (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>***> Applying ruleset updateForm to ASTTerm (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>***> Applying ruleset updateForm to ASTTerm (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>***> Applying ruleset updateForm to ASTTerm (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))

>--> Replacing metafeature _1`updateForm by     execute (X)->display()
>***> RHS after replacement of metafeatures:     execute (X)->display()

>--> Replacing _1 by (X)->display()
>>>> Applying simple_stmt rule _1  |-->_1 for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     execute (X)->display()
>>>> Applying stmt rule _1  |-->_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>***> Metafeatures of rule _1  |-->_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by     execute (X)->display()
>>>> Applying file_input rule _1 _*  |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n for (file_input (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))))
>***> Metafeatures of rule _1 _*  |-->_1`classDefinitions\n_*`classDefinitions class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n are [_*`classDefinitions, _*`nestedAttributeDefinitions, _*`followingStatement, _*`functionDefinitions, _1`classDefinitions, _1`nestedAttributeDefinitions, _1`functionDefinitions]
>***> LHS tokens: [_1, _*]


>***> Applying metafeature classDefinitions to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))] : java.util.Vector

>***> Applying classDefinitions to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))]

>***> Valid ruleset classDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 classdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 classdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 classdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`classDefinitions<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     execute (X)->display()
>--> Replacing metafeature _*`classDefinitions by 
>> Applied vector rule: _1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n_*`nestedAttributeDefinitions\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n

>***> Applying metafeature nestedAttributeDefinitions to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))] : java.util.Vector

>***> Applying nestedAttributeDefinitions to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))]

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))
>>>> Applying stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>>>> Applying small_stmt rule _*  |--> for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))
>***> Metafeatures of rule _*  |--> are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: 

>--> Replacing _* by A1:= (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))
>>>> Applying stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1 _*  |-->_1`nestedAttributeDefinitions_*`nestedAttributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>>>> Applying small_stmt rule _*  |--> for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))
>***> Metafeatures of rule _*  |--> are []
>***> LHS tokens: [_*]

>***> RHS after replacement of metafeatures: 

>--> Replacing _* by X:= A1.Birthday_F()
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 simple_stmt satisfied by term (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))

||| Condition _1 simple_stmt is satisfied by (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))
>>>> Applying stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 small_stmt satisfied by term (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))

||| Condition _1 small_stmt is satisfied by (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
>>>> Applying simple_stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 funcdef for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
>>>> Applying small_stmt rule _1  |--> for (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by (X)->display()
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     execute (X)->display()
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) )))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     execute (X)->display()
>--> Replacing metafeature _*`nestedAttributeDefinitions by 
>> Applied vector rule: _1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n\n\n  operation initialise()\n  pre: true post: true\n  activity: _1_*`followingStatement;\n\n_1`functionDefinitions\n_*`functionDefinitions}\n

>***> Applying metafeature followingStatement to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))] : java.util.Vector

>***> Applying followingStatement to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))]

>***> Valid ruleset followingStatement

>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
>>>> Applying stmt rule _1  |--> ;\n_1 for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>***> Metafeatures of rule _1  |--> ;\n_1 are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures:  ;\n_1

>--> Replacing _1 by     execute (X)->display()
>--> Replacing metafeature _*`followingStatement by  ;
    var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80) ;
    var X : OclAny := A1.Birthday_F() ;
    execute (X)->display()
>> Applied vector rule: _1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n\n\n  operation initialise()\n  pre: true post: true\n  activity: _1 ;
    var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80) ;
    var X : OclAny := A1.Birthday_F() ;
    execute (X)->display();\n\n_1`functionDefinitions\n_*`functionDefinitions}\n

>***> Applying metafeature functionDefinitions to [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))] : java.util.Vector

>***> Applying functionDefinitions to vector of terms [(stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( ))))))))))))), (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))]

>***> Valid ruleset functionDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name Student)) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom "Jorge")))))) , (argument (test (logical_test (comparison (expr (atom "123")))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 18)))))))) , (argument (test (logical_test (comparison (expr (atom (number (integer 80))))))))) )))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name X)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name A1)) (trailer . (name Birthday_F) (arguments ( )))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     var X : OclAny := A1.Birthday_F()
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 funcdef for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>>>> Applying stmt rule _1  |--> for (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom print) (trailer (arguments ( (arglist (argument (test (logical_test (comparison (expr (atom (name X)))))))) ))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     execute (X)->display()
>--> Replacing metafeature _*`functionDefinitions by 
>> Applied vector rule: _1`classDefinitions\n class FromPython {\n_1`nestedAttributeDefinitions\n\n\n\n  operation initialise()\n  pre: true post: true\n  activity: _1 ;
    var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80) ;
    var X : OclAny := A1.Birthday_F() ;
    execute (X)->display();\n\n_1`functionDefinitions\n}\n

>***> Applying metafeature classDefinitions to (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))) : ASTCompositeTerm

>***> Applying classDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>***> Valid ruleset classDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 classdef for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>>>> Applying stmt rule _1  |-->_1`classDefinitions<when> _1 compound_stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
>***> Metafeatures of rule _1  |-->_1`classDefinitions<when> _1 compound_stmt are [_1`classDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature classDefinitions to (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))) : ASTCompositeTerm

>***> Applying classDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>***> Valid ruleset classDefinitions

*** Metafeatures of _1 are: []
||| ASTTerm condition _1 classdef satisfied by term (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))

||| Condition _1 classdef is satisfied by (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))
>>>> Applying compound_stmt rule _1  |-->_1<when> _1 classdef for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>***> Metafeatures of rule _1  |-->_1<when> _1 classdef are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: _1

>--> Replacing _1 by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


>***> Applying ruleset classDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>--> Replacing metafeature _1`classDefinitions by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


>***> RHS after replacement of metafeatures: class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}



>--> Replacing _1 by     skip
>***> Applying ruleset classDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>--> Replacing metafeature _1`classDefinitions by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}



>***> Applying metafeature nestedAttributeDefinitions to (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>>>> Applying stmt rule _1  |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
>***> Metafeatures of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt are [_1`nestedAttributeDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature nestedAttributeDefinitions to (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))) : ASTCompositeTerm

>***> Applying nestedAttributeDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>***> Valid ruleset nestedAttributeDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 stmt for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 simple_stmt for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 small_stmt for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 compound_stmt for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`nestedAttributeDefinitions<when> _1 funcdef for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>>>> Applying compound_stmt rule _1  |--> for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     skip
>***> Applying ruleset nestedAttributeDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>--> Replacing metafeature _1`nestedAttributeDefinitions by 

>***> Applying metafeature functionDefinitions to (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))) : ASTCompositeTerm

>***> Applying functionDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>***> Valid ruleset functionDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 funcdef for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
*** Metafeatures of _1 are: []
||| ASTTerm condition _1 compound_stmt satisfied by term (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

||| Condition _1 compound_stmt is satisfied by (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>>>> Applying stmt rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt for (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))
>***> Metafeatures of rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt are [_1`functionDefinitions]
>***> LHS tokens: [_1]


>***> Applying metafeature functionDefinitions to (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))) : ASTCompositeTerm

>***> Applying functionDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>***> Valid ruleset functionDefinitions

*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1<when> _1 funcdef for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
*** Metafeatures of _1 are: []
>!!> Conditions failed of rule _1  |-->_1`functionDefinitions<when> _1 compound_stmt for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>>>> Applying compound_stmt rule _1  |--> for (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))
>***> Metafeatures of rule _1  |--> are []
>***> LHS tokens: [_1]

>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


>***> Applying ruleset functionDefinitions to ASTTerm (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))))))))))))

>--> Replacing metafeature _1`functionDefinitions by 
>***> RHS after replacement of metafeatures: 

>--> Replacing _1 by     skip
>***> Applying ruleset functionDefinitions to ASTTerm (stmt (compound_stmt (classdef class (name Student) : (suite (stmt (compound_stmt (funcdef def (name __init__) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name name))) , (def_parameter (named_parameter (name num))) , (def_parameter (named_parameter (name age))) , (def_parameter (named_parameter (name degree))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Name)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name name)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Num)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name num)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name age)))))))))))) (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part = (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name degree)))))))))))))))) (stmt (compound_stmt (funcdef def (name Degree_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))) , (def_parameter (named_parameter (name n))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Degree)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (name n))))))))))))))) (stmt (compound_stmt (funcdef def (name Birthday_F) ( (typedargslist (def_parameters (def_parameter (named_parameter (name self))))) ) : (suite (stmt (simple_stmt (small_stmt (testlist_star_expr (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age)))))))) (assign_part += (testlist (test (logical_test (comparison (expr (atom (number (integer 1)))))))))))) (stmt (simple_stmt (small_stmt return (testlist (test (logical_test (comparison (expr (atom (name self)) (trailer . (name Age))))))))))))))))))

>--> Replacing metafeature _1`functionDefinitions by 
>***> RHS after replacement of metafeatures: class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}

\n class FromPython {\n\n\n\n\n  operation initialise()\n  pre: true post: true\n  activity: _1 ;
    var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80) ;
    var X : OclAny := A1.Birthday_F() ;
    execute (X)->display();\n\n\n}\n

>--> Replacing _1 by     skip
>--> Replacing _* by     var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80)    var X : OclAny := A1.Birthday_F()    execute (X)->display()
class Student {
  static operation newStudent() : Student
  pre: true
  post: Student->exists( _x | result = _x );

  attribute Name : int;
  attribute Num : OclAny;
  attribute Age : OclAny;
  attribute Degree : OclAny;

  operation initialise(name : OclAny,num : OclAny,age : OclAny,degree : OclAny) : Student
  pre: true post: true
  activity:
    self.Name := name ;
    self.Num := num ;
    self.Age := age ;
    self.Degree := degree;
    return self;


  operation Degree_F(n : OclAny)
  pre: true post: true
  activity:
    self.Degree := self.Degree + n;


  operation Birthday_F() : OclAny
  pre: true post: true
  activity:
    self.Age := self.Age + 1 ;
    return self.Age;

}


 class FromPython {




  operation initialise()
  pre: true post: true
  activity:     skip ;
    var A1 : Student := (Student.newStudent()).initialise("Jorge", "123", 18, 80) ;
    var X : OclAny := A1.Birthday_F() ;
    execute (X)->display();


}


>>> Time for processing AST = 357

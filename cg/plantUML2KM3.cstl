classDiagram::
@startuml _* @enduml _2 |-->package app {\n _* }


cdelement::
class _1 _2 _3 |-->class _1 _3\n
class _1 _2 |-->class _1 _2\n<when> _2 classDefinition
class _1 _2 |-->class _1 { }\n 
class _1 |-->class _1 { }\n 

entity _1 _2 _3 |-->class _1 _3\n
entity _1 _2 |-->class _1 _2\n<when> _2 classDefinition
entity _1 _2 |-->class _1 { }\n 
entity _1 |-->class _1 { }\n 

interface _1 _2 _3 |-->interface _1 _3\n
interface _1 _2 |-->interface _1 _2\n<when> _2 classDefinition
interface _1 _2 |-->interface _1 { }\n 
interface _1 |-->interface _1 { }\n 

abstract class _1 _2 _3 |-->abstract class _1 _3\n
abstract class _1 _2 |-->abstract class _1 _2\n<when> _2 classDefinition
abstract class _1 _2 |-->abstract class _1 { }\n 
abstract class _1 |-->abstract class _1 { }\n 

abstract _1 _2 _3 |-->abstract class _1 _3\n
abstract _1 _2 |-->abstract class _1 _2\n<when> _2 classDefinition
abstract _1 _2 |-->abstract class _1 { }\n 
abstract _1 |-->abstract class _1 { }\n 

enum _1 _2 _3 |--> enumeration _1 _3\n
enum _1 _2 |--> enumeration _1 _2\n <when> _2 enumDefinition
enum _1 _2 |--> enumeration _1 { }\n 
enum _1 |--> enumeration _1 { }\n 

annotation _1 |-->

_1 |-->_1


inheritance::
_1 _2 _3 |-->class _1 extends _3 { }\n<when> _2 leftAncestorSymbol
_1 _2 _3 |-->class _3 extends _1 { }\n<when> _2 rightAncestorSymbol


association::
_1 _2 _3 _4 _5 _6 |-->class _1 { reference ref_5 [_4] : _5; }\n
_1 _2 _3 _4 _5 |-->class _1 { reference ref_5 [_4] : _5; }\n<when> _5 identifier
_1 _2 _3 _4 |-->class _1 { reference ref_4 [_3] : _4; }\n<when> _3 stringExpression
_1 _2 _3 _4 |-->class _1 { reference ref_4 [1] : _4; }\n
_1 _2 _3 |-->class _1 { reference ref_3 [1] : _3; }\n




classDefinition::
{ } |-->{ }\n 
{ _* } |-->{\n _* }\n


classElement::
_1 |-->_1


enumDefinition::
{ _* } |-->{ _*`enumliteral }


enumliteral::
_1 |--> literal _1; 


attribute::
_1 : _2 _3 _4 |-->class _1 { attribute _4 : _2; }\n 
_1 : _2 _3 |-->class _1 { attribute _3 : _2; }\n


internalAttribute:: 
{ _1 } _2 _3 : _4 |-->  _1 attribute _3 : _4;\n
{ _1 } _2 : _3 |-->  _1 attribute _3 : _4;\n

{ _1 } _2 _3 _4 |-->  _1 attribute _4 : _2;\n
{ _1 } _2 _3 |-->  _1 attribute _3 : _2;\n<when> _2 type
{ _1 } _2 _3 |-->  _1 attribute _3 : OclAny;\n
{ _1 } _2 |-->  _1 attribute _2 : OclAny;\n<when> _2 type

_1 _2 : _3 |-->  attribute _2 : _3;\n
_1 : _2 |-->  attribute _1 : _2;\n

_1 _2 _3 |-->  attribute _3 : _1;\n
_1 _2 |-->  attribute _2 : _1;\n<when> _1 type
_1 _2 |-->  attribute _2 : OclAny;\n
_1 |-->  attribute _1 : OclAny;\n


visibility:: 
_1 |-->


stereotype::
_* |-->


identifier::
_1 |-->_1


stringExpression::
"many" |-->*
"*" |-->*
"one" |-->1
"1" |-->1
_1 |-->_1


type::
Sequence ( _1 ) |-->Sequence(_1)
Set ( _1 ) |-->Set(_1)
Bag ( _1 ) |-->SortedSequence(_1)
OrderedSet ( _1 ) |-->OrderedSet(_1) 
SortedSet ( _1 ) |-->SortedSet(_1) 
_1 [ _2 ] |-->Sequence(_1)  
Map ( _1 , _2 ) |-->Map(_1,_2) 
SortedMap ( _1 , _2 ) |-->SortedMap(_1,_2) 
Function ( _1 , _2 ) |-->Function(_1,_2) 
_1 |-->_1


modifier::
classifier |-->static
_1 |-->_1


leftAncestorSymbol::
_1 |-->_1


rightAncestorSymbol::
_1 |-->_1


